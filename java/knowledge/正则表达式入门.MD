### 1.元字符 

万物皆有源，正则也是如此，元字符是构造正则表达式的一种基本元素。
我们先来记几个常用的元字符：

| 元字符 | 说明                         |
| ------ | ---------------------------- |
| .      | 匹配除换行符以外的任意字符   |
| \w     | 匹配字母或数字或下划线或汉字 |
| \s     | 匹配任意的空白符             |
| \d     | 匹配数字                     |
| \b     | 匹配单词的开始或结束         |
| ^      | 匹配字符串的开始             |
| $      | 匹配字符串的结束             |

有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，
比如：

1. 匹配有abc开头的字符串：

```java
1\babc或者^abc
```

1. 匹配8位数字的QQ号码：

```java
1^\d\d\d\d\d\d\d\d$
```

1. 匹配1开头11位数字的手机号码：

```java
1^1\d\d\d\d\d\d\d\d\d\d$
```

### 2. 重复限定符 

有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？

答案是有的！
为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：

| 语法  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ?     | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |

有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：

1. 匹配8位数字的QQ号码：

```java
1^\d{8}$
```

1. 匹配1开头11位数字的手机号码：

```java
1^1\d{10}$
```

1. 匹配银行卡号是14~18位的数字：

```java
1^\d{14,18}$
```

1. 匹配以a开头的，0个或多个b结尾的字符串

```java
1^ab*$
```

### 3. 分组 

从上面的例子（4）中看到，*限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被*限定那怎么办呢？

> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。

因此当我们要匹配多个ab时，我们可以这样
如：匹配字符串中包含0到多个ab开头：

```java
1^(ab)*
```

### 4. 转义 

我们看到正则表达式用小括号来做分组，那么问题来了：

> 如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？

针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。
如：要匹配以(ab)开头：

```java
1^(\(ab\))*
```

### 5. 条件或 

回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？

> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们就可以用或条件来处理这个问题

```java
1^(130|131|132|155|156|185|186|145|176)\d{8}$
```

### 6. 区间 

看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？
实际是有的

> 正则提供一个元字符中括号 [] 来表示区间条件。
>
> 1. 限定0到9 可以写成[0-9]
> 2. 限定A-Z 写成[A-Z]
> 3. 限定某些数字 [165]

那上面的正则我们还改成这样：

```java
1^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```