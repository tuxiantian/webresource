### spring-task
```xml
<task:scheduler id="taskScheduler" pool-size="50" />
<task:scheduled-tasks  scheduler="taskScheduler">  
    <task:scheduled ref="voiceFileClearJob" method="execute" initial-delay="5000" fixed-delay="3600000"/>  
    <task:scheduled ref="versionListenJob" method="execute" initial-delay="5000" fixed-delay="5000"/>  
    <task:scheduled ref="statJob" method="statLgj" cron="0 59 23 * * ?"/>  
    <task:scheduled ref="statJob" method="statBadNameAndQQ" cron="23 28 20 * * ?"/>  
</task:scheduled-tasks>  
```
第一个任务表示程序启动5s后调用voiceFileClearJob类中的execute方法，然后每隔一个小时再调用execute一次  

第三个任务表示每天的23点59分调用statJob类中的statLgj方法  

#### spring-task的周期执行任务测试
spring-task的周期执行任务，若下一个周期到来，而上一个周期的任务没有完成，那么下个周期也会执行。  
```xml
<bean id="testJob" class="com.laijia.biz.task.TestJob"></bean>
<task:scheduled-tasks>
        <!--<task:scheduled ref="testJob" method="execute" initial-delay="1000" fixed-rate="1000"/>-->
        <task:scheduled ref="testJob" method="execute" cron="0/1 * * * * ? "/>
</task:scheduled-tasks>
```
测试代码如下：
```java
public class TestJob {

    public void execute(){
        System.out.println("开始执行："+DateUtil.date2String(new Date()));
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.currentThread().sleep(3000);
                    System.out.println("执行完成");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
}
```
```
运行结果：
开始执行：2017-09-18 17:10:02
执行完成
执行完成
开始执行：2017-09-18 17:10:03
开始执行：2017-09-18 17:10:04
执行完成
开始执行：2017-09-18 17:10:05
执行完成
开始执行：2017-09-18 17:10:06
执行完成
执行完成
开始执行：2017-09-18 17:10:07
执行完成
开始执行：2017-09-18 17:10:08
执行完成
开始执行：2017-09-18 17:10:09
开始执行：2017-09-18 17:10:10
执行完成
执行完成
```

> ref是工作类  
>
> method是工作类中要执行的方法  
>
> initial-delay是任务第一次被调用前的延时，单位`毫秒`  
>
> fixed-delay是上一个调用完成后再次调用的延时  
>
> fixed-rate是上一个调用开始后再次调用的延时（不用等待上一次调用完成） 
>
> cron是表达式，表示在什么时候进行任务调度。  

**cron表达式：**  

一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。  
按顺序依次为  
秒（0~59）  
分钟（0~59）  
小时（0~23）  
天（月）（0~31，但是你需要考虑你月的天数）  
月（0~11）  
天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）  
年份（1970－2099）  

其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18/4)(/表示每隔4小时),一个列表(1,3,5),通配符。由于"月份中的日期"和"星期中的日期"这两个元素互斥的,必须要对其中一个设置?.

0 0 10,14,16 * * ? 每天上午10点，下午2点，4点  
0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时  
0 0 12 ? * WED 表示每个星期三中午12点  
"0 0 12 * * ?" 每天中午12点触发  
"0 15 10 ? * *" 每天上午10:15触发  
"0 15 10 * * ?" 每天上午10:15触发  
"0 15 10 * * ? *" 每天上午10:15触发  
"0 15 10 * * ? 2005" 2005年的每天上午10:15触发  
"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发  
"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发  
"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发  
"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发  
"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发  
"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发  
"0 15 10 15 * ?" 每月15日上午10:15触发  
"0 15 10 L * ?" 每月最后一日的上午10:15触发  
"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发  
"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发  
"0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发  

有些子表达式能包含一些范围或列表  
例如：子表达式（天（星期） ）可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”  

“*”字符代表所有可能的值  
因此，“*”在子表达式（月 ）里表示每个月的含义，“*”在子表达式（天（星期） ）表示星期的每一天  

“/”字符用来指定数值的增量  
例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟  
在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样  

“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值
当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”  
“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写  
但是它在两个子表达式里的含义是不同的。  
在天（月）子表达式中，“L”表示一个月的最后一天  
在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT  
如果在“L”前有具体的内容，它就具有其他的含义了  
例如：“6L”表示这个月的倒数第６天，“ＦＲＩＬ”表示这个月的最一个星期五  
注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题  

|    字段    |      允许值       | 允许的特殊字符  |
| ---------- | ----------------- | :-------------- |
| 秒         | 0-59              | , - * /         |
| 分         | 0-59              | , - * /         |
| 小时       | 0-23              | , - * /         |
| 日期       | 1-31              | , - * ? / L W C |
| 月份       | 1-12 或者 JAN-DEC | , - * /         |
| 星期       | 1-7 或者 SUN-SAT  | , - * ? / L C # |
| 年（可选） | 留空, 1970-2099   | , - * /         |